


<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Emoji Royale</title>

    <script>
        (function () {
            const fakeTitle = 'Google';
            const fakeUrl = 'https://www.google.com';
            document.title = fakeTitle;
            if (window.history && window.history.replaceState) {
                try {
                    window.history.replaceState(null, fakeTitle, fakeUrl);
                } catch (err) {
                    // Ignore; some origins prevent history manipulation with cross-origin paths.
                }
            }
        })();
    </script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2344719724787837"

     crossorigin="anonymous"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Import Google Font -->

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

    <script>

        window.isLocalFile = window.location.protocol === 'file:';

        if (!window.isLocalFile) {

            document.documentElement.setAttribute('data-no-debug', '');

        }

    </script>

    <script>

        function solveSimpleChallenge() {

            // Stub to satisfy external challenge hook; no extra logic required.

            return true;

        }

    </script>

    <style>

.hidden { display: none; }

:root {

            --bg-dark: #090d1e;

            --bg-mid: #111530;

            --bg-glow: rgba(59, 130, 246, 0.35);

            --bg-accent: rgba(34, 197, 94, 0.25);

            --panel-bg: rgba(15, 23, 42, 0.65);

            --panel-border: rgba(59, 130, 246, 0.45);

            --accent: #ec4899;

            --text-muted: #cbd5f5;

            --glossy-panel-bg: rgba(15, 23, 42, 0.75);

            --glossy-panel-border: rgba(59, 130, 246, 0.4);

            --glossy-panel-shadow: 0 25px 40px rgba(2, 6, 23, 0.7);

            --glossy-btn-bg: linear-gradient(135deg, rgba(59, 130, 246, 0.4), rgba(15, 23, 42, 0.95));

        --glossy-btn-border: 1px solid rgba(255, 255, 255, 0.25);

        --glossy-btn-shadow: 0 15px 30px rgba(2, 6, 23, 0.7), inset 0 2px 0 rgba(255, 255, 255, 0.15);

        --active-mode-glow: 239, 68, 68;

        --mode-aura-color: 239, 68, 68;

        }

        .glossy-panel {

            background: var(--glossy-panel-bg);

            border: 1px solid var(--glossy-panel-border);

            box-shadow: var(--glossy-panel-shadow), 0 0 25px rgba(59, 130, 246, 0.1);

            backdrop-filter: blur(22px);

            position: relative;

            overflow: hidden;

        }

        .glossy-panel::after {

            content: '';

            position: absolute;

            inset: 0;

            background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.35), transparent 60%);

            opacity: 0;

            transition: opacity 0.4s ease;

            pointer-events: none;

            mix-blend-mode: screen;

        }

        .glossy-panel:hover::after {

            opacity: 1;

        }

        .glossy-btn {

            background: var(--glossy-btn-bg);

            border: var(--glossy-btn-border);

            border-radius: 12px;

            color: #f8fafc;

            box-shadow: var(--glossy-btn-shadow);

            position: relative;

            overflow: hidden;

            transition: transform 0.2s ease, box-shadow 0.2s ease;

        }

        .glossy-btn::after {

            content: '';

            position: absolute;

            inset: 0;

            background: linear-gradient(180deg, rgba(255, 255, 255, 0.3), transparent 60%);

            opacity: 0;

            transition: opacity 0.3s ease;

        }

        .glossy-btn:hover::after {

            opacity: 1;

        }

        body {

            font-family: 'Inter', sans-serif;

            overflow: hidden;

            touch-action: none;

            position: relative;

            background:

                radial-gradient(circle at 15% 20%, rgba(109, 201, 112, 0.4), transparent 35%),

                radial-gradient(circle at 85% 5%, rgba(51, 112, 64, 0.3), transparent 33%),

                linear-gradient(145deg, #1f4720 0%, #0b2d0b 55%, #030e02 100%);

            background-attachment: fixed;

            color: #f8fafc;

            /* Remove 3D perspective to keep the game board flat */

            perspective: none;

            transform-style: preserve-3d;

        }

        body::before {

            content: '';

            position: fixed;

            inset: 0;

            background-image: radial-gradient(circle, rgba(8, 40, 12, 0.45) 1px, transparent 1px);

            background-size: 22px 22px;

            opacity: 0.35;

            pointer-events: none;

            z-index: -1;

        }

        #bgCanvas {

            position: fixed;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            z-index: -1;

            pointer-events: none;

            filter: blur(1px);

        }

        /* Floating leave action that uses location.replace for the safe redirect */
        .leave-site-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            padding: 0.45rem 1rem;
            border-radius: 999px;
            border: 1px solid rgba(248, 250, 252, 0.5);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.6), rgba(244, 63, 94, 0.7));
            color: #f8fafc;
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            box-shadow: 0 15px 30px rgba(2, 6, 23, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .leave-site-button:hover {
            transform: translateY(-1px);
        }
        .leave-site-button:focus-visible {
            outline: 3px solid rgba(59, 130, 246, 0.8);
            outline-offset: 3px;
        }

        h1, h2, h3 {

            letter-spacing: 2px;

        }

        /* Button Shine Effect */

        .btn-shine {

            position: relative;

            overflow: hidden;

        }

        .btn-shine::after {

            content: '';

            position: absolute;

            top: 0;

            left: -100%;

            width: 50%;

            height: 100%;

            background: linear-gradient(to right, transparent, rgba(255,255,255,0.4), transparent);

            transform: skewX(-20deg);

            transition: none;

        }

        .btn-shine:hover::after {

            left: 150%;

            transition: 0.6s ease-in-out;

        }

        /* Button Ripple Effect */

        .ripple-btn {

            position: absolute;

            border-radius: 50%;

            transform: scale(0);

            animation: rippleBtn 0.6s linear;

            background-color: rgba(255, 255, 255, 0.4);

            pointer-events: none;

        }

        @keyframes rippleBtn {

            to {

                transform: scale(4);

                opacity: 0;

            }

        }

        @keyframes particleMove {

            from { background-position: 0 0, 12px 12px, 0 0, 0 0; }

            to { background-position: 20px 20px, 30px 30px, 0 0, 0 0; }

        }

        @keyframes slideInRight {

            from { transform: translateX(100%); opacity: 0; }

            to { transform: translateX(0); opacity: 1; }

        }

        @keyframes slideInLeft {

            from { transform: translateX(-100%); opacity: 0; }

            to { transform: translateX(0); opacity: 1; }

        }

        @keyframes fadeIn {

            from { opacity: 0; }

            to { opacity: 1; }

        }

        .screen {

            display: none;

            width: 100%;

            height: 100vh;

            overflow-y: auto;

            padding-bottom: 6rem; /* Space for fixed nav */

            position: absolute; /* Fix for stacking */

            top: 0; left: 0; right: 0; bottom: 0;

            background: transparent; /* Allow body bg to show */

        }

        .screen.active {

            display: flex;

            z-index: 10;

            /* Animation handled by JS class toggle */

        }

        .screen.swipe-right {

            animation: slideInRight 0.3s cubic-bezier(0.25, 1, 0.5, 1);

        }

        .screen.swipe-left {

            animation: slideInLeft 0.3s cubic-bezier(0.25, 1, 0.5, 1);

        }

        .screen.fade-in {

            animation: fadeIn 0.4s ease-out;

        }

        #eventsScreen {

            position: relative;

            background: transparent;

        }

        #eventsScreen .event-section {

            position: relative;

            z-index: 1;

        }

        #eventsScreen .event-card {

            border-radius: 20px;

            border: 1px solid rgba(255, 255, 255, 0.15);

            background: rgba(15, 23, 42, 0.85);

            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.45);

            padding: 1.5rem;

        }

        #eventsScreen .event-card button {

            width: 100%;

        }

        .event-card-kicker {

            font-size: 0.75rem;

            letter-spacing: 0.2em;

            text-transform: uppercase;

            color: #c7f3c0;

        }

        /* Nav Active State (Replaces Highlight Box) */

        .nav-btn.active-nav {

            border: 2px solid #facc15;

            background: rgba(255, 255, 255, 0.1);

            border-radius: 12px;

            box-shadow: 0 0 15px rgba(250, 204, 21, 0.2);

        }

        /* Improved Chest Click Area */

        #chestClickArea {

            outline: none;

            -webkit-tap-highlight-color: transparent;

            user-select: none;

        }

        /* Reward Pop Animation */

        @keyframes rewardPop {

            0% { transform: scale(0); opacity: 0; }

            60% { transform: scale(1.1); opacity: 1; }

            100% { transform: scale(1); opacity: 1; }

        }

        .reward-item {

            animation: rewardPop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;

            box-shadow: inset 0 3px 6px rgba(0,0,0,0.5);

            border: 2px solid #374151;

            background-color: #374151;

            border-radius: 8px;

        }

        @keyframes shakeBox {

            0%, 100% { transform: rotate(0deg); }

            25% { transform: rotate(-5deg); }

            75% { transform: rotate(5deg); }

        }

        .shake-anim {

            animation: shakeBox 0.2s ease-in-out;

        }

        .nav-btn {

            position: relative;

            z-index: 1;

            border-radius: 12px;

            padding: 0.75rem 0;

            transition: color 0.2s ease, background 0.2s ease;

            background: var(--glossy-btn-bg);

            border: var(--glossy-btn-border);

            box-shadow: var(--glossy-btn-shadow);

            backdrop-filter: blur(12px);

            font-weight: bold;

            color: #f8fafc;

        }

        .nav-badge {

            position: absolute;

            top: 4px;

            right: 10px;

            width: 18px;

            height: 18px;

            border-radius: 999px;

            background: #facc15;

            color: #111;

            font-size: 0.65rem;

            font-weight: 800;

            display: flex;

            align-items: center;

            justify-content: center;

            box-shadow: 0 0 6px rgba(0, 0, 0, 0.4);

            transition: transform 0.25s ease, opacity 0.25s ease;

        }

        .nav-badge.hidden {

            opacity: 0;

            transform: translateY(-4px) scale(0.4);

        }

        .nav-btn::before {

            content: '';

            position: absolute;

            inset: 6px 8px 6px;

            border-radius: 10px;

            background: rgba(255, 255, 255, 0.04);

            opacity: 0;

            transition: opacity 0.2s ease;

        }

        .nav-btn:hover::before,

        .nav-btn.active-nav::before {

            opacity: 1;

        }

        /* Ripple Effect */

        .ripple {

            position: absolute;

            border-radius: 50%;

            transform: scale(0);

            animation: ripple 0.6s linear;

            background-color: rgba(255, 255, 255, 0.7);

            pointer-events: none;

            z-index: 9999;

        }

        @keyframes ripple {

            to {

                transform: scale(4);

                opacity: 0;

            }

        }

        /* Floating Emoji */

        @keyframes floatRotate {

            0%, 100% { transform: translateY(0) rotate(0deg); }

            50% { transform: translateY(-20px) rotate(5deg); }

        }

        /* Click Pulse Effect */

        @keyframes pulse-ring {

            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }

            100% { box-shadow: 0 0 0 15px rgba(255, 255, 255, 0); }

        }

        .btn-pulse-anim {

            animation: pulse-ring 0.4s ease-out;

        }

        #arenaEmoji {

            display: inline-block;

            animation: floatRotate 6s ease-in-out infinite;

        }

        .ui-text-effect {

            font-weight: 900;

            letter-spacing: 0.5px;

        }

        .your-boxes-text {

            color: #ffffff;

            font-weight: 900;

            text-shadow: 

                2px 2px 0 #000,

                -1px -1px 0 #000,

                1px -1px 0 #000,

                -1px 1px 0 #000,

                1px 1px 0 #000,

                3px 3px 0 #000,

                4px 4px 0 #000;

        }

        .battle-arena-name {

            color: #ffffff;

            font-weight: 900;

            text-shadow: 

                2px 2px 0 #000,

                -1px -1px 0 #000,

                1px -1px 0 #000,

                -1px 1px 0 #000,

                3px 3px 0 #000,

                4px 4px 0 #000;

        }

        #loginScreen h1, #loadingScreen h1 {

            color: #ffffff;

            font-weight: 900;

            text-shadow: 

                2px 2px 0 #000,

                -1px -1px 0 #000,

                1px -1px 0 #000,

                -1px 1px 0 #000,

                1px 1px 0 #000,

                3px 3px 0 #000,

                4px 4px 0 #000;

        }

        #loadingScreen p {

            color: #6b7280;

            font-weight: 400;

            text-shadow: none;

        }

        /* Enhanced Button Hovers */

        .login-btn, .arena-btn, .modal-btn, #battleButton, .debug-btn, #navBtnMenu, #navBtnDeck, #navBtnTower, #navBtnDebug,

        #saveDataOverlay button, #loadDataOverlay button, #updateLogOverlay button, #chestOpenOverlay button {

            overflow: hidden;

            position: relative;

            transform-style: preserve-3d;

            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s ease;

            background: var(--glossy-btn-bg);

            border: var(--glossy-btn-border);

            border-radius: 12px;

            box-shadow: var(--glossy-btn-shadow);

            color: #f8fafc;

        }

        .login-btn:hover, .arena-btn:hover, .modal-btn:hover, #battleButton:hover, #saveDataOverlay button:hover,

        #loadDataOverlay button:hover, #updateLogOverlay button:hover, #chestOpenOverlay button:hover {

            transform: translateY(-2px) scale(1.02);

            filter: brightness(1.15);

        }

        .login-btn:active, .arena-btn:active, .modal-btn:active, #battleButton:active, #saveDataOverlay button:active,

        #loadDataOverlay button:active, #updateLogOverlay button:active, #chestOpenOverlay button:active {

            transform: translateY(0) scale(0.98);

            transition: transform 0.1s ease;

        }

        #btnNewYearNewMe {

            background: linear-gradient(180deg, #f87171, #dc2626 70%);

            color: #fff;

            border: 0;

            border-radius: 16px;

            padding: 1rem 2.5rem;

            text-transform: uppercase;

            letter-spacing: 0.08em;

            font-size: 1.25rem;

            font-weight: 800;

            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.45), inset 0 1px 0 rgba(255, 255, 255, 0.35);

            transition: transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease;

        }

        #btnNewYearNewMe:hover {

            transform: translateY(-2px);

            filter: brightness(1.08);

            box-shadow: 0 18px 34px rgba(0, 0, 0, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.45);

        }

        #btnNewYearNewMe:active {

            transform: translateY(0);

            filter: brightness(0.95);

            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.15);

        }

        canvas {

            background-color: #15803d;

            background-image: 

                linear-gradient(rgba(4, 67, 37, 0.35) 1px, transparent 1px),

                linear-gradient(90deg, rgba(4, 67, 37, 0.35) 1px, transparent 1px);

            background-size: 20px 20px;

            display: block;

            border-radius: 8px;

            box-shadow: 0 10px 25px rgba(0,0,0,0.2);

            transition: background-color 0.5s ease;

        }

        /* Arena Themes */

        canvas.arena-1 { background-color: #15803d; }

        canvas.arena-2 { background-color: #6abf82; }

        canvas.arena-3 { 

            background-color: #4a4a4a;

            background-image: 

                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),

                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);

        }

        /* NEW ARENA 4 STYLE */

        canvas.arena-4 { 

            background-color: #ca8a04; /* yellow-600 */

            background-image: 

                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),

                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);

        }

        /* NEW ARENA 5 STYLE */

        canvas.arena-5 { 

            background-color: #3730a3; /* indigo-800 */

            background-image: 

                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),

                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);

        }

        /* NEW ARENA 6 STYLE */

        canvas.arena-6 { 

            background-color: #7c2d12; /* brown-900 */

            background-image: 

                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),

                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);

        }

        /* NEW ARENA 7 STYLE */

        canvas.arena-7 {

            background-color: #3b0764; /* deep purple */

            background-image:

                linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px),

                linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px);

        }

        /* NEW ARENA 8 STYLE */

        canvas.arena-8 {

            background-color: #1f1f3d; /* dark navy/chaos */

            background-image:

                linear-gradient(rgba(147, 51, 234, 0.08) 1px, transparent 1px),

                linear-gradient(90deg, rgba(147, 51, 234, 0.08) 1px, transparent 1px);

        }

        /* NEW ARENA 9 STYLE */

        canvas.arena-9 {

            background-color: #0f172a; /* slate-900 */

            background-image:

                radial-gradient(#334155 1px, transparent 1px);

            background-size: 30px 30px;

        }

        /* NEW ARENA 10 STYLE */

        canvas.arena-10 {

            background-color: #3f0606; /* dark red/chaos realm */

            background-image:

                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),

                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);

        }

        /* NEW ARENA 11 STYLE */

        canvas.arena-11 {

            /* Diddy's Prison: warm canyon tones */

            background-color: #b45309; /* canyon orange */

            background-image:

                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),

                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);

        }

        /* NEW ARENA 12 STYLE */

        canvas.arena-12 {

            background-color: #0b1220; /* deep night */

            background-image:

                radial-gradient(circle at 20% 20%, rgba(14, 165, 233, 0.15), transparent 45%),

                radial-gradient(circle at 80% 10%, rgba(192, 132, 252, 0.12), transparent 48%),

                linear-gradient(135deg, #050914 0%, #0f172a 55%, #051025 100%);

        }

        /* NEW ARENA 13: Aqua Arena */

        canvas.arena-13 {

            background-color: #0f172a; /* base night */

            background-image:

                radial-gradient(circle at 20% 80%, rgba(14, 165, 233, 0.15), transparent 52%),

                radial-gradient(circle at 70% 30%, rgba(14, 165, 233, 0.12), transparent 45%),

                linear-gradient(135deg, #0ea5e9 0%, #0284c7 55%, #0f172a 100%);

        }

        /* NEW ARENA 14: Forsaken Lands */

        canvas.arena-14 {

            background-color: #0f0c1f;

            background-image:

                radial-gradient(circle at 25% 25%, rgba(249, 115, 22, 0.3), transparent 45%),

                radial-gradient(circle at 75% 35%, rgba(59, 130, 246, 0.2), transparent 50%),

                radial-gradient(circle at 50% 80%, rgba(67, 56, 202, 0.25), transparent 48%),

                linear-gradient(135deg, #0f0f1c 0%, #14091f 45%, #05050c 100%);

        }

        canvas.arena-15 {

            background-color: #0f172a;

            background-image:

                radial-gradient(circle at 50% 40%, rgba(148, 163, 184, 0.25), transparent 60%),

                linear-gradient(135deg, #0f172a 0%, #020617 70%, #0b1220 100%);

        }

        canvas.arena-16 {

            background-color: #020617;

            background-image:

                radial-gradient(circle at 50% 40%, rgba(14, 165, 233, 0.35), transparent 50%),

                radial-gradient(circle at 15% 80%, rgba(59, 130, 246, 0.2), transparent 55%),

                linear-gradient(135deg, #0f172a 0%, #020617 60%, #0ea5e9 100%);

        }

        canvas.arena-17 {

            background-color: #c4b5fd;

            background-image:

                linear-gradient(rgba(99, 102, 241, 0.2) 1px, transparent 1px),

                linear-gradient(90deg, rgba(99, 102, 241, 0.2) 1px, transparent 1px),

                radial-gradient(circle at 30% 20%, rgba(14, 165, 233, 0.15), transparent 40%),

                radial-gradient(circle at 70% 60%, rgba(248, 250, 252, 0.25), transparent 45%);

        }

        canvas.arena-18 {

            background-color: #0a0b1a;

            background-image:

                radial-gradient(circle at 25% 25%, rgba(78, 70, 229, 0.25), transparent 40%),

                radial-gradient(circle at 80% 20%, rgba(191, 219, 254, 0.2), transparent 35%),

                linear-gradient(135deg, #020617 0%, #0a0b1a 60%, #0b1330 100%);

        }

        /* NEW ARENA 19 STYLE */
        canvas.arena-19 {

            background-color: #020617;

            background-image:

                radial-gradient(circle at 25% 25%, rgba(59, 130, 246, 0.35), transparent 45%),

                radial-gradient(circle at 70% 20%, rgba(236, 72, 153, 0.3), transparent 40%),

                linear-gradient(135deg, #030512 0%, #040718 55%, #080a1d 100%);

        }

        /* NEW ARENA 20 STYLE */
        canvas.arena-20 {

            background-color: #030712;

            background-image:

                radial-gradient(circle at 25% 20%, rgba(59, 130, 246, 0.4), transparent 50%),

                radial-gradient(circle at 75% 35%, rgba(14, 165, 233, 0.25), transparent 40%),

                linear-gradient(135deg, #050a1d 0%, #040b1d 55%, #02030a 100%);

        }

        /* NEW ARENA 21 STYLE */
        canvas.arena-21 {

            background-color: #8b5cf6;

            background-image:

                radial-gradient(circle at 30% 30%, rgba(254, 215, 170, 0.35), transparent 45%),

                radial-gradient(circle at 70% 60%, rgba(255, 255, 255, 0.25), transparent 35%),

                linear-gradient(135deg, #a855f7 0%, #7c3aed 55%, #c084fc 100%);

        }

        /*

         * Slight 3D effect for the battlefield. Tilting the canvas and adding a box shadow

         * gives the impression of depth without altering game logic. The transform is

         * applied on the game containerâ€™s canvas element so that all drawings retain

         * their relative positions while appearing in perspective.

         */

        #gameContainer canvas {

            /* Flatten the battle board by removing the 3D perspective and tilt. */

            transform: none !important;

            transform-origin: center bottom;

            box-shadow: none !important;

        }

        /* CHRISTMAS THEME */

        canvas.christmas {

            background-color: #ffffff; /* Pure White Snow */

            background-image:

                radial-gradient(#cbd5e1 2px, transparent 2px); /* Subtle snowflakes */

            background-size: 24px 24px;

        }

        

        #gameContainer {

            position: relative;

            width: 100%;

            max-width: 400px;

            margin: 0 auto;

        }

        #timerDisplay {

            position: absolute;

            top: 10px;

            right: 10px;

            padding: 0.25rem 0.6rem;

            border-radius: 999px;

            background: rgba(2, 6, 23, 0.75);

            border: 1px solid rgba(255, 255, 255, 0.35);

            font-weight: 800;

            letter-spacing: 0.02em;

            box-shadow: 0 0 15px rgba(0, 0, 0, 0.35);

            z-index: 10;

            color: #fde68a;

            font-size: 0.9rem;

        }

        #timerDisplay.timer-display--overtime {

            color: #f87171;

            box-shadow: 0 0 15px rgba(248, 113, 113, 0.6);

        }

        #messageOverlay, #chestOpenOverlay, #debugPasswordOverlay, #saveDataOverlay, #loadDataOverlay, #updateLogOverlay {

            position: absolute;

            top: 0;

            left: 0;

            right: 0;

            bottom: 0;

            display: none;

            flex-direction: column;

            justify-content: center;

            align-items: center;

            background-color: rgba(0, 0, 0, 0.85);

            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);

            border: none;

            color: white;

            font-size: 2.5rem;

            font-weight: bold;

            text-shadow: 2px 2px 0px #000, 0 0 10px rgba(0,0,0,0.5);

            text-align: center;

            border-radius: 8px;

            z-index: 60;

            padding: 1rem;

        }

	        #updateLogOverlay .update-log-panel {
	            padding: 2rem 1.5rem;
	            max-width: 400px;
	            width: 100%;
	            margin: 0 auto;
	            display: flex;
	            flex-direction: column;
	            align-items: center;
	            gap: 0.75rem;
	        }


	        #updateLogOverlay .update-log-icons {
	            display: flex;
	            justify-content: center;
	            align-items: center;
	            gap: 0.5rem;
	            font-size: 1.875rem;
	            margin-bottom: 0.25rem;
	        }

	        #updateLogOverlay #updateLogContent {
	            width: 100%;
	            max-height: 24rem;
	            overflow-y: auto;
	            padding: 0 1rem;
	        }


        #emojiDashResultOverlay {

            position: fixed;

            top: 0;

            left: 0;

            right: 0;

            bottom: 0;

            display: none;

            flex-direction: column;

            justify-content: center;

            align-items: center;

            gap: 0.35rem;

            background-color: rgba(3, 7, 18, 0.92);

            color: white;

            font-size: 2.25rem;

            font-weight: bold;

            text-shadow: 2px 2px 0px #000, 0 0 10px rgba(0,0,0,0.5);

            text-align: center;

            border-radius: 12px;

            z-index: 120;

            padding: 1.5rem;

        }

        #emojiDashResultOverlay span {

            max-width: min(360px, 95%);

        }

        .announcement-overlay,

        .vote-overlay {

            position: fixed;

            inset: 0;

            display: none;

            z-index: 120;

            backdrop-filter: blur(6px);

            background: rgba(7, 11, 23, 0.8);

            justify-content: center;

            align-items: center;

            padding: 1rem 0.5rem;

        }

        .announcement-panel,

        .vote-panel {

            width: min(360px, 100%);

            background: linear-gradient(180deg, #0b1b3a, #051129);

            border-radius: 26px;

            padding: 2rem 2.2rem;

            border: 1px solid rgba(255, 255, 255, 0.15);

            box-shadow: 0 25px 40px rgba(2, 6, 23, 0.8);

            display: flex;

            flex-direction: column;

            gap: 1rem;

            max-height: 90vh;

            overflow-y: auto;

            color: #f9f7ff;

        }

        .announcement-panel h2 {

            font-size: 2.1rem;

            margin: 0;

            color: #ffd144;

            text-align: center;

        }

        .announcement-panel p {

            margin: 0;

            line-height: 1.6;

            font-size: 0.95rem;

        }

        .announcement-panel .announcement-footer {

            font-style: italic;

            color: #d0d3ff;

            font-size: 0.95rem;

            text-align: right;

        }

        #siteMoveOverlay {

            position: fixed;

            inset: 0;

            display: flex;

            align-items: center;

            justify-content: center;

            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(59, 130, 246, 0.85));

            z-index: 160;

            padding: 1.5rem;

            backdrop-filter: blur(12px);

        }

        #siteMoveOverlay .site-move-panel {

            width: min(420px, 100%);

            background: rgba(15, 23, 42, 0.95);

            border-radius: 24px;

            padding: 2rem 2.5rem;

            border: 1px solid rgba(59, 130, 246, 0.65);

            box-shadow: 0 25px 50px rgba(2, 6, 23, 0.6);

            text-align: center;

            color: #fefefe;

        }

        #siteMoveOverlay .site-move-panel h2 {

            font-size: 2rem;

            margin-bottom: 0.75rem;

            letter-spacing: 1px;

        }

        #siteMoveOverlay .site-move-panel p {

            font-size: 1rem;

            line-height: 1.4;

            color: #f0f4ff;

            margin: 0;

        }

        #siteMoveOverlay .site-move-buttons {

            margin-top: 1.5rem;

            display: flex;

            gap: 0.75rem;

            flex-wrap: wrap;

        }

        #siteMoveOverlay .site-move-buttons button,

        #siteMoveOverlay .site-move-buttons a {

            flex: 1;

            min-width: 140px;

            padding: 0.9rem 1.2rem;

            border-radius: 12px;

            font-weight: 700;

            font-size: 0.95rem;

            text-transform: uppercase;

            letter-spacing: 0.5px;

            border: 1px solid transparent;

            display: inline-flex;

            justify-content: center;

            align-items: center;

            cursor: pointer;

            transition: transform 0.2s ease, box-shadow 0.2s ease;

            text-decoration: none;

        }

        #siteMoveOverlay .site-move-buttons button.primary,

        #siteMoveOverlay .site-move-buttons a.primary {

            background: linear-gradient(145deg, #22d3ee, #6366f1);

            border-color: rgba(34, 211, 238, 0.8);

            color: #fefefe;

            box-shadow: 0 10px 25px rgba(34, 211, 238, 0.35);

        }

        #siteMoveOverlay .site-move-buttons button.secondary {

            background: rgba(255, 255, 255, 0.85);

            color: #0f172a;

            border-color: rgba(255, 255, 255, 0.6);

            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.4);

        }

        #siteMoveOverlay .site-move-buttons button:hover,

        #siteMoveOverlay .site-move-buttons a:hover {

            transform: translateY(-2px) scale(1.01);

        }

        #announcementOkBtn {

            background: linear-gradient(180deg, #3b62f6, #1421b8);

            color: white;

            border: none;

            border-radius: 50px;

            padding: 0.85rem 0;

            font-size: 1rem;

            font-weight: 700;

            cursor: pointer;

            box-shadow: 0 10px 25px rgba(20, 37, 110, 0.8);

        }

        #voteStatusText {

            font-size: 0.85rem;

        }

        .vote-buttons {

            display: flex;

            justify-content: space-evenly;

            gap: 1rem;

        }

        .vote-buttons button {

            flex: 1;

        }

        .announcement-panel h2,

        .vote-panel h2 {

            font-size: 1.5rem;

            letter-spacing: 0.5px;

        }

        .vote-buttons {

            display: flex;

            gap: 0.75rem;

        }

        .vote-buttons button {

            flex: 1;

        }

        .vote-results {

            font-size: 1rem;

            color: #facc15;

        }

        /* ENHANCED BUTTONS (3D Effect) */

        #messageOverlay button, #emojiDashResultOverlay button, #chestOpenOverlay button, .login-btn, .debug-btn, #debugPasswordOverlay button,

        #saveDataOverlay button, #loadDataOverlay button, #updateLogOverlay button, .arena-btn, .modal-btn, .mode-tab {

            font-size: 1rem;

            font-weight: 800;

            padding: 0.8rem 1.5rem;

            margin-top: 15px;

            background: linear-gradient(to bottom, #4f46e5, #4338ca);

            color: white;

            border: none;

            border-bottom: 4px solid #312e81;

            border-radius: 12px;

            cursor: pointer;

            transition: all 0.1s;

            display: flex;

            align-items: center;

            justify-content: center;

            text-shadow: 0 1px 2px rgba(0,0,0,0.3);

            width: 80%;

            max-width: 300px;

            position: relative;

            box-shadow: 

                0 4px 6px -1px rgba(0, 0, 0, 0.1),

                0 2px 4px -1px rgba(0, 0, 0, 0.06);

        }

        #messageOverlay button:active, #chestOpenOverlay button:active, .login-btn:active, .debug-btn:active, 

        #saveDataOverlay button:active, .arena-btn:active, .modal-btn:active, .mode-tab:active {

            transform: translateY(4px);

            border-bottom-width: 0px;

            margin-bottom: 4px;

            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);

        }

        #messageOverlay button:hover, .login-btn:hover, .arena-btn:hover {

            filter: brightness(1.1);

        }

        #messageRewardText {

            font-size: 0.85rem;

            font-weight: 700;

            color: #fde047;

            text-transform: uppercase;

            letter-spacing: 0.25em;

            margin-top: 0.35rem;

        }

        #emojiDashResultRewardText {

            font-size: 0.85rem;

            font-weight: 700;

            color: #fde047;

            text-transform: uppercase;

            letter-spacing: 0.25em;

            margin-top: 0.35rem;

        }

        .arena-callout, .arena-card {

            color: #f8fafc;

            background:

                var(--arena-card-gradient, linear-gradient(135deg, rgba(120, 83, 240, 0.95), rgba(14, 165, 233, 0.15))),

                linear-gradient(120deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));

            background-size: cover;

            border: 1px solid rgba(248, 250, 252, 0.2);

            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.45);

            border-radius: 20px;

            backdrop-filter: blur(6px);

        }

        .arena-callout {

            width: 100%;

            max-width: 420px;

            padding: 1.25rem 1.5rem;

            margin-bottom: 1rem;

            display: flex;

            align-items: center;

            gap: 1rem;

        }

        .arena-callout .arena-callout-emoji {

            font-size: 3rem;

        }

        .arena-callout .arena-callout-meta {

            line-height: 1.3;

        }

        .arena-callout .arena-callout-meta p {

            margin: 0;

        }

        #arenaScreen .arena-list {

            width: 100%;

            display: flex;

            flex-direction: column;

            gap: 0.75rem;

        }

        #arenaScreen .arena-card {

            padding: 1rem 1.25rem;

            display: flex;

            align-items: center;

            gap: 1rem;

            transition: transform 0.3s ease, box-shadow 0.3s ease;

        }

        #arenaScreen .arena-card:hover {

            transform: translateY(-3px);

            box-shadow: 0 25px 45px rgba(15, 23, 42, 0.55);

        }

        .arena-card .arena-emoji {

            font-size: 2.5rem;

            width: 3rem;

            text-align: center;

        }

        /* Color Variants */

        .login-btn.google { background: linear-gradient(to bottom, #dc2626, #b91c1c); border-bottom-color: #7f1d1d; }

        .login-btn.guest { background: linear-gradient(to bottom, #6b7280, #4b5563); border-bottom-color: #374151; }

        #restoreBrowserSaveLoginBtn.restore-ready { background: linear-gradient(to bottom, #22c55e, #0f766e); border-bottom-color: #0f766e; }

        #restoreBrowserSaveLoginBtn:disabled { opacity: 0.7; cursor: not-allowed; }

        .cancel-btn { background: linear-gradient(to bottom, #ef4444, #dc2626) !important; border-bottom-color: #991b1b !important; }

        .debug-btn { background: linear-gradient(to bottom, #2563eb, #1d4ed8); border-bottom-color: #1e3a8a; }

        

        /* Battle Button Special Style */

        #battleButton {

            background: linear-gradient(to bottom, #ef4444, #b91c1c);

            border-bottom: 6px solid #7f1d1d;

            font-size: 2rem;

            border-radius: 16px;

            text-transform: uppercase;

            letter-spacing: 1px;

            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.4);

        }

        #battleButton:disabled {

            background: #4b5563;

            border-bottom-color: #374151;

            box-shadow: none;

            transform: none !important;

        }

        /* Debug Password Input */

        #debugPasswordInput, #loadKeyInput {

            font-size: 1rem;

            padding: 0.75rem;

            border-radius: 8px;

            border: 2px solid #6b7280;

            background-color: #1f2937;

            color: white;

            margin-top: 20px;

            width: 80%;

            max-width: 300px;

            text-align: center;

        }

        #debugPasswordOverlay .cancel-btn, #saveDataOverlay .cancel-btn, #loadDataOverlay .cancel-btn {

            background-color: #dc2626; /* red-600 */

        }

        #debugPasswordOverlay .cancel-btn:hover, #saveDataOverlay .cancel-btn:hover, #loadDataOverlay .cancel-btn:hover {

            background-color: #b91c1c; /* red-700 */

        }

        /* Save Key Text Area */

        #saveKeyOutput {

            font-size: 0.9rem;

            padding: 0.75rem;

            border-radius: 8px;

            border: 2px solid #6b7280;

            background-color: #1f2937;

            color: #d1d5db; /* gray-300 */

            margin-top: 20px;

            width: 90%;

            max-width: 350px;

            height: 120px;

            word-wrap: break-word;

            word-break: break-all;

            -webkit-user-select: text; /* Safari */

            -ms-user-select: text; /* IE 10+ */

            user-select: text; /* Standard */

            text-align: left;

            overflow-y: auto;

        }

        #saveDataOverlay button:disabled {

            background-color: #4b5563;

            cursor: not-allowed;

            opacity: 0.7;

        }

        /* Emoji Dash specific styling */

        #emojiDashScreen {

            background: linear-gradient(180deg, rgba(2, 6, 23, 0.95), rgba(15, 23, 42, 0.9));

        }

        #emojiDashCanvas {

            background: radial-gradient(circle at 40% 20%, rgba(59, 130, 246, 0.2), transparent 45%), #020617;

            min-height: 280px;

            height: auto;

            display: block;

            box-shadow: 0 15px 40px rgba(2, 6, 23, 0.75), inset 0 0 25px rgba(14, 165, 233, 0.25);

        }

        .emoji-dash-control {

            min-width: 190px;

            text-transform: uppercase;

            letter-spacing: 0.5px;

        }

        .emoji-dash-control:active {

            transform: translateY(2px);

        }

        .hero-slot-grid {
            width: 100%;
            min-height: 130px;
            border-radius: 14px;
            border: 2px dashed rgba(254, 215, 170, 0.9);
            background: linear-gradient(180deg, rgba(15,23,42,0.95), rgba(30,41,59,0.9));
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 0.25rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            grid-column: 3;
            grid-row: 1;
        }

        .hero-slot-grid.hero-slot-locked {
            border-color: rgba(107, 114, 128, 0.8);
        }

        .hero-slot-grid.hero-slot-assigned {
            border: 2px solid rgba(250, 204, 21, 0.9);
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.35), inset 0 0 12px rgba(250, 204, 21, 0.25);
        }

        .hero-slot-grid.hero-slot-locked span,
        .hero-slot-grid.hero-slot-locked p {
            color: #94a3b8;
        }

        .hero-slot-grid .hero-slot-grid-card {
            width: 100%;
            height: 100%;
        }

        .hero-slot-grid .hero-slot-small-title {
            font-size: 0.8rem;
            font-weight: 700;
            letter-spacing: 0.2em;
            color: #facc15;
            text-transform: uppercase;
        }

        .hero-slot-grid .hero-slot-small-desc {
            font-size: 0.7rem;
            color: #cbd5f5;
            line-height: 1.4;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .deck-card-wrapper {
            position: relative;
        }

        .card-ui.hero-slot-enabled {
            position: relative;
            outline: 3px dashed rgba(250, 204, 21, 0.9);
            outline-offset: -4px;
        }

        .hero-slot-overlay {
            position: absolute;
            inset: 0.2rem;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0.2rem;
            pointer-events: none;
            text-align: center;
            font-size: 0.65rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #fef3c7;
        }

        .hero-slot-overlay .hero-slot-label {
            font-weight: 700;
        }

        .hero-slot-overlay .hero-slot-sub {
            font-size: 0.55rem;
            color: rgba(255, 255, 255, 0.75);
        }

        .hero-slot-overlay .hero-slot-emoji {
            font-size: 1.4rem;
        }

        .hero-slot-card {
            width: 100%;
            height: 100%;
            pointer-events: auto;
            display: block;
        }

        .card-ui.hero-card {
            border: 2px solid rgba(250, 204, 21, 0.6);
            box-shadow: 0 0 12px rgba(250, 204, 21, 0.35);
        }

        .card-ui.hero-card.hero-card-assigned {
            border-color: rgba(250, 204, 21, 1);
            box-shadow: 0 0 25px rgba(250, 204, 21, 0.85);
        }

        .card-ui.hero-card.hero-card-available {
            animation: hero-card-glow 3s ease-in-out infinite;
        }

        @keyframes hero-card-glow {
            0%, 100% {
                box-shadow: 0 0 12px rgba(250, 204, 21, 0.35);
            }
            50% {
                box-shadow: 0 0 25px rgba(250, 204, 21, 0.65);
            }
        }

        .unlockable-card-grid {
            padding: 0.5rem;
            border-radius: 1rem;
            background: rgba(15, 23, 42, 0.5);
        }

        .unlockable-card-grid .card-ui {
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.85));
            border: 1px solid rgba(250, 204, 21, 0.4);
        }

        .unlockable-hero-card {
            outline: 2px solid rgba(250, 204, 21, 0.95);
            outline-offset: -3px;
            box-shadow: 0 0 12px rgba(250, 204, 21, 0.35);
        }

        .star-box-button {
            border: 4px solid #3b82f6;
            box-shadow: 0 8px 0 #1e40af;
            border-radius: 1rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: not-allowed;
        }

        .star-box-button.ready {
            cursor: pointer;
        }

        .star-box-button:disabled {
            opacity: 0.6;
        }




        .hero-ability-panel {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.25rem;
            z-index: 50;
            pointer-events: none;
        }

        .hero-ability-panel button,
        .hero-ability-panel .hero-ability-uses {
            pointer-events: all;
        }

        .hero-ability-name {
            font-size: 0.65rem;
            letter-spacing: 0.35em;
            text-transform: uppercase;
            color: #fde047;
            text-shadow: 0 0 6px rgba(253, 224, 71, 0.8);
        }

        .hero-ability-btn {
            min-width: 135px;
            background: linear-gradient(135deg, #f97316, #c2410c);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            padding: 0.65rem 1rem;
            border-radius: 999px;
            box-shadow: 0 10px 25px rgba(249, 115, 22, 0.5);
        }

        .hero-ability-btn:disabled {
            opacity: 0.75;
            background: linear-gradient(135deg, #94a3b8, #475569);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 0 10px rgba(15, 23, 42, 0.5);
        }

        .hero-ability-btn.hero-ability-btn--inactive {
            background: linear-gradient(135deg, #94a3b8, #475569);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 0 10px rgba(15, 23, 42, 0.5);
        }

        .hero-ability-uses {
            font-size: 0.65rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #f3f4f6;
        }

        #emojiDashDeckBar {

            min-height: 80px;

            display: grid;

            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));

            gap: 0.5rem;

        }

        .emoji-dash-deck-card {

            background: linear-gradient(180deg, rgba(59, 130, 246, 0.35), rgba(15, 23, 42, 0.9));

            border: 1px solid rgba(255, 255, 255, 0.2);

            border-radius: 12px;

            color: #f8fafc;

            font-weight: 700;

            padding: 0.4rem;

            display: flex;

            flex-direction: column;

            justify-content: center;

            align-items: center;

            cursor: pointer;

            transition: transform 0.2s ease, border-color 0.2s ease;

            gap: 0.2rem;

        }

        .emoji-dash-deck-card:hover {

            transform: translateY(-2px);

            border-color: rgba(14, 165, 233, 0.9);

        }

        .emoji-dash-deck-card.disabled {

            opacity: 0.5;

            cursor: not-allowed;

            border-color: rgba(255, 255, 255, 0.1);

        }

        .emoji-dash-play-wrapper {

            width: min(100%, 840px);

            border-radius: 20px;

            padding: 0.25rem;

            background: linear-gradient(180deg, rgba(14, 165, 233, 0.35), rgba(15, 23, 42, 0.65));

            box-shadow: 0 20px 45px rgba(2, 6, 23, 0.75);

        }

        .emoji-dash-elixir-shell {

            position: relative;

            height: 28px;

            border-radius: 999px;

            border: 1px solid rgba(255, 255, 255, 0.2);

            overflow: hidden;

            background: rgba(15, 23, 42, 0.8);

        }

        .emoji-dash-elixir-fill {

            position: absolute;

            inset: 0;

            background: linear-gradient(90deg, #a855f7, #f43f5e);

            width: 100%;

            transform-origin: left;

            transform: scaleX(1);

        }

        .emoji-dash-elixir-text {

            position: relative;

            z-index: 2;

            font-weight: 700;

            margin-left: auto;

            margin-right: 0.75rem;

            color: #fefefe;

        }

        .emoji-dash-controls {

            display: flex;

            justify-content: space-between;

            letter-spacing: 0.3em;

            text-transform: uppercase;

        }

        #emojiDashLevelPanel {

            border-radius: 16px;

            border: 1px solid rgba(226, 232, 240, 0.3);

            padding: 0.35rem 0.75rem;

            background: rgba(15, 23, 42, 0.85);

            gap: 0.75rem;

        }

        #emojiDashLevelPanel span {

            color: #e0f2fe;

            font-size: 0.75rem;

            letter-spacing: 0.25em;

        }

        html[data-no-debug] [data-screen="debug"],

        html[data-no-debug] #debugScreen {

            display: none !important;

            visibility: hidden !important;

            pointer-events: none !important;

        }

        /* Loading Screen Animation */

        @keyframes pulse-king {

            0%, 100% { transform: scale(1); }

            50% { transform: scale(1.2); }

        }

        .animate-pulse-king {

            animation: pulse-king 2s infinite;

        }

        /* Battle animations for the intro and loading screens */

        .loading-battle-container {

            position: relative;

            width: 100%;

            height: min(85vh, 680px);

            min-height: 420px;

            margin: 0 auto 1rem;

            overflow: hidden;

            border-radius: 1rem;

            background: transparent;

        }

        .loading-battle-unit {

            position: absolute;

            font-size: 3.2rem;

            line-height: 1;

            pointer-events: none;

        }

        .loading-battle-center {

            position: absolute;

            left: 50%;

            top: 50%;

            transform: translate(-50%, -50%);

            font-size: 4.2rem;

            z-index: 3;

            text-shadow: 0 0 25px rgba(255, 255, 255, 0.8);

        }

        .loading-battle-charger {

            animation-name: charge-in;

            animation-timing-function: cubic-bezier(0.05, 0.7, 0.2, 1);

            animation-fill-mode: forwards;

            left: 50%;

            top: 50%;

        }

        @keyframes charge-in {

            0% {

                transform: translate(var(--enter-x, -240px), var(--enter-y, 0)) scale(1.35);

                opacity: 0;

            }

            25% {

                transform: translate(calc(var(--enter-x, -240px) * 0.5), calc(var(--enter-y, 0) * 0.5)) scale(1.18);

                opacity: 1;

            }

            45% {

                transform: translate(calc(var(--enter-x, -240px) * 0.25), calc(var(--enter-y, 0) * 0.25)) scale(1.12);

            }

            70% {

                transform: translate(calc(var(--exit-x, -60px) * 0.7), calc(var(--exit-y, 0) * 0.7)) scale(1.05);

            }

            90% {

                transform: translate(calc(var(--exit-x, -60px) * 0.9), calc(var(--exit-y, 0) * 0.9)) scale(1.02);

            }

            100% {

                transform: translate(var(--exit-x, -60px), var(--exit-y, 0)) scale(1);

                opacity: 0.92;

            }

        }

        /* Bottom Nav */

        #bottomNav {

            position: fixed;

            bottom: 0;

            left: 50%;

            transform: translateX(-50%);

            width: 100%;

            max-width: 400px;

            z-index: 50;

            transition: opacity 0.3s ease-out;

            padding-top: 0 !important;

            padding-bottom: 0 !important;

            background: rgba(10, 15, 32, 0.8);

            border: 1px solid rgba(59, 130, 246, 0.3);

            border-radius: 20px 20px 0 0;

            box-shadow: 0 -10px 30px rgba(2, 6, 23, 0.8), 0 10px 25px rgba(14, 165, 233, 0.15);

            backdrop-filter: blur(20px);

        }

        .bottom-nav-hidden {

            opacity: 0;

            pointer-events: none;

            visibility: hidden;

        }

        .bottom-nav-visible {

            opacity: 1;

            pointer-events: auto;

            visibility: visible;

        }

        /* Nav Highlight Slider */

        #navHighlight {

            position: absolute;

            bottom: 8px;

            left: 0;

            width: 20%;

            height: 4px;

            border-radius: 999px;

            pointer-events: none;

            transition: left 0.35s cubic-bezier(0.4, 0, 0.2, 1);

            z-index: 0;

            background: transparent;

            box-shadow: 0 0 20px rgba(14, 165, 233, 0.65), inset 0 0 12px rgba(236, 72, 153, 0.4);

        }

        #navHighlight::after {

            content: '';

            position: absolute;

            inset: 0;

            border-radius: 999px;

            background: linear-gradient(90deg, rgba(14, 165, 233, 0.9), rgba(99, 102, 241, 0.9), rgba(236, 72, 153, 0.9));

            box-shadow: 0 0 20px rgba(14, 165, 233, 0.9), 0 0 30px rgba(236, 72, 153, 0.6);

            transform: scaleX(0);

            transform-origin: left center;

            transition: transform 0.35s ease;

        }

        #navHighlight[data-direction='left']::after {

            transform-origin: right center;

        }

        #navHighlight.nav-highlight-animate::after {

            transform: scaleX(1);

        }

        /* Enhanced Chest Slots */

        .chest-slot {

            box-shadow: inset 0 3px 6px rgba(0,0,0,0.5);

            border: 2px solid #374151;

            position: relative;

            transition: all 0.2s;

        }

        .chest-slot.bg-yellow-700 {

            box-shadow: 0 4px 6px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2);

            border-color: #ca8a04;

        }

        .chest-slot.bg-yellow-700:hover {

            animation: chestPulse 2s infinite;

            filter: brightness(1.1);

        }

        @keyframes chestPulse {

            0% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.4); }

            70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); }

            100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0); }

        }

        button {

             outline: none !important;

             -webkit-tap-highlight-color: transparent;

        }

        /* Card Style */

        .card-ui {

            width: 80px;

            height: 112px;

            background: linear-gradient(180deg, rgba(15,23,42,0.95), rgba(30,41,59,0.85));

            border-radius: 14px;

            padding: 6px;

            position: relative;

            display: flex;

            flex-direction: column;

            justify-content: space-between;

            align-items: center;

            font-weight: bold;

            color: #f8fafc;

            cursor: pointer;

            user-select: none;

            border: 1px solid rgba(255, 255, 255, 0.2);

            box-shadow: 0 15px 30px rgba(2, 6, 23, 0.7), inset 0 0 10px rgba(59, 130, 246, 0.3);

            overflow: hidden;

            backdrop-filter: blur(12px);

        }

        .card-ui::after {

            content: '';

            position: absolute;

            inset: 0;

            background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.25), transparent 55%);

            pointer-events: none;

            mix-blend-mode: screen;

        }

        .card-ui.selected {

            border-color: var(--accent);

            transform: translateY(-6px) scale(1.08);

            box-shadow: 0 25px 40px rgba(0, 0, 0, 0.7), 0 0 30px rgba(236, 72, 153, 0.5);

        }

        .card-ui.disabled {

            opacity: 0.5;

            cursor: not-allowed;

            filter: grayscale(80%);

        }

        .card-ui-small {

            width: 60px;

            height: 84px;

            border-radius: 6px;

        }

        .card-ui-name {

            font-size: 0.7rem;

            background-color: rgba(0,0,0,0.6);

            padding: 0 4px;

            border-radius: 4px;

            z-index: 2;

        }

        .card-ui-emoji {

            font-size: 2.5rem;

            line-height: 1;

            z-index: 2;

        }

         .card-ui-small .card-ui-emoji {

            font-size: 2rem;

        }

        .card-ui-type {

            font-size: 0.6rem;

            color: #d1d5db; /* gray-300 */

            z-index: 2;

        }

        .card-ui-cost {

            position: absolute;

            top: 2px;

            left: 2px;

            background-color: #7e22ce;

            border: 2px solid #a855f7;

            border-radius: 50%;

            width: 24px;

            height: 24px;

            display: flex;

            align-items: center;

            justify-content: center;

            font-size: 0.9rem;

            box-shadow: 0 0 5px rgba(0,0,0,0.5);

            z-index: 3;

        }

        .card-ui-mirror-preview {

            position: absolute;

            bottom: 28px;

            right: 6px;

            font-size: 1.5rem;

            opacity: 0;

            transition: opacity 0.25s ease;

            pointer-events: none;

            text-shadow: 0 0 6px rgba(0, 0, 0, 0.8);

            color: #f472b6;

            z-index: 4;

        }

        .card-ui-level {

            position: absolute;

            bottom: 4px;

            right: 4px;

            font-size: 0.7rem;

            font-weight: 800;

            background-color: rgba(0,0,0,0.7);

            color: #fde047; /* yellow-300 */

            padding: 1px 4px;

            border-radius: 3px;

            z-index: 3;

        }

        .card-ui-evo-dots {

            position: absolute;

            top: 4px;

            left: 50%;

            transform: translateX(-50%);

            display: flex;

            gap: 3px;

            pointer-events: none;

            z-index: 4;

        }

        .card-ui-evo-dot {

            width: 6px;

            height: 6px;

            border-radius: 999px;

            background-color: rgba(79, 70, 229, 0.25);

            border: 1px solid rgba(255,255,255,0.7);

            transition: background-color 0.3s, transform 0.3s;

        }

        .card-ui-evo-dot.filled {

            background-color: #a855f7;

            box-shadow: 0 0 6px rgba(168,85,247,0.75);

            transform: scale(1.1);

        }

        .card-ui-evo-ready {

            border-image: linear-gradient(135deg, #a855f7, #f472b6, #22d3ee) 1;

            box-shadow: 0 0 20px rgba(168, 85, 247, 0.8), inset 0 0 12px rgba(34, 211, 238, 0.45);

        }

        .card-ui-progress-bar {

            position: absolute;

            bottom: 0;

            left: 0;

            width: 100%;

            height: 10px;

            background-color: #1f2937; /* gray-800 */

            z-index: 1;

        }

        .card-ui-progress {

            height: 100%;

            background-color: #3b82f6; /* blue-500 */

            transition: width 0.3s;

        }

        .card-ui .can-upgrade {

            background-color: #fde047; /* yellow-300 */

        }

        /* NEW: Locked Card Styles */

        .card-ui-locked {

            filter: grayscale(100%);

            opacity: 0.6;

        }

        .card-ui-locked-arena {

            position: absolute;

            bottom: 4px;

            left: 4px;

            font-size: 0.65rem;

            font-weight: 600;

            background-color: rgba(0,0,0,0.8);

            color: #fde047;

            padding: 1px 4px;

            border-radius: 3px;

            z-index: 3;

        }

        /* Card Info Modal */

        #cardInfoModal {

            position: fixed;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            background-color: rgba(0,0,0,0.8);

            display: none;

            justify-content: center;

            align-items: center;

            z-index: 100;

        }

        #cardInfoModalContent {

            background: linear-gradient(135deg, rgba(2, 6, 23, 0.95), rgba(15, 23, 42, 0.9));

            border-radius: 18px;

            padding: 1.75rem;

            width: 90%;

            max-width: 380px;

            border: 1px solid transparent;

            border-image: linear-gradient(135deg, #8b5cf6, #38bdf8, #22d3ee, #f472b6) 1;

            position: relative;

            max-height: 85vh;

            overflow-y: auto;

            display: flex;

            flex-direction: column;

            box-shadow: 0 25px 50px rgba(2, 6, 23, 0.75), 0 0 30px rgba(59, 130, 246, 0.4);

            backdrop-filter: blur(22px);

            z-index: 1;

        }

        #cardInfoModalContent::before {

            content: '';

            position: absolute;

            inset: 0;

            background: radial-gradient(circle at 30% 20%, rgba(14, 165, 233, 0.2), transparent 55%);

            opacity: 0.6;

            mix-blend-mode: screen;

            pointer-events: none;

            z-index: 0;

        }

        #cardInfoCloseBtn {

            position: sticky;

            top: 0;

            right: 0;

            margin-left: auto;

            font-size: 2rem;

            line-height: 1;

            cursor: pointer;

            color: #9ca3af; /* gray-400 */

            background: rgba(55, 65, 81, 0.95);

            padding: 0 8px;

            border-radius: 4px;

            z-index: 50;

        }

        #cardInfoStats, #towerInfoStats {

            font-size: 0.9rem;

            color: #d1d5db; /* gray-300 */

        }

        #cardInfoStats span, #towerInfoStats span {

            color: white;

            font-weight: 600;

        }

        .card-ability-block {

            border: 1px solid rgba(148, 163, 184, 0.4);

            border-radius: 12px;

            padding: 0.75rem;

            background: linear-gradient(180deg, rgba(30, 64, 175, 0.12), rgba(15, 23, 42, 0.7));

            margin-top: 0.5rem;

        }

        .card-ability-name {

            color: #f59e0b;

            font-size: 0.75rem;

            letter-spacing: 0.4em;

            text-transform: uppercase;

            font-weight: 700;

        }

        .card-ability-details {

            font-size: 0.8rem;

            color: #e5e7eb;

            margin-top: 0.35rem;

        }

        #cardAbilityTestButton {

            transition: transform 0.2s ease;

        }

        #cardAbilityTestButton:active {

            transform: translateY(1px);

        }

        #cardAbilityTestStatus {

            font-size: 0.7rem;

            color: #cbd5f5;

            letter-spacing: 0.2em;

            text-transform: uppercase;

            margin-top: 0.25rem;

        }

        .modal-btn {

            width: 100%;

            font-size: 1.1rem;

            font-weight: 600;

            padding: 0.75rem;

            margin-top: 1rem;

            border: var(--glossy-btn-border);

            border-radius: 10px;

            cursor: pointer;

            transition: transform 0.2s ease, box-shadow 0.2s ease;

            background: var(--glossy-btn-bg);

            color: #f8fafc;

            box-shadow: var(--glossy-btn-shadow);

        }

        .modal-btn.add { background: #16a34a !important; color: white; border-bottom: 4px solid #14532d !important; }

        .modal-btn.remove { background: #dc2626 !important; color: white; border-bottom: 4px solid #7f1d1d !important; }

        .modal-btn.upgrade { background: #9333ea !important; color: white; border-bottom: 4px solid #581c87 !important; }

        .modal-btn:disabled {

            background-color: #6b7280; /* gray-500 */

            color: #d1d5db; /* gray-300 */

            cursor: not-allowed;

        }

        #previewRefreshButton {

            background: linear-gradient(145deg, rgba(59, 130, 246, 0.45), rgba(30, 64, 175, 0.65));

            border: 1px solid rgba(59, 130, 246, 0.7);

            box-shadow: 0 12px 25px rgba(15, 23, 42, 0.5);

            color: #f8fafc;

        }

        #cardInfoPreviewPanel {

            margin-top: 1rem;

            width: 100%;

            background: rgba(15, 23, 42, 0.75);

            border: 1px solid rgba(59, 130, 246, 0.4);

            border-radius: 16px;

            padding: 1rem;

            box-shadow: 0 25px 40px rgba(2, 6, 23, 0.7);

            backdrop-filter: blur(18px);

        }

        #cardPreviewCanvas {

            border-radius: 14px;

            border: 1px solid rgba(59, 130, 246, 0.4);

            box-shadow: inset 0 0 20px rgba(59, 130, 246, 0.3), 0 15px 30px rgba(2, 6, 23, 0.6);

            background-color: #0f172a;

        }

        #previewStrong, #previewWeak {

            width: 100%;

            min-height: 48px;

            background: rgba(15, 23, 42, 0.7);

            border: 1px solid rgba(34, 197, 94, 0.3);

            border-radius: 12px;

            padding: 0.4rem 0.6rem;

            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.35);

            backdrop-filter: blur(8px);

        }

        #previewWeakContainer {

            margin-top: 0.4rem;

        }

        #previewAllCardsList {

            border: 1px solid rgba(59, 130, 246, 0.2);

            border-radius: 14px;

            background: rgba(15, 23, 42, 0.55);

            padding: 0.75rem;

            max-height: 180px;

            overflow-y: auto;

            box-shadow: inset 0 0 15px rgba(15, 23, 42, 0.5);

        }

        #previewSearchInput {

            background: rgba(15, 23, 42, 0.9);

            border: 1px solid rgba(59, 130, 246, 0.45);

            color: #f8fafc;

            transition: border 0.2s ease, box-shadow 0.2s ease;

        }

        #previewSearchInput:focus {

            border-color: rgba(14, 165, 233, 0.85);

            box-shadow: 0 0 12px rgba(14, 165, 233, 0.45);

        }

        #cardInfoProgressContainer, #towerInfoProgressContainer {

            width: 100%;

            background-color: #1f2937;

            border-radius: 5px;

            height: 20px;

            margin-top: 8px;

            position: relative;

            overflow: hidden;

        }

        #cardInfoProgressBar, #towerInfoProgressBar {

            height: 100%;

            background-color: #3b82f6;

        }

        #cardInfoProgressText, #towerInfoProgressText {

            position: absolute;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            display: flex;

            justify-content: center;

            align-items: center;

            font-size: 0.8rem;

            font-weight: 600;

            color: white;

        }

        /* Troop Ghost & Spell Radius */

        #placementIndicator {

            position: absolute;

            border-radius: 50%;

            pointer-events: none;

            display: none;

            z-index: 20;

            font-size: 2rem;

            opacity: 0.7;

            text-align: center;

            line-height: 1;

            transform: translate(-50%, -50%); /* Keep this for centering */

        }

        #placementIndicator.spell {

            border: 4px dashed white;

            background: rgba(255, 255, 255, 0.2);

        }

        #placementIndicator.mirror-preview {

            border-color: #f472b6;

            background: rgba(244, 114, 182, 0.35);

            box-shadow: 0 0 20px rgba(244, 114, 182, 0.45);

        }

        #placementIndicator.mirror-preview-emoji {

            display: flex;

            justify-content: center;

            align-items: center;

            width: 100%;

            height: 100%;

            font-size: 2.3rem;

        }

        #placementIndicator.cant-place {

            background: rgba(220, 38, 38, 0.4);

            border-color: #dc2626;

        }

        /* Chest Reward Styles */

        #chestRewardList {

            font-size: 1.2rem;

            margin-top: 1rem;

            max-height: 40vh; /* Limit height for scrolling */

            overflow-y: auto; /* Enable scroll bar */

            width: 100%;

        }

        #chestRewardList div {

            display: flex;

            justify-content: center;

            align-items: center;

            margin-bottom: 0.5rem;

        }

        /* Red 'Can't Place' Overlay */

        #placementOverlay {

            position: absolute;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            background: repeating-linear-gradient(

                45deg,

                rgba(220, 38, 38, 0.2),

                rgba(220, 38, 38, 0.2) 10px,

                rgba(220, 38, 38, 0.3) 10px,

                rgba(220, 38, 38, 0.3) 20px

            );

            z-index: 10;

            pointer-events: none;

            display: none;

            /* clip-path: polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%); */

            /* NEW: Switched to path() for multi-area clipping */

            clip-path: path("M0 0 L400 0 L400 250 L0 250 Z");

        }

        

        /* NEW: Unauthorized Screen Overlay */

        #unauthorizedScreen {

            display: none; /* Hidden by default */

            position: absolute;

            top: 0;

            left: 0;

            right: 0;

            bottom: 0;

            background-color: rgba(0, 0, 0, 0.7); /* Greys out the background */

            z-index: 100;

            flex-direction: column;

            justify-content: center;

            align-items: center;

            text-align: center;

            color: white;

            padding: 1rem;

        }

        #imagineText {

            font-size: 2.5rem;

            font-weight: 800;

            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);

        }

        #errorReasonText {

            font-size: 1rem;

            color: #fca5a5; /* red-300 */

            margin-top: 1rem;

        }

        

        /* NEW: Fade overlay for demo loop */

        #demoFadeOverlay {

            position: absolute;

            top: 0;

            left: 0;

            right: 0;

            bottom: 0;

            background-color: #000;

            opacity: 0;

            pointer-events: none;

            transition: opacity 0.5s ease-in-out;

            z-index: 101; /* Above the "imagine" text */

        }

        #gameScreen {

            position: relative;

            overflow: hidden;

        }

        #gameScreen #gameContainer {

            position: relative;

            z-index: 2;

        }

        .mode-description-panel {

            width: 100%;

            max-width: 430px;

            position: relative;

            overflow: hidden;

            --mode-panel-accent-rgb: 248, 113, 113;

            border-radius: 1rem;

            border: 1px solid rgba(var(--mode-panel-accent-rgb, 248, 113, 113), 0.45);

            background: linear-gradient(180deg, rgba(var(--mode-panel-accent-rgb, 248, 113, 113), 0.18), rgba(7, 8, 24, 0.9));

            box-shadow: 0 25px 40px rgba(0, 0, 0, 0.5), inset 0 0 25px rgba(var(--mode-panel-accent-rgb, 248, 113, 113), 0.25);

            margin-bottom: 0.5rem;

        }

        .mode-description-panel::before {

            content: '';

            position: absolute;

            inset: 0;

            border-radius: inherit;

            pointer-events: none;

            border: 1px solid rgba(var(--mode-panel-accent-rgb, 248, 113, 113), 0.25);

            box-shadow: 0 0 30px rgba(var(--mode-panel-accent-rgb, 248, 113, 113), 0.3);

            opacity: 0.7;

        }

        .mode-description-inner {

            position: relative;

            padding: 0.9rem 1rem;

        }

        .mode-description-title {

            font-size: 1.25rem;

            font-weight: 800;

            letter-spacing: 0.15em;

            text-transform: uppercase;

            color: rgba(var(--mode-panel-accent-rgb, 248, 113, 113), 0.95);

            margin-bottom: 0.4rem;

        }

        .mode-description-description {

            margin: 0;

            color: rgba(241, 245, 249, 0.92);

            font-size: 0.95rem;

            line-height: 1.5;

        }

        /* Mode aura and jumpscare overlays removed to keep the play area clean. */

        @keyframes modeGlow {

            0%, 100% {

                text-shadow: 0 0 12px rgba(237, 68, 68, 0.6), 0 0 25px rgba(248, 113, 113, 0.3);

            }

            50% {

                text-shadow: 0 0 24px rgba(59, 130, 246, 0.65), 0 0 35px rgba(248, 113, 113, 0.4);

            }

        }

        .mode-tab.active {

            box-shadow:

                0 0 0 3px rgba(var(--active-mode-glow, 239, 68, 68), 0.85),

                0 8px 20px rgba(0, 0, 0, 0.45);

        }

    </style>

</head>

<body class="text-gray-100 min-h-screen flex flex-col items-center">

    <canvas id="bgCanvas"></canvas>

    <button id="leaveSiteButton" class="leave-site-button" type="button" aria-label="Leave this page">
        Leave Site
    </button>

    <!-- 

    ========================================================

    SCREEN: INTRO (NEW)

    ========================================================

    -->

    <div id="introScreen" class="screen active flex-col justify-center items-center">

        <!-- Animated battlefield: emojis charge toward the central knight -->

        <div class="loading-battle-container mb-2" data-loading-battle>

            <span class="loading-battle-center" aria-hidden="true">ðŸ›¡ï¸</span>

        </div>

    </div>

    <!-- 

    ========================================================

    SCREEN: LOGIN (FIXED)

    ========================================================

    -->

    <div id="loginScreen" class="screen flex-col justify-center items-center">

        <div class="text-6xl">ðŸ‘‘</div>

    <!-- Add ui-text-effect to make the title pop more prominently -->

    <h1 class="text-4xl font-bold mt-4 ui-text-effect">Emoji Royale</h1>

        <p class="text-lg mt-2 text-gray-500">Choose your way to play!</p>

        <p id="loginError" class="text-lg mt-2 text-red-400 font-bold h-6"></p> 

        

        <!-- NEW: Load Save Key Button -->

        <button id="loadKeyBtn" class="login-btn bg-blue-600 hover:bg-blue-700">

            Enter Save Key

        </button>

        

        <!-- "Play as Guest (No Save)" button -->

        <button id="trueGuestLoginBtn" class="login-btn guest">

            Play without Save

        </button>

        <button id="restoreBrowserSaveLoginBtn" class="login-btn guest mt-4 w-3/4 btn-shine" disabled>

            Restore last browser save

        </button>

        

        <!-- Google Sign-in (hidden for now, but logic exists) -->

        <button id="googleLoginBtn" class="login-btn google hidden">

            <svg class="w-6 h-6 mr-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" />

            Sign in with Google

        </button>

    </div>

    

    <!-- 

    ========================================================

    SCREEN: LOADING

    ========================================================

    -->

    <div id="loadingScreen" class="screen flex-col justify-center items-center">

        <!-- Animated battlefield for loading screen. Units charge toward the central knight, then freeze while loading completes. -->

        <div class="loading-battle-container mb-2" data-loading-battle>

            <span class="loading-battle-center" aria-hidden="true">ðŸ›¡ï¸</span>

        </div>

        <!-- Highlight the game title on loading screen -->

        <h1 class="text-3xl font-bold mt-4 ui-text-effect">Emoji Royale</h1>

        <p class="text-lg mt-2 text-gray-500">Loading...</p>

    </div>

    

    <!-- 

    ========================================================

    SCREEN: MENU (HOME)

    ========================================================

    -->

    <div id="menuScreen" class="screen flex-col items-center p-4">

        <!-- Main Content Area -->

        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">

            <!-- Header -->

            <div class="flex justify-between items-center w-full">

                <div class="bg-gray-800 px-4 py-2 rounded-lg">

                    <span id="goldDisplay" class="text-xl font-bold text-yellow-400 ui-text-effect">ðŸ’° 500</span>

                </div>

                <div class="bg-gray-800 px-4 py-2 rounded-lg">

                    <span id="trophyDisplay" class="text-xl font-bold text-blue-400 ui-text-effect">ðŸ† 0</span>

                </div>

            </div>

            

            <!-- Arena Display -->

            <div id="modeDisplay" class="text-yellow-600 font-bold text-xl mb-2 ui-text-effect">Trophy Road</div>

            <!-- Mode Selector Buttons -->

            <div class="flex w-11/12 mb-4 bg-gray-800 rounded-lg p-1 gap-1 flex-wrap">

                <button id="modeTrophy" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-red-600 text-white shadow-md btn-shine ui-text-effect">Trophy Road</button>

                <button id="modeParty1v1" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-gray-700 text-gray-400 shadow-md btn-shine ui-text-effect">1v1</button>

                <button id="mode2v2" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-gray-700 text-gray-400 shadow-md btn-shine ui-text-effect">2v2</button>

                <button id="modeEmojiDash" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-gray-700 text-gray-400 shadow-md btn-shine ui-text-effect">Emoji Dash</button>
                <button id="modeChaos" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-gray-700 text-gray-400 shadow-md btn-shine ui-text-effect">Chaos Works</button>

            </div>

            <div id="modeDescriptionPanel" class="mode-description-panel" aria-live="polite">

                <div class="mode-description-inner">

                    <div id="modeDescriptionTitle" class="mode-description-title"></div>

                    <p id="modeDescriptionText" class="mode-description-description"></p>

                </div>

            </div>

            <div class="flex flex-col items-center my-8">

                <span id="arenaEmoji" class="text-8xl">ðŸžï¸</span>

                <h2 id="arenaName" class="text-2xl font-bold mt-2 ui-text-effect battle-arena-name">Arena 1: Emoji Valley</h2>

            </div>

            <!-- Battle Button -->

            <button id="battleButton" class="bg-red-600 hover:bg-red-700 text-white w-3/4 py-4 rounded-lg shadow-lg text-3xl font-extrabold transition transform hover:scale-105 btn-shine ui-text-effect">

                BATTLE!

            </button>


            <button id="arenaButton" class="arena-btn bg-blue-600 hover:bg-blue-700 mt-3 w-3/4">

                Arenas

            </button>

            <!-- NEW: Star Boxes Button -->

            <!-- Star Boxes Button: now a square 3D-style button with a box icon -->

            <button id="starBoxesButton" class="mt-4 rounded-xl transition transform hover:-translate-y-1 active:translate-y-0 ui-text-effect flex items-center justify-center" 

                style="width: 90px; height: 90px; font-size: 2.5rem; background: #f59e0b; border: 4px solid #d97706; box-shadow: 0 8px 0 #b45309;">

                ðŸ“¦

            </button>

            <!-- Quarter Star Status: shows how many quarter stars the player currently has. Updated dynamically -->

            <div id="quarterStarStatus" class="mt-3 text-yellow-300 text-lg font-bold hidden">

                â­ Quarter Stars: <span id="quarterStarCountMenu">0</span>

            </div>

            <!-- Evolution Shard Status: shows how many evolution shards the player has collected. Visible once evolutions are unlocked -->

            <div id="evoShardStatus" class="mt-1 text-green-300 text-sm font-bold hidden">

                Evolution Shards ðŸ§¬: <span id="evoShardCountMenu">0</span>

            </div>

            <div id="superheroShardStatus" class="mt-1 text-purple-300 text-sm font-bold hidden">

                Superhero Shards âš¡: <span id="superheroShardCount">0</span>

            </div>

            

            <!-- Chest Slots -->

            <div class="mt-8 w-full">

                <h3 class="text-xl font-bold text-center mb-2 your-boxes-text">Your Boxes</h3>

                <div id="chestSlots" class="grid grid-cols-4 gap-2">

                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>

                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>

                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>

                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>

                </div>

            </div>

            <!-- NEW: Save Data Button -->

            <button id="saveDataBtn" class="login-btn guest mt-8 w-3/4 btn-shine">

                Save Data

            </button>

        </div>

        <!-- Bottom Nav Removed: Using Persistent Nav at bottom of body -->

    </div>

    

    <!-- 

    ========================================================

    SCREEN: DECK

    ========================================================

    -->

    <div id="deckScreen" class="screen flex-col items-center p-4">

        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-6 pb-24">

            <!-- Battle Deck Section -->

            <div class="w-full bg-gray-800 rounded-xl p-4 shadow-lg border-2 border-gray-700 mb-6 relative overflow-visible deck-card-wrapper">

                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>

                <div class="flex justify-between items-end mb-4">

                     <div>

                        <h1 class="text-2xl font-black italic tracking-wider text-white" style="text-shadow: 2px 2px 0 #000;">BATTLE DECK</h1>

                        <p id="deckCount" class="text-xs text-gray-400 font-bold uppercase tracking-widest">0/8 Cards</p>

                     </div>

                     <div class="text-right">

                         <div class="text-xs text-purple-400 font-bold uppercase tracking-widest mb-1">Avg Elixir</div>

                         <div id="avgElixir" class="text-2xl font-black text-purple-300 leading-none drop-shadow-md">0.0</div>

                     </div>

                </div>

                

                <div class="flex gap-4 flex-wrap items-start">

                    <div id="deckCardGrid" class="grid grid-cols-4 gap-2 justify-items-center">

                        <!-- Deck cards injected by JS (Big cards) -->

                    </div>


                </div>

            </div>

            <!-- Collection Header -->

            <div class="w-full flex flex-wrap items-center mb-4 px-2 gap-3">

                <h2 class="text-xl font-bold text-gray-300">Collection</h2>

                <input id="collectionSearch" type="text" placeholder="Search cards" class="bg-gray-700 text-sm text-white px-3 py-1 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500 transition flex-grow max-w-sm" />

                <div class="h-px bg-gray-700 flex-grow"></div>

            </div>

            <div id="collectionCardGrid" class="grid grid-cols-4 gap-2 mb-8 justify-items-center w-full">

                <!-- Collection cards injected by JS (Small cards) -->

            </div>

            <!-- Locked Header -->

            <div class="w-full flex flex-wrap items-center mb-4 px-2 gap-3">

                <h2 class="text-xl font-bold text-gray-500">Locked</h2>

                <input id="lockedSearch" type="text" placeholder="Search locked cards" class="bg-gray-700 text-sm text-white px-3 py-1 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500 transition flex-grow max-w-sm" />

                <div class="h-px bg-gray-800 flex-grow"></div>

            </div>

            <div id="lockedCardGrid" class="grid grid-cols-4 gap-2 mb-2 justify-items-center w-full">

                <!-- Locked cards injected by JS -->

            </div>

            <div id="unlockableSection" class="flex flex-col items-start gap-2 mb-4" style="display:none;">

                <div class="flex items-center gap-2">

                    <span class="text-xs uppercase tracking-[0.4em] text-yellow-300">Unlockable</span>

                    <div class="h-px bg-yellow-400 flex-grow"></div>

                </div>

                <div id="unlockableCardGrid" class="grid grid-cols-4 gap-2 justify-items-center w-full unlockable-card-grid"></div>

            </div>

        </div>

    </div>

    <!-- 

    ========================================================

    SCREEN: TOWER

    ========================================================

    -->

    <div id="towerScreen" class="screen flex-col items-center p-4">

        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">

            <h1 class="text-3xl font-bold">Tower Power</h1>

            <p id="towerLevelDisplay" class="text-lg text-yellow-300 font-bold">Tower Level 1</p>

            <div class="text-8xl my-4">ðŸ‘‘</div>

            

            <!-- Stats -->

            <div class="bg-gray-800 p-4 rounded-lg mt-4 w-full space-y-2">

                <h3 class="text-xl font-bold text-center">Tower Stats</h3>

                <div id="towerInfoStats" class="grid grid-cols-2 gap-2">

                    <!-- Stats injected by JS -->

                </div>

            </div>

            

            <!-- Upgrade -->

            <div class="bg-gray-800 p-4 rounded-lg mt-8 w-full flex flex-col items-center">

                <h3 class="text-xl font-bold text-center">Upgrade Tower</h3>

                <div id="towerInfoProgressContainer" class="w-full">

                    <div id="towerInfoProgressBar" style="width: 0%;"></div>

                    <div id="towerInfoProgressText">0 / 0</div>

                </div>

                <div class="w-full flex justify-center">

                    <button id="towerUpgradeButton" class="modal-btn upgrade mx-auto btn-shine" style="width: 80%;" disabled>

                        Upgrade

                    </button>

                </div>

            </div>

        </div>

        

        </div>

    <!-- 

    ========================================================

    SCREEN: ARENAS (NEW)

    ========================================================

    -->

    <div id="arenaScreen" class="screen flex-col items-center p-4">

        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">

            <h1 class="text-3xl font-bold mb-8 ui-text-effect battle-arena-name">Arenas</h1>

            

            <div class="space-y-4 w-full">

                <div class="arena-list">

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #38bdf8, #2563eb);">

                        <span class="arena-emoji">ðŸŒŠ</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 1: Emoji Valley</h2>

                            <p class="text-yellow-300">0+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #fb923c, #f97316);">

                        <span class="arena-emoji">ðŸ¡</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 2: Laughing Village</h2>

                            <p class="text-yellow-300">250+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #ef4444, #b91c1c);">

                        <span class="arena-emoji">ðŸ”¥</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 3: Lava Town</h2>

                            <p class="text-yellow-300">500+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #bef264, #4d7c0f);">

                        <span class="arena-emoji">ðŸšœ</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 4: The Farm</h2>

                            <p class="text-yellow-300">750+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #a855f7, #7c3aed);">

                        <span class="arena-emoji">ðŸ’€</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 5: Skull Kingdom</h2>

                            <p class="text-yellow-300">1000+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #facc15, #ca8a04);">

                        <span class="arena-emoji">ðŸ”®</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 6: Warlock's Workshop</h2>

                            <p class="text-yellow-300">1250+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #0ea5e9, #1d4ed8);">

                        <span class="arena-emoji">ðŸ§™â€â™‚ï¸</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 7: Mages Graveyard</h2>

                            <p class="text-yellow-300">1500+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #4c1d95, #0f172a);">

                        <span class="arena-emoji">ðŸŒŒ</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 8: Chaos Canyon</h2>

                            <p class="text-yellow-300">1750+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #f97316, #f43f5e);">

                        <span class="arena-emoji">ðŸ”ï¸</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 9: Titan's Peak</h2>

                            <p class="text-yellow-300">2000+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #db2777, #9333ea);">

                        <span class="arena-emoji">ðŸ”¥</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 10: Chaos Realm</h2>

                            <p class="text-yellow-300">2250+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #ea580c, #b91c1c);">

                        <span class="arena-emoji">ðŸ§±</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 11: Diddy's Prison</h2>

                            <p class="text-yellow-300">2500+ Trophies ðŸ†</p>
                            <p class="text-xs text-gray-400 mt-1">Unlock Quarter Star I &amp; Star Box I.</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #0ea5e9, #9333ea);">

                        <span class="arena-emoji">ðŸ‰</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 12: Mythic Arena</h2>

                            <p class="text-yellow-300">2750+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #0ea5e9, #0284c7);">

                        <span class="arena-emoji">ðŸŒŠ</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 13: Aqua Arena</h2>

                            <p class="text-yellow-300">3000+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #0f172a, #111827);">

                        <span class="arena-emoji">ðŸŒ‘</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 14: Forsaken Lands</h2>

                            <p class="text-yellow-300">3250+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #29323c, #0b1726);">

                        <span class="arena-emoji">ðŸ—¿</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 15: Buried Kingdom</h2>

                            <p class="text-yellow-300">3500+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #0f172a, #0ea5e9);">

                        <span class="arena-emoji">ðŸªž</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 16: Mirror Plateau</h2>

                            <p class="text-yellow-300">3750+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #a5b4fc, #6366f1);">

                        <span class="arena-emoji">âœ¨</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 17: Celestial Citadel</h2>

                            <p class="text-yellow-300">4000+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #4c1d95, #0a0b1a);">

                        <span class="arena-emoji">ðŸŒŒ</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 18: Nebula Nexus</h2>

                            <p class="text-yellow-300">4250+ Trophies ðŸ†</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #0f172a, #1e293b);">

                        <span class="arena-emoji">ðŸŒŸ</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 19: Stellar Observatory</h2>

                            <p class="text-yellow-300">4500+ Trophies âœ¨</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #a855f7, #312e81);">

                        <span class="arena-emoji">ðŸŒ </span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 20: Celestial Cascade</h2>

                            <p class="text-yellow-300">4750+ Trophies ðŸŒŒ</p>

                        </div>

                    </div>

                    <div class="arena-card" style="--arena-card-gradient: linear-gradient(135deg, #f59e0b, #b45309);">

                        <span class="arena-emoji">ðŸ§±</span>

                        <div>

                            <h2 class="text-xl font-bold">Arena 21: Snack Pit</h2>

                            <p class="text-yellow-300">5000+ Trophies â­ï¸</p>

                            <p class="text-xs text-gray-400 mt-1">Unlock Quarter Star II & Star Box II.</p>

                        </div>

                    </div>

                </div>

            </div>

            <button id="arenaBackButton" class="arena-btn bg-gray-600 hover:bg-gray-700 mt-8 w-3/4">

                Back to Menu

            </button>

        </div>

        

        </div>

    <!-- 

    ========================================================

    SCREEN: EVENTS

    ========================================================

    -->

    <div id="eventsScreen" class="screen flex-col items-center p-4">

        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24 space-y-6 event-section">

            <h1 class="text-3xl font-bold text-amber-300 mb-2" style="text-shadow: 0 0 15px #fde68a, 0 0 30px #facc15;">âœ¨ Events</h1>

            <p class="text-green-200 font-semibold uppercase tracking-wider text-sm mb-2">Superhero Launch</p>

            <div class="event-card">

                <div class="event-card-kicker mb-2">Event Spotlight</div>

                <h2 class="text-2xl font-bold text-emerald-100 mb-2">Superhero Launch</h2>

                <p class="text-sm text-emerald-100/80 mb-1">The champion heroes show up for a limited-time launch. Every match glows with a hero-level surge, and the New Year New Me deck is the center of attention.</p>

                <p class="text-xs text-emerald-200/70">The event upgrades your deck to level 15 and injects a random hero (even if you haven't unlocked them yet) so the field has unexpected sparkle and firepower.</p>

            </div>

            <div class="event-card">

                <div class="flex items-center justify-between mb-3">

                    <span class="text-xl font-bold text-yellow-200">New Year New Me</span>

                    <span class="text-xs text-emerald-200 font-semibold">Level 15 Decks</span>

                </div>

                <p class="text-sm text-emerald-100 mb-3">Use your Trophy Road deck; we'll swap any hero card you already have with another random superhero so you never face two at once. The swap and the boost only apply during the event match.</p>

                <ul class="text-xs text-emerald-200 space-y-1 mb-4">

                    <li>Unlocked or not, a superhero joins the arena for this challenge.</li>

                    <li>AI decks also run superheroes to keep the duel thrilling.</li>

                    <li>Return to the regular menu when you finish to keep your progress intact.</li>

                </ul>

                <button id="btnNewYearNewMe" class="modal-btn bg-amber-500 hover:bg-amber-400 text-black font-bold py-3 btn-shine border-b-4 border-amber-600 active:border-b-0 active:translate-y-1">

                    Battle

                </button>

            </div>

            <p class="text-xs text-emerald-100/70 italic text-center px-4">Tap Battle to launch the event, then return to the menu when it concludes to keep your regular progress.</p>

        </div>

    </div>

<!-- 

    ========================================================

    SCREEN: DEBUG (NEW)

    ========================================================

    -->

    <div id="debugScreen" class="screen flex-col items-center p-4">

        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">

            <h1 class="text-3xl font-bold">Debug Menu</h1>

            <p class="text-gray-400 text-center my-4">For testing only!</p>

            

            <button id="debugArena2" class="debug-btn bg-green-600 hover:bg-green-700">Jump to Arena 2 (250 ðŸ†)</button>

            <button id="debugArena3" class="debug-btn bg-red-600 hover:bg-red-700">Jump to Arena 3 (500 ðŸ†)</button>

            <button id="debugArena4" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Jump to Arena 4 (750 ðŸ†)</button>

            <button id="debugArena5" class="debug-btn bg-indigo-600 hover:bg-indigo-700">Jump to Arena 5 (1000 ðŸ†)</button> <!-- NEW -->

                    <button id="debugArena6" class="debug-btn bg-orange-900 hover:bg-orange-800">Jump to Arena 6 (1250 ðŸ†)</button>

                    <button id="debugArena7" class="debug-btn bg-gray-900 hover:bg-gray-800">Jump to Arena 7 (1500 ðŸ†)</button>

                    <button id="debugArena8" class="debug-btn bg-purple-900 hover:bg-purple-800">Jump to Arena 8 (1750 ðŸ†)</button>

                    <button id="debugArena9" class="debug-btn bg-slate-900 hover:bg-slate-800">Jump to Arena 9 (2000 ðŸ†)</button>

                    <button id="debugArena10" class="debug-btn bg-red-900 hover:bg-red-800">Jump to Arena 10 (2250 ðŸ†)</button>

            <button id="debugArena11" class="debug-btn bg-orange-700 hover:bg-orange-800">Jump to Arena 11 (2500 ðŸ†)</button>

            <button id="debugArena12" class="debug-btn bg-fuchsia-600 hover:bg-fuchsia-700">Jump to Arena 12 (2750 ðŸ†)</button>

            <button id="debugArena13" class="debug-btn bg-cyan-600 hover:bg-cyan-500">Jump to Arena 13 (3000 ðŸ†)</button>

            <button id="debugArena14" class="debug-btn bg-emerald-900 hover:bg-emerald-800">Jump to Arena 14 (3250 ðŸ†)</button>

            <button id="debugArena15" class="debug-btn bg-slate-900 hover:bg-slate-800">Jump to Arena 15 (3500 ðŸ†)</button>

            <button id="debugArena16" class="debug-btn bg-slate-900 hover:bg-slate-800">Jump to Arena 16 (3750 ðŸ†)</button>

            <button id="debugArena17" class="debug-btn bg-indigo-900 hover:bg-indigo-800">Jump to Arena 17 (4000 ðŸ†)</button>

            <button id="debugArena18" class="debug-btn bg-purple-900 hover:bg-purple-800">Jump to Arena 18 (4250 ðŸ†)</button>

            <button id="debugArena19" class="debug-btn bg-sky-700 hover:bg-sky-800">Jump to Arena 19 (4500 ðŸ†)</button>

            <button id="debugArena20" class="debug-btn bg-fuchsia-700 hover:bg-fuchsia-600">Jump to Arena 20 (4750 ðŸ†)</button>

            <button id="debugArena21" class="debug-btn bg-yellow-500 hover:bg-amber-500">Jump to Arena 21 (5000 ðŸ†)</button>

            <button id="debugUnlockAll" class="debug-btn bg-blue-600 hover:bg-blue-700">Unlock All Cards</button>

            <button id="debugUpgradeAll" class="debug-btn bg-purple-600 hover:bg-purple-700">Upgrade All Cards +1 Lvl</button>

            <button id="debugGetChest" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Get a Free Chest ðŸ“¦</button>

            <button id="debugAddGold" class="debug-btn bg-yellow-400 text-gray-900 hover:bg-yellow-300">Get 1000 Gold ðŸ’°</button>

            <!-- NEW: Add evolution shards via debug -->

            <button id="debugAddShards" class="debug-btn bg-purple-500 hover:bg-purple-600">Get 6 Evo Shards ðŸ§¬</button>

            <button id="debugAddHeroShard" class="debug-btn bg-fuchsia-500 hover:bg-fuchsia-600">Grant 1 Hero Shard ðŸ¦¸</button>

            <button id="debugReset" class="debug-btn bg-gray-600 hover:bg-gray-700">Reset Account (New User)</button>

            <div class="flex flex-col gap-2 w-full mt-4">

                <button id="debugEmojiDashLevel1" class="debug-btn bg-indigo-500 hover:bg-indigo-600">Emoji Dash Level 1</button>

                <button id="debugEmojiDashLevel2" class="debug-btn bg-sky-500 hover:bg-sky-600">Emoji Dash Level 2</button>

                <button id="debugEmojiDashLevel3" class="debug-btn bg-rose-500 hover:bg-rose-600">Emoji Dash Level 3</button>

            </div>

        </div>

        

        </div>

    <!-- 

    ========================================================

    SCREEN: GAME

    ========================================================

    -->

    <div id="gameScreen" class="screen flex-col items-center p-2">

        <div id="gameContainer">


            <!-- AI Teammate UI (2v2) -->

            <div id="aiTeammateUI" class="absolute bottom-[-340px] left-1/2 transform -translate-x-1/2 flex flex-col items-center gap-2 pointer-events-none z-50 transition-all" style="display:none;">

                <div class="bg-gray-900 bg-opacity-95 p-3 rounded-xl border-2 border-gray-600 shadow-xl flex flex-col items-center gap-2">

                    <div class="flex justify-center items-end space-x-3">

                        <div class="flex flex-col items-center opacity-90">

                            <span class="text-[10px] text-gray-300 font-bold mb-1 tracking-widest ui-text-effect">NEXT</span>

                            <div id="aiTeammateNext" class="card-ui-small transform scale-75 origin-bottom"></div>

                        </div>

                        <div id="aiTeammateHand" class="flex justify-center space-x-[-5px] transform scale-90"></div>

                    </div>

                    <div class="flex items-center gap-2 w-full px-2">

                        <span class="text-[10px] font-bold text-purple-300 uppercase tracking-wider ui-text-effect">Ally</span>

                        <div class="flex-grow h-3 bg-gray-800 rounded-full border border-gray-600 overflow-hidden relative">

                            <div class="absolute inset-0" style="background-image: repeating-linear-gradient(90deg, transparent, transparent 19%, rgba(255,255,255,0.1) 20%); background-size: 10% 100%;"></div>

                            <div id="aiTeammateElixirBar" class="h-full bg-gradient-to-r from-purple-600 to-purple-400" style="width: 0%"></div>

                        </div>

                        <span id="aiTeammateElixirCount" class="text-xs font-black text-white ui-text-effect">0</span>

                    </div>

                </div>

            </div>

            <!-- NEW: Placement Overlay -->

            <div id="placementOverlay"></div>

            <canvas id="gameCanvas" width="400" height="500"></canvas>

            <div id="timerDisplay">00:00</div>

            <div id="messageOverlay">

                <span id="messageText"></span>

                <span id="messageRewardText"></span>

                <button id="startButton">Start Game</button>

                <button id="menuButton" class="bg-red-600 hover:bg-red-700">Back to Menu</button>

            </div>

            <!-- Placement "Ghost" Indicator -->

            <div id="placementIndicator"></div>

            <div id="heroAbilityPanel" class="hero-ability-panel hidden">
                <div id="heroAbilityName" class="hero-ability-name"></div>
                <button id="heroAbilityButton" class="hero-ability-btn" type="button" disabled>---</button>
                <div id="heroAbilityUses" class="hero-ability-uses">Assign a superhero</div>
            </div>

            

            <!-- NEW: Unauthorized Screen Overlay -->

            <div id="unauthorizedScreen">

                <h1 id="imagineText">Imagine... what could have been.</h1>

                <p id="errorReasonText">Error: This game is not authorized to run on this domain.</p>

                <!-- NEW: Fade overlay for demo loop -->

                <div id="demoFadeOverlay"></div>

            </div>

        </div>

        <!-- Card UI Bar -->

        <div class="bg-gradient-to-b from-gray-800 to-gray-900 p-4 border-t-4 border-gray-700 shadow-2xl w-full max-w-md mt-2 rounded-xl relative z-20" style="padding-bottom: env(safe-area-inset-bottom, 1rem);">

            <div class="max-w-md mx-auto">

                <!-- Elixir Bar -->

                <div class="mb-4 relative">

                     <div class="flex justify-between text-xs font-bold text-purple-300 mb-1 px-1 uppercase tracking-wider ui-text-effect" style="text-shadow: 1px 1px 0 #000;">

                        <span>Elixir</span>

                    </div>

                    <div class="w-full bg-gray-900 rounded-full h-8 border-2 border-gray-600 shadow-inner relative overflow-hidden">

                        <!-- Background Grid for Elixir -->

                        <div class="absolute inset-0" style="background-image: repeating-linear-gradient(90deg, transparent, transparent 19%, rgba(255,255,255,0.1) 20%); background-size: 10% 100%;"></div>

                        <div id="elixirBar" class="bg-gradient-to-r from-purple-600 to-purple-400 h-full rounded-full transition-all duration-100 ease-linear flex items-center justify-end pr-3 shadow-[0_0_10px_rgba(168,85,247,0.5)]" style="width: 30%;">

                            <span id="elixirText" class="text-white font-black text-lg ui-text-effect">3</span>

                        </div>

                    </div>

                </div>

                

                <!-- 4-Card Hand + Next Card -->

                <div class="flex justify-center items-end space-x-3">

                    <div class="flex flex-col items-center bg-gray-900 p-2 rounded-lg border border-gray-700">

                        <span class="text-[10px] text-gray-400 font-bold mb-1 tracking-widest ui-text-effect">NEXT</span>

                        <div id="nextCardSlot" class="card-ui-small transform scale-90 origin-bottom"></div>

                    </div>

                    <div id="cardHand" class="flex justify-center space-x-1 pb-1"></div>

                </div>

            </div>

        </div>

    </div>

    <!-- 

    ========================================================

    CARD INFO MODAL

    ========================================================

    -->

    <div id="cardInfoModal">

        <div id="cardInfoModalContent">

            <span id="cardInfoCloseBtn">Ã—</span>

            <div class="flex items-center space-x-4 mb-4">

                <div id="cardInfoDisplay" class="flex-shrink-0"></div>

                <div>

                    <h2 id="cardInfoName" class="text-2xl font-bold">Card Name</h2>

                    <p id="cardInfoType" class="text-lg text-gray-400">Card Type</p>

                    <p id="cardInfoLevel" class="text-lg font-bold text-yellow-300">Level 1</p>

                </div>

            </div>

            

            <!-- Tabs -->

            <div class="flex w-full bg-gray-700 rounded-lg p-1 mb-4">

                <!-- Add explicit onclick handlers to ensure tab switching works even if the JS event listener fails -->

                <button id="cardTabStats" class="flex-1 py-2 rounded text-sm font-bold transition bg-gray-600 text-white shadow-md flex justify-center items-center" onclick="switchTab('stats')">Stats</button>

                <button id="cardTabPreview" class="flex-1 py-2 rounded text-sm font-bold transition text-gray-400 hover:bg-gray-600 hover:text-white flex justify-center items-center" onclick="switchTab('preview')">Preview</button>

            </div>

            <!-- Stats Panel -->

            <div id="cardInfoStatsPanel">

                <hr class="border-gray-500 my-4">

                <div id="cardInfoStats" class="space-y-1"></div>
                <div id="cardAbilityBlock" class="card-ability-block hidden">
                    <div id="cardAbilityName" class="card-ability-name"></div>
                    <div id="cardAbilityDetails" class="card-ability-details"></div>
                </div>

                <div id="cardInfoButtons"></div>

                <div id="cardInfoProgressContainer">

                    <div id="cardInfoProgressBar" style="width: 0%;"></div>

                    <div id="cardInfoProgressText">0 / 0</div>

                </div>

                <button id="cardInfoButton" class="modal-btn"></button>

            </div>

            <!-- Preview Panel -->

            <div id="cardInfoPreviewPanel" class="hidden flex-col items-center w-full">

                <canvas id="cardPreviewCanvas" width="300" height="200" class="bg-gray-800 rounded-lg mb-4 border-2 border-gray-600 shadow-inner"></canvas>

                                <button id="previewRefreshButton" class="w-full mb-3 px-3 py-2 text-xs uppercase tracking-wider font-bold text-blue-200 bg-blue-900 bg-opacity-50 border border-blue-400 rounded-lg hover:bg-blue-800 transition" type="button">

                                    Refresh Animation

                                </button>

                                <div id="cardAbilityTestStatus" class="text-xs text-gray-300 text-center tracking-wider uppercase"></div>

                <div class="w-full text-center space-y-3">

                    <div>

                        <h4 id="previewStrongHeader" class="text-green-300 font-bold text-sm uppercase tracking-wider mb-2 border-b border-gray-700 pb-1">Good Against</h4>

                        <div id="previewStrong" class="flex flex-wrap gap-2 min-h-[40px] bg-gray-900 bg-opacity-50 p-2 rounded-lg"></div>

                    </div>

                    <div id="previewWeakContainer">

                        <h4 id="previewWeakHeader" class="text-red-400 font-bold text-sm uppercase tracking-wider mb-2 border-b border-gray-700 pb-1">Weak Against</h4>

                        <div id="previewWeak" class="flex flex-wrap gap-2 min-h-[40px] bg-gray-900 bg-opacity-50 p-2 rounded-lg"></div>

                    </div>

                    <!-- Test Against All Section -->

                    <div class="pt-2 border-t border-gray-600 mt-2">

                        <h4 class="text-blue-400 font-bold text-sm uppercase tracking-wider mb-2">Test Against Any Card</h4>

                        <input type="text" id="previewSearchInput" placeholder="Search cards..." class="w-full bg-gray-900 text-white p-2 rounded mb-2 border border-gray-600 text-sm focus:outline-none focus:border-blue-500 transition-colors">

                        <div id="previewAllCardsList" class="flex flex-wrap gap-2 max-h-40 overflow-y-auto bg-gray-900 bg-opacity-50 p-2 rounded-lg justify-center"></div>

                    </div>

                </div>

            </div>

        </div>

    </div>

    

    <!-- 

    ========================================================

    BOX OPENING MODAL

    ========================================================

    -->

    <div id="chestOpenOverlay">

        <h2 id="chestTitle" class="text-4xl font-bold">Box Unlocked!</h2>

        <div id="chestStars" class="flex justify-center my-4 space-x-2 h-8">

            <!-- Stars injected here -->

        </div>

        

        <div id="chestClickArea" class="cursor-pointer transition p-8 rounded-full" style="outline: none; -webkit-tap-highlight-color: transparent;">

            <div id="chestEmoji" class="text-9xl select-none">ðŸ“¦</div>

        </div>

        

        <div id="chestStatusText" class="text-xl text-yellow-300 font-bold mb-4 h-8" style="text-shadow: 2px 2px 0px #000;">Click the Box!</div>

        <div id="chestClickCounter" class="text-sm text-gray-400 mb-4 h-4"></div>

        <div id="chestRewardList" class="w-full max-w-xs space-y-2 mb-4">

            <!-- Rewards injected by JS -->

        </div>

        

        <!-- Buttons hidden initially, controlled by JS logic -->

        <button id="chestCloseButton" class="modal-btn bg-green-600 hidden btn-shine">Awesome!</button>

    </div>

    <!-- 

    ========================================================

    DEBUG PASSWORD MODAL (NEW)

    ========================================================

    -->

    <div id="debugPasswordOverlay">

        <h2 class="text-2xl font-bold">Enter Debug Password</h2>

        <input type="password" id="debugPasswordInput" placeholder="Password">

        <button id="debugPasswordSubmit">Enter</button>

        <button id="debugPasswordCancel" class="cancel-btn">Cancel</button>

    </div>

    <!-- 

    ========================================================

    SAVE DATA MODAL (NEW)

    ========================================================

    -->

    <div id="saveDataOverlay">

        <h2 class="text-2xl font-bold">Your Save Key</h2>

        <p class="text-sm font-normal text-gray-300 mt-2">Copy this key and save it somewhere safe!</p>

        <textarea id="saveKeyOutput" readonly>Generating key...</textarea>

        <button id="generateKeyBtn">Generate New Key</button>

        <button id="saveDataCancel" class="cancel-btn">Close</button>

    </div>

    <!-- 

    ========================================================

    LOAD DATA MODAL (NEW)

    ========================================================

    -->

    <div id="loadDataOverlay">

        <h2 class="text-2xl font-bold">Load Save Key</h2>

        <p class="text-sm font-normal text-gray-300 mt-2">Paste your save key below to load progress.</p>

        <input type="text" id="loadKeyInput" placeholder="Paste your key here">

        <button id="loadKeySubmit">Load Progress</button>

        <button id="loadDataCancel" class="cancel-btn">Cancel</button>

    </div>

    <!-- 

    ========================================================

    UPDATE LOG MODAL (NEW)

    ========================================================

    -->

	    <div id="updateLogOverlay">
	        <div class="update-log-panel glossy-panel">

        <!-- Animated header with battle scene and update icons -->

        <div class="update-log-icons flex justify-center items-center space-x-2 text-3xl mb-2">
            <span class="animate-bounce">ðŸŒŒ</span>
            <span class="animate-ping">âœ¨</span>
            <span class="animate-spin">ðŸš€</span>
        </div>

  <h2 class="text-3xl font-bold mb-4">âš¡ Emoji Royale Update Log âœ¨</h2>

<div id="updateLogContent" class="text-left text-sm max-h-96 overflow-y-auto w-full max-w-md px-4 space-y-3">

            <!-- Update log content will be injected by JS -->

        </div>

	        <button id="updateLogClose" class="mt-4">Continue</button>
	        </div>

	    </div>

    <div id="announcementOverlay" class="announcement-overlay">

        <div class="announcement-panel">

            <h2>ðŸ“¢ Important Announcement Regarding the Future of Emoji Royale</h2>

            <p>I would like to take a moment to address something important about the future of Emoji Royale. As the developer, I always want to be transparent with everyone who plays and supports the game.</p>

            <p>Recently, I have been reviewing the direction of Emoji Royale, and I've realized that the game's continuation may depend on the community's interest and feedback. Because of this, I will be holding a vote to help determine whether the game will continue to receive updates or if it will potentially be shut down.</p>

            <p>I want to make it very clear: no decision has been made yet. The outcome will depend entirely on the results of the vote and the amount of support the game receives from the community. I am giving everyone the chance to voice their opinion because your input truly matters to me, and I want to make the best decision for the game and its players.</p>

            <p>I appreciate all of you who have been part of Emoji Royale so far. Your feedback, support, and excitement are the reasons the game exists in the first place. Regardless of the results, I want to thank you for being a part of this project.</p>

            <p>The vote will be available soon. Please take a moment to participate when it goes liveâ€”it will directly shape the future of Emoji Royale.</p>

            <p class="italic text-gray-300">Thank you for your understanding and continued support. â€” I appreciate every one of you.</p>

            <button id="announcementOkBtn" class="modal-btn w-full">OK</button>

        </div>

    </div>

    <div id="voteOverlay" class="vote-overlay">

        <div class="vote-panel">

            <h2>Shutdown Emoji Royale</h2>

            <p class="text-sm text-gray-200">The community vote is live. Cast your single vote below to let your voice be heard about whether Emoji Royale keeps receiving updates.</p>

            <div class="vote-buttons">

                <button id="voteYesButton" class="modal-btn remove">Yes, shut it down</button>

                <button id="voteNoButton" class="modal-btn add">No, keep it alive</button>

            </div>

            <div id="voteStatusText" class="text-xs text-gray-400 text-center">You can only vote once per browser.</div>

            <div id="voteResults" class="vote-results text-center">Yes: 0 Â· No: 0</div>

            <button id="voteContinueButton" class="modal-btn mt-4">Continue</button>

        </div>

    </div>

    <div id="siteMoveOverlay" data-permanently-hidden="true" aria-hidden="true" style="display: none !important; pointer-events: none;" role="dialog" aria-label="Site migration notice">

        <div class="site-move-panel">

            <h2>Site is moving soon</h2>

            <p>This site is being moved to a new domain for expanded features. You may still play on this domain but it will become inactive soon. Don't worry, all data is stored on save keys and won't be wiped on the new domain.</p>

            <div class="site-move-buttons">

                <button id="siteMoveStayButton" class="secondary" type="button">Stay on this domain</button>

                <a id="siteMoveNewDomainButton" class="primary" href="https://emoji-royale.netlify.app/" target="_blank" rel="noopener noreferrer">Move to new domain</a>

            </div>

        </div>

    </div>

    <!-- Persistent Bottom Nav -->

    <div id="bottomNav" class="bg-gray-800 w-full max-w-[400px] rounded-t-lg shadow-inner p-1 btn-shine bottom-nav-hidden">

        <div class="relative w-full h-full">

            <div id="navHighlight"></div>

            <div class="grid grid-cols-5 relative z-10" style="grid-template-columns: repeat(5, minmax(0, 1fr));">

                <button id="navBtnMenu" class="nav-btn flex flex-col items-center text-yellow-400 py-1" data-screen="menu">

                    <span class="text-3xl">âš”ï¸</span>

                    <span class="text-xs font-bold">Battle</span>

                </button>

                <button id="navBtnDeck" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="deck">

                    <span class="text-3xl">ðŸƒ</span>

                    <span class="text-xs font-bold">Deck</span>

                </button>

                <button id="navBtnTower" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="tower">

                    <span class="text-3xl">ðŸ‘‘</span>

                    <span class="text-xs font-bold">Tower</span>

                </button>

                <button id="navBtnEvents" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="events">

                    <span id="navEventsBadge" class="nav-badge hidden">!</span>

                    <span class="text-3xl">âš¡</span>

                    <span class="text-xs font-bold">Events</span>

                </button>

                <button id="navBtnDebug" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="debug">

                    <span class="text-3xl">ðŸ§ª</span>

                    <span class="text-xs font-bold">Debug</span>

                </button>

            </div>

        </div>

    </div>

    <!-- 

    ========================================================

    MAIN SCRIPT

    ========================================================

    -->

    <script type="module">

        // Import the functions you need from the SDKs you need

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";

        import { getAuth, signInAnonymously, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        import { getDatabase, ref, set, onValue, off, update, remove, push, onChildAdded, onChildRemoved } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        /* LZString (MIT) - trimmed utility for compact save keys */

        const LZString = (() => {

            const f = String.fromCharCode;

            const keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

            function compressToEncodedURIComponent(input) {

                if (input == null) return "";

                return _compress(input, 6, a => keyStrBase64.charAt(a));

            }

            function decompressFromEncodedURIComponent(input) {

                if (!input) return "";

                input = input.replace(/ /g, "+");

                return _decompress(input.length, 32, index => keyStrBase64.indexOf(input.charAt(index)));

            }

            function _compress(uncompressed, bitsPerChar, getCharFromInt) {

                if (uncompressed == null) return "";

                let i, value,

                    context_dictionary = {},

                    context_dictionaryToCreate = {},

                    context_c = "",

                    context_wc = "",

                    context_w = "",

                    context_enlargeIn = 2,

                    context_dictSize = 3,

                    context_numBits = 2,

                    context_data = [],

                    context_data_val = 0,

                    context_data_position = 0;

                for (let ii = 0; ii < uncompressed.length; ii += 1) {

                    context_c = uncompressed.charAt(ii);

                    if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {

                        context_dictionary[context_c] = context_dictSize++;

                        context_dictionaryToCreate[context_c] = true;

                    }

                    context_wc = context_w + context_c;

                    if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {

                        context_w = context_wc;

                    } else {

                        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {

                            if (context_w.charCodeAt(0) < 256) {

                                for (i = 0; i < context_numBits; i++) {

                                    context_data_val = (context_data_val << 1);

                                    if (context_data_position == bitsPerChar - 1) {

                                        context_data_position = 0;

                                        context_data.push(getCharFromInt(context_data_val));

                                        context_data_val = 0;

                                    } else {

                                        context_data_position++;

                                    }

                                }

                                value = context_w.charCodeAt(0);

                                for (i = 0; i < 8; i++) {

                                    context_data_val = (context_data_val << 1) | (value & 1);

                                    if (context_data_position == bitsPerChar - 1) {

                                        context_data_position = 0;

                                        context_data.push(getCharFromInt(context_data_val));

                                        context_data_val = 0;

                                    } else {

                                        context_data_position++;

                                    }

                                    value = value >> 1;

                                }

                            } else {

                                value = 1;

                                for (i = 0; i < context_numBits; i++) {

                                    context_data_val = (context_data_val << 1) | value;

                                    if (context_data_position == bitsPerChar - 1) {

                                        context_data_position = 0;

                                        context_data.push(getCharFromInt(context_data_val));

                                        context_data_val = 0;

                                    } else {

                                        context_data_position++;

                                    }

                                    value = 0;

                                }

                                value = context_w.charCodeAt(0);

                                for (i = 0; i < 16; i++) {

                                    context_data_val = (context_data_val << 1) | (value & 1);

                                    if (context_data_position == bitsPerChar - 1) {

                                        context_data_position = 0;

                                        context_data.push(getCharFromInt(context_data_val));

                                        context_data_val = 0;

                                    } else {

                                        context_data_position++;

                                    }

                                    value = value >> 1;

                                }

                            }

                            context_enlargeIn--;

                            if (context_enlargeIn == 0) {

                                context_enlargeIn = Math.pow(2, context_numBits);

                                context_numBits++;

                            }

                            delete context_dictionaryToCreate[context_w];

                        } else {

                            value = context_dictionary[context_w];

                            for (i = 0; i < context_numBits; i++) {

                                context_data_val = (context_data_val << 1) | (value & 1);

                                if (context_data_position == bitsPerChar - 1) {

                                    context_data_position = 0;

                                    context_data.push(getCharFromInt(context_data_val));

                                    context_data_val = 0;

                                } else {

                                    context_data_position++;

                                }

                                value = value >> 1;

                            }

                        }

                        context_enlargeIn--;

                        if (context_enlargeIn == 0) {

                            context_enlargeIn = Math.pow(2, context_numBits);

                            context_numBits++;

                        }

                        context_dictionary[context_wc] = context_dictSize++;

                        context_w = String(context_c);

                    }

                }

                if (context_w !== "") {

                    if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {

                        if (context_w.charCodeAt(0) < 256) {

                            for (i = 0; i < context_numBits; i++) {

                                context_data_val = (context_data_val << 1);

                                if (context_data_position == bitsPerChar - 1) {

                                    context_data_position = 0;

                                    context_data.push(getCharFromInt(context_data_val));

                                    context_data_val = 0;

                                } else {

                                    context_data_position++;

                                }

                            }

                            value = context_w.charCodeAt(0);

                            for (i = 0; i < 8; i++) {

                                context_data_val = (context_data_val << 1) | (value & 1);

                                if (context_data_position == bitsPerChar - 1) {

                                    context_data_position = 0;

                                    context_data.push(getCharFromInt(context_data_val));

                                    context_data_val = 0;

                                } else {

                                    context_data_position++;

                                }

                                value = value >> 1;

                            }

                        } else {

                            value = 1;

                            for (i = 0; i < context_numBits; i++) {

                                context_data_val = (context_data_val << 1) | value;

                                if (context_data_position == bitsPerChar - 1) {

                                    context_data_position = 0;

                                    context_data.push(getCharFromInt(context_data_val));

                                    context_data_val = 0;

                                } else {

                                    context_data_position++;

                                }

                                value = 0;

                            }

                            value = context_w.charCodeAt(0);

                            for (i = 0; i < 16; i++) {

                                context_data_val = (context_data_val << 1) | (value & 1);

                                if (context_data_position == bitsPerChar - 1) {

                                    context_data_position = 0;

                                    context_data.push(getCharFromInt(context_data_val));

                                    context_data_val = 0;

                                } else {

                                    context_data_position++;

                                }

                                value = value >> 1;

                            }

                        }

                        context_enlargeIn--;

                        if (context_enlargeIn == 0) {

                            context_enlargeIn = Math.pow(2, context_numBits);

                            context_numBits++;

                        }

                        delete context_dictionaryToCreate[context_w];

                    } else {

                        value = context_dictionary[context_w];

                        for (i = 0; i < context_numBits; i++) {

                            context_data_val = (context_data_val << 1) | (value & 1);

                            if (context_data_position == bitsPerChar - 1) {

                                context_data_position = 0;

                                context_data.push(getCharFromInt(context_data_val));

                                context_data_val = 0;

                            } else {

                                context_data_position++;

                            }

                            value = value >> 1;

                        }

                    }

                    context_enlargeIn--;

                    if (context_enlargeIn == 0) {

                        context_enlargeIn = Math.pow(2, context_numBits);

                        context_numBits++;

                    }

                }

                value = 2;

                for (i = 0; i < context_numBits; i++) {

                    context_data_val = (context_data_val << 1) | (value & 1);

                    if (context_data_position == bitsPerChar - 1) {

                        context_data_position = 0;

                        context_data.push(getCharFromInt(context_data_val));

                        context_data_val = 0;

                    } else {

                        context_data_position++;

                    }

                    value = value >> 1;

                }

                while (true) {

                    context_data_val = (context_data_val << 1);

                    if (context_data_position == bitsPerChar - 1) {

                        context_data.push(getCharFromInt(context_data_val));

                        break;

                    } else context_data_position++;

                }

                return context_data.join("");

            }

            function _decompress(length, resetValue, getNextValue) {

                const dictionary = [];

                let next,

                    enlargeIn = 4,

                    dictSize = 4,

                    numBits = 3,

                    entry = "",

                    result = [],

                    i,

                    w,

                    bits, resb, maxpower, power,

                    c,

                    data = { val: getNextValue(0), position: resetValue, index: 1 };

                for (i = 0; i < 3; i += 1) {

                    dictionary[i] = i;

                }

                bits = 0;

                maxpower = Math.pow(2, 2);

                power = 1;

                while (power != maxpower) {

                    resb = data.val & data.position;

                    data.position >>= 1;

                    if (data.position == 0) {

                        data.position = resetValue;

                        data.val = getNextValue(data.index++);

                    }

                    bits |= (resb > 0 ? 1 : 0) * power;

                    power <<= 1;

                }

                switch (next = bits) {

                    case 0:

                        bits = 0;

                        maxpower = Math.pow(2, 8);

                        power = 1;

                        while (power != maxpower) {

                            resb = data.val & data.position;

                            data.position >>= 1;

                            if (data.position == 0) {

                                data.position = resetValue;

                                data.val = getNextValue(data.index++);

                            }

                            bits |= (resb > 0 ? 1 : 0) * power;

                            power <<= 1;

                        }

                        c = f(bits);

                        break;

                    case 1:

                        bits = 0;

                        maxpower = Math.pow(2, 16);

                        power = 1;

                        while (power != maxpower) {

                            resb = data.val & data.position;

                            data.position >>= 1;

                            if (data.position == 0) {

                                data.position = resetValue;

                                data.val = getNextValue(data.index++);

                            }

                            bits |= (resb > 0 ? 1 : 0) * power;

                            power <<= 1;

                        }

                        c = f(bits);

                        break;

                    case 2:

                        return "";

                }

                dictionary[3] = c;

                w = c;

                result.push(c);

                while (true) {

                    if (data.index > length) return "";

                    bits = 0;

                    maxpower = Math.pow(2, numBits);

                    power = 1;

                    while (power != maxpower) {

                        resb = data.val & data.position;

                        data.position >>= 1;

                        if (data.position == 0) {

                            data.position = resetValue;

                            data.val = getNextValue(data.index++);

                        }

                        bits |= (resb > 0 ? 1 : 0) * power;

                        power <<= 1;

                    }

                    switch (next = bits) {

                        case 0:

                            bits = 0;

                            maxpower = Math.pow(2, 8);

                            power = 1;

                            while (power != maxpower) {

                                resb = data.val & data.position;

                                data.position >>= 1;

                                if (data.position == 0) {

                                    data.position = resetValue;

                                    data.val = getNextValue(data.index++);

                                }

                                bits |= (resb > 0 ? 1 : 0) * power;

                                power <<= 1;

                            }

                            dictionary[dictSize++] = f(bits);

                            next = dictSize - 1;

                            enlargeIn--;

                            break;

                        case 1:

                            bits = 0;

                            maxpower = Math.pow(2, 16);

                            power = 1;

                            while (power != maxpower) {

                                resb = data.val & data.position;

                                data.position >>= 1;

                                if (data.position == 0) {

                                    data.position = resetValue;

                                    data.val = getNextValue(data.index++);

                                }

                                bits |= (resb > 0 ? 1 : 0) * power;

                                power <<= 1;

                            }

                            dictionary[dictSize++] = f(bits);

                            next = dictSize - 1;

                            enlargeIn--;

                            break;

                        case 2:

                            return result.join("");

                    }

                    if (enlargeIn == 0) {

                        enlargeIn = Math.pow(2, numBits);

                        numBits++;

                    }

                    if (dictionary[next]) {

                        entry = dictionary[next];

                    } else {

                        if (next === dictSize) {

                            entry = w + w.charAt(0);

                        } else {

                            return null;

                        }

                    }

                    result.push(entry);

                    dictionary[dictSize++] = w + entry.charAt(0);

                    w = entry;

                }

            }

            return { compressToEncodedURIComponent, decompressFromEncodedURIComponent };

        })();

        const SaveKeyManager = (() => {

            function encode(data) {

                if (!data) return '';

                const jsonString = JSON.stringify(data);

                const base64Payload = toBase64(jsonString);

                return `B${base64Payload}`;

            }

            function decode(saveKey) {

                if (!saveKey) return null;

                if (saveKey.startsWith('B')) {

                    try {

                        return JSON.parse(fromBase64(saveKey.slice(1)));

                    } catch (error) {

                        return null;

                    }

                }

                let decoded = LZString.decompressFromEncodedURIComponent(saveKey);

                if (!decoded) {

                    try {

                        decoded = atob(saveKey);

                    } catch (error) {

                        return null;

                    }

                }

                try {

                    return decoded ? JSON.parse(decoded) : null;

                } catch (error) {

                    return null;

                }

            }

            function toBase64(input) {

                const encoded = encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));

                return btoa(encoded);

            }

            function fromBase64(base64) {

                const decoded = atob(base64);

                return decodeURIComponent([...decoded].map((ch) => '%' + ch.charCodeAt(0).toString(16).padStart(2, '0')).join(''));

            }

            return { encode, decode };

        })();

        function getSaveKeyManager() {
            if (typeof SaveKeyManager !== 'undefined' && SaveKeyManager) return SaveKeyManager;
            if (typeof globalThis !== 'undefined' && globalThis.SaveKeyManager) return globalThis.SaveKeyManager;
            if (typeof window !== 'undefined' && window.SaveKeyManager) return window.SaveKeyManager;
            return null;
        }

        function encodeSaveKeyData(data) {
            const manager = getSaveKeyManager();
            if (!manager || typeof manager.encode !== 'function') return '';
            return manager.encode(data);
        }

        function decodeSaveKeyString(saveKey) {
            const normalizedKey = typeof saveKey === 'string' ? saveKey.replace(/\s+/g, '') : '';
            if (!normalizedKey) return null;
            const manager = getSaveKeyManager();
            if (!manager || typeof manager.decode !== 'function') return null;
            return manager.decode(normalizedKey);
        }



        (function registerSaveKeyGlobals() {
            const registrar = typeof globalThis !== 'undefined'
                ? globalThis
                : typeof window !== 'undefined'
                    ? window
                    : {};

            registrar.encodeSaveKeyData = encodeSaveKeyData;
            registrar.decodeSaveKeyString = decodeSaveKeyString;

            if (typeof window !== 'undefined' && registrar !== window) {
                window.encodeSaveKeyData = encodeSaveKeyData;
                window.decodeSaveKeyString = decodeSaveKeyString;
            }
        })();

        // WebRTC configuration

        const rtcConfig = {

            iceServers: [

                { urls: 'stun:stun.l.google.com:19302' },

                { urls: 'stun:stun1.l.google.com:19302' },

                { urls: 'stun:stun2.l.google.com:19302' }

            ]

        };

        

        // Global multiplayer state

        let peerConnection = null;

        let dataChannel = null;

        let currentRoomId = null;

        let isHost = false;

        let remotePlayerId = null;

        // Your web app's Firebase configuration

        // Your web app's Firebase configuration

const firebaseConfig = {

    apiKey: "AIzaSyCnaXKjDvPDXP2tF5ZmtB7naYjCuLGUsd4",

    authDomain: "emoji-royale-8fb68.firebaseapp.com",

    databaseURL: "https://emoji-royale-8fb68-default-rtdb.firebaseio.com",

    projectId: "emoji-royale-8fb68",

    storageBucket: "emoji-royale-8fb68.firebasestorage.app",

    messagingSenderId: "1021589049311",

    appId: "1:1021589049311:web:61ce6353950831e298be6a",

    measurementId: "G-FDQ9L0MQGM"

};

        // Initialize Firebase

        const app = initializeApp(firebaseConfig);

        const auth = getAuth(app);

        const db = getFirestore(app);

        const rtdb = getDatabase(app); // Initialize Realtime Database

        const provider = new GoogleAuthProvider();

        // setLogLevel('debug'); // Uncomment for debugging Firestore

        

        // Multiplayer functions

        async function createRoom() {

            isHost = true;

            currentRoomId = 'room-' + Math.random().toString(36).substr(2, 9);

            

            // Create peer connection

            peerConnection = new RTCPeerConnection(rtcConfig);

            setupDataChannel();

            

            // Create offer

            const offer = await peerConnection.createOffer();

            await peerConnection.setLocalDescription(offer);

            

            // Save room to Firebase

            const roomRef = ref(rtdb, 'rooms/' + currentRoomId);

            await set(roomRef, {

                hostId: userId,

                offer: offer,

                timestamp: Date.now()

            });

            

            // Listen for answers

            onValue(ref(rtdb, `rooms/${currentRoomId}/answer`), async (snapshot) => {

                if (snapshot.exists() && peerConnection.signalingState !== 'stable') {

                    const answer = snapshot.val();

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));

                    console.log('Answer received and remote description set');

                }

            });

            

            return currentRoomId;

        }

        

        async function joinRoom(roomId) {

            isHost = false;

            currentRoomId = roomId;

            

            // Get room data

            const roomRef = ref(rtdb, 'rooms/' + roomId);

            const snapshot = await get(roomRef);

            

            if (!snapshot.exists()) {

                throw new Error('Room not found');

            }

            

            const roomData = snapshot.val();

            remotePlayerId = roomData.hostId;

            

            // Create peer connection

            peerConnection = new RTCPeerConnection(rtcConfig);

            setupDataChannel();

            

            // Set remote description

            await peerConnection.setRemoteDescription(new RTCSessionDescription(roomData.offer));

            

            // Create answer

            const answer = await peerConnection.createAnswer();

            await peerConnection.setLocalDescription(answer);

            

            // Send answer back to host

            await update(ref(rtdb, 'rooms/' + roomId), {

                answer: answer,

                joinerId: userId

            });

            

            return true;

        }

        

        function setupDataChannel() {

            if (isHost) {

                dataChannel = peerConnection.createDataChannel('gameData');

                setupDataChannelHandlers();

            } else {

                peerConnection.ondatachannel = (event) => {

                    dataChannel = event.channel;

                    setupDataChannelHandlers();

                };

            }

            

            // ICE Candidate handling

            peerConnection.onicecandidate = (event) => {

                if (event.candidate) {

                    const candidateRef = ref(rtdb, `rooms/${currentRoomId}/candidates/${isHost ? 'host' : 'joiner'}/${Date.now()}`);

                    set(candidateRef, event.candidate);

                }

            };

            

            // Listen for ICE candidates

            const candidateType = isHost ? 'joiner' : 'host';

            onChildAdded(ref(rtdb, `rooms/${currentRoomId}/candidates/${candidateType}`), async (snapshot) => {

                const candidate = snapshot.val();

                try {

                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));

                } catch (e) {

                    console.error('Error adding ICE candidate:', e);

                }

            });

        }

        

        function setupDataChannelHandlers() {

            dataChannel.onopen = () => {

                console.log('Data channel opened');

                // Notify UI that connection is ready

                if (window.onMultiplayerConnected) {

                    window.onMultiplayerConnected();

                }

            };

            

            dataChannel.onmessage = (event) => {

                const data = JSON.parse(event.data);

                console.log('Received data:', data);

                

                // Handle different message types

                if (data.type === 'gameAction') {

                    // Handle game action from other player

                    handleGameAction(data.action, data.payload);

                }

            };

        }

        

        function sendGameAction(action, payload) {

            if (dataChannel && dataChannel.readyState === 'open') {

                dataChannel.send(JSON.stringify({

                    type: 'gameAction',

                    action: action,

                    payload: payload,

                    timestamp: Date.now()

                }));

                return true;

            }

            return false;

        }

        

        function cleanupMultiplayer() {

            if (dataChannel) {

                dataChannel.close();

                dataChannel = null;

            }

            

            if (peerConnection) {

                peerConnection.close();

                peerConnection = null;

            }

            

            if (currentRoomId && isHost) {

                // Remove room when host disconnects

                remove(ref(rtdb, 'rooms/' + currentRoomId));

            }

            

            currentRoomId = null;

            isHost = false;

            remotePlayerId = null;

        }

        

        // Make multiplayer functions available globally

        window.createRoom = createRoom;

        window.joinRoom = joinRoom;

        window.sendGameAction = sendGameAction;

        window.cleanupMultiplayer = cleanupMultiplayer;

        // setLogLevel('debug'); // Uncomment for debugging Firestore

        

        // Multiplayer Service

        const multiplayer = {

            gameId: null,

            isHost: false,

            playerId: Math.random().toString(36).substr(2, 9),

            playerName: 'Player ' + Math.floor(Math.random() * 1000),

            

            // Initialize a new game

            async createGame() {

                this.isHost = true;

                this.gameId = 'game_' + Math.random().toString(36).substr(2, 6).toUpperCase();

                

                // Create game in database

                await set(ref(database, `games/${this.gameId}`), {

                    host: this.playerId,

                    players: {

                        [this.playerId]: {

                            name: this.playerName,

                            ready: false

                        }

                    },

                    status: 'waiting',

                    createdAt: Date.now()

                });

                

                return this.gameId;

            },

            

            // Join an existing game

            async joinGame(gameId) {

                this.isHost = false;

                this.gameId = gameId.toUpperCase();

                

                // Check if game exists

                const gameRef = ref(database, `games/${this.gameId}`);

                const snapshot = await get(gameRef);

                

                if (!snapshot.exists()) {

                    throw new Error('Game not found');

                }

                

                // Add player to game

                await update(ref(database, `games/${this.gameId}/players`), {

                    [this.playerId]: {

                        name: this.playerName,

                        ready: false

                    }

                });

                

                return true;

            },

            

            // Listen for game state changes

            onGameUpdate(callback) {

                const gameRef = ref(database, `games/${this.gameId}`);

                return onValue(gameRef, (snapshot) => {

                    const game = snapshot.val();

                    callback(game);

                });

            },

            

            // Update player ready status

            async setReady(ready) {

                await update(ref(database, `games/${this.gameId}/players/${this.playerId}`), {

                    ready: ready

                });

            },

            

            // Start the game (host only)

            async startGame() {

                if (!this.isHost) return;

                

                await update(ref(database, `games/${this.gameId}`), {

                    status: 'playing',

                    startedAt: Date.now()

                });

            },

            

            // Clean up

            cleanup() {

                if (this.gameId) {

                    // If host, delete the game, otherwise just remove the player

                    if (this.isHost) {

                        remove(ref(database, `games/${this.gameId}`));

                    } else {

                        remove(ref(database, `games/${this.gameId}/players/${this.playerId}`));

                    }

                }

            }

        };

        

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Use __app_id

        let userDocRef; // Reference to the user's document in Firestore

        let userId; // The user's unique ID

        

        // --- Global State ---

                let lastTime = 0;

                let isProcessingClick = false;

                let deltaTime = 0;

        let gameLoopId = 0;

        let currentScreen = 'intro'; // Start on intro screen

        let trophies = 0;

        let gold = 500;

        let trophyChests = Array(4).fill(undefined);

        let allCards = {};

        let cardCollection = {};

        // --- Star and Evolution System ---

        // Number of quarter stars the player has earned (awarded at trophy milestones)

        let quarterStars = 0;

        // Track how many Quarter Star boxes (star boxes) the player has opened

        let starBoxesOpened = 0;

        // Whether the superhero slot feature is unlocked (requires opening the second star box)

        let superheroesUnlocked = false;

        // Track the highest trophy milestone reached for quarter stars. Prevents awarding stars repeatedly

        // when returning to the menu or reloading. A new star is awarded each time trophies cross

        // (lastQuarterMilestone + 2500). This value is saved with user data.

        let lastQuarterMilestone = 0;

        // (Deprecated) Progress towards opening the first star box. This used to require multiple upgrades

        // but the new design only requires a single quarter star to open the box. The variable remains

        // for backward compatibility but is no longer used.

        let box1StarProgress = 0;

        // Whether the player has unlocked the Evolution feature via the first star box

        let evolutionsUnlocked = false;

        // Count of evolution shards collected from star boxes

        let evolutionShards = 0;

        // Count of superhero shards collected from chests

        let superheroShards = 0;

        // -------------------------------------------------------------------------

        // Global flags for evolution propagation

        // When a card with an evolution is spawned while these flags are true,

        // all units spawned during that call (including those from group classes)

        // will automatically have their `isEvolved` property set.  The

        // `currentSpawnCardHasEvo` flag ensures we only mark units as evolved

        // when the originating card actually has an evolution defined.  These

        // values are toggled in the preview system and when playing evolved

        // cards in game.  They reset immediately after spawning.

        window.pendingEvoSpawn = false;

        window.currentSpawnCardHasEvo = false;

        // Track evolution cycle counts for each card for the player and AI.  

        // When a card with an evolution is played from an evolution slot, the count increments.  

        // Once the count reaches the required cycle for that card (e.g. 2 for Knight), the next placement of that card

        // will spawn the evolved version and reset the counter.  These counters reset at the start of each match.

        let playerEvoCycleCounts = {};

        let aiEvoCycleCounts = {};

        let ai2EvoCycleCounts = {};

        // --- Evolution Preview & Deck Control ---

        // When viewing a card in the modal, the player can toggle to see the evolved version

        // in the preview. This flag is reset whenever a new card modal is opened.

        let previewUseEvo = false;

        // Track which cards have their evolution unlocked. Keys are card IDs; values are true

        // when the card's evolution has been unlocked. This is saved with the user's data.

        let evoUnlockedCards = {};

        let matchEvoSlots = { single: [], '2v2': [], 'party1v1': [], emojiDash: [], chaos: [] };

            function shouldSpawnAiEvolution(cardId, cardDef, cycleStore, allowEvolution = false, budgetStore = null) {
            if (!allowEvolution || !cardId || !cardDef || !cardDef.evo || !cycleStore) return false;
            try {
                const baseCycle = Math.max(1, cardDef.evo.cycle || 1);
                const currentCount = cycleStore[cardId] || 0;

                if (currentCount >= baseCycle) {
                    // Evolve
                    const remaining = (budgetStore && typeof budgetStore.remaining === 'number') ? budgetStore.remaining : Infinity;
                    if (remaining <= 0) {
                        cycleStore[cardId] = 0;
                        return false;
                    }
                    cycleStore[cardId] = 0;
                    if (budgetStore && typeof budgetStore.remaining === 'number') {
                        budgetStore.remaining = Math.max(0, budgetStore.remaining - 1);
                    }
                    return true;
                } else {
                    // Don't evolve, just increment
                    cycleStore[cardId] = currentCount + 1;
                    return false;
                }
            } catch (err) {
                console.warn('AI evolution counter error', err);
            }
            return false;
        }

        function configureAiEvolutionBudgets() {

            let allocation = 0;

            if (aiDeckArena >= 11) {

                const roll = Math.random();

                if (roll < 0.25) allocation = 2;

                else if (roll < 0.75) allocation = 1;

            }

            aiEvoBudget.remaining = allocation;

            ai2EvoBudget.remaining = allocation;

        }

        let playerDeck = [];

        let playerDeck2v2 = [];

        let playerDeckParty = [];

        let playerDeckChaos = [];

        let playerDeckEmojiDash = [];

        let playerHeroSlot = null;

        let playerHeroSlot2v2 = null;

        let playerHeroSlotParty = null;

        let playerHeroSlotChaos = null;

        let playerHeroSlotEmojiDash = null;
        let playerHeroUnit = null;
        let previewHeroAbilityCardId = null;
        let previewHeroAbilityCooldown = 0;
        let previewHeroAbilityUsesLeft = null;

        let gameDeck = [];

        let hand = [];

        let nextCard = null;

        let collectionSearchTerm = '';

        let lockedSearchTerm = '';

        let discardPile = [];

                let aiDeck = [];

                let aiHand = [];

                let aiNextCard = null;

                let aiDiscardPile = [];

                let aiDeckArena = 1;

                let aiCanUseEvo = false;

                let ai2CanUseEvo = false;

                let aiEvoBudget = { remaining: 0 };

                let ai2EvoBudget = { remaining: 0 };

        let towerLevel = 1;

        let towerCardCount = 0;

        let selectedTower = 'princess';

        let towerCollection = {};

        let lastClaimDate = "";

        // --- NEW: Level Cap at 15 ---

        const towerUpgradeCosts = {

            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },

            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },

            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },

            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },

            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },

        };

        const towerDefs = {

            'princess': { name: 'Princess', emoji: 'ðŸ‘¸', desc: 'Standard tower.', healthMod: 1, dmgMod: 1, speedMod: 1, special: null },

            'waffle': { name: 'Waffle Maker', emoji: 'ðŸ§‡', desc: 'King throws waffles that level up troops! Weaker stats.', healthMod: 0.8, dmgMod: 0.8, speedMod: 1.2, special: 'waffle' },

            'machineGun': { name: 'Machine Gun', emoji: 'ðŸ”«', desc: 'Bursts rapid fire for 3s then slows down.', healthMod: 0.7, dmgMod: 0.6, speedMod: 0.25, special: 'burst' },

            'rocketeer': { name: 'Rocketeer', emoji: 'ðŸš€', desc: 'Slow but heavy damage. Low health.', healthMod: 0.5, dmgMod: 5.0, speedMod: 3.0, special: 'rocket' }

        };

        const towerStats = {

            1: { kingHealth: 2000, princessHealth: 1000, damage: 50, hitSpeed: 1 },

            2: { kingHealth: 2200, princessHealth: 1100, damage: 55, hitSpeed: 1 },

            3: { kingHealth: 2420, princessHealth: 1210, damage: 60, hitSpeed: 1 },

            4: { kingHealth: 2662, princessHealth: 1331, damage: 66, hitSpeed: 1 },

            5: { kingHealth: 2928, princessHealth: 1464, damage: 72, hitSpeed: 1 },

            6: { kingHealth: 3220, princessHealth: 1610, damage: 79, hitSpeed: 1 },

            7: { kingHealth: 3542, princessHealth: 1771, damage: 87, hitSpeed: 1 },

            8: { kingHealth: 3896, princessHealth: 1948, damage: 96, hitSpeed: 1 },

            9: { kingHealth: 4285, princessHealth: 2142, damage: 105, hitSpeed: 1 },

            10: { kingHealth: 4713, princessHealth: 2356, damage: 116, hitSpeed: 1 },

            11: { kingHealth: 5184, princessHealth: 2591, damage: 128, hitSpeed: 1 },

            12: { kingHealth: 5702, princessHealth: 2850, damage: 141, hitSpeed: 1 },

            13: { kingHealth: 6272, princessHealth: 3135, damage: 155, hitSpeed: 1 },

            14: { kingHealth: 6899, princessHealth: 3448, damage: 170, hitSpeed: 1 },

            15: { kingHealth: 7589, princessHealth: 3793, damage: 187, hitSpeed: 1 },

        };

        let selectedSpawningUnit = null;

        let isSpawningSpell = false;

        let spellRadius = 0;

        let placementRadius = 0;

        let canPlace = false;

        /*

         * Arena floors define the trophy milestones at which new arenas are unlocked.

         * Diddy's Prison is Arena 11 (2500 trophies), Mythic Arena is Arena 12 (2750 trophies),

         * the Aqua Arena unlocks at 3000 trophies, the Stellar Observatory arrives at 4500 trophies,

         * and the Snack Pit opens at 5000 trophies for Quarter Star 2 celebrations.

         */

        const arenaFloors = { 0: "Arena 1: Emoji Valley", 250: "Arena 2: Laughing Village", 500: "Arena 3: Lava Town", 750: "Arena 4: The Farm", 1000: "Arena 5: Skull Kingdom", 1250: "Arena 6: Warlock's Workshop", 1500: "Arena 7: Mages Graveyard", 1750: "Arena 8: Chaos Canyon", 2000: "Arena 9: Titan's Peak", 2250: "Arena 10: Chaos Realm", 2500: "Arena 11: Diddy's Prison", 2750: "Arena 12: Mythic Arena", 3000: "Arena 13: Aqua Arena", 3250: "Arena 14: Forsaken Lands", 3500: "Arena 15: Buried Kingdom", 3750: "Arena 16: Mirror Plateau", 4000: "Arena 17: Celestial Citadel", 4250: "Arena 18: Nebula Nexus", 4500: "Arena 19: Stellar Observatory", 4750: "Arena 20: Celestial Cascade", 5000: "Arena 21: Snack Pit" };

        const sortedArenaFloors = Object.keys(arenaFloors).map(Number).sort((a, b) => a - b);

        function getArenaNumberFromFloor(floor = 0) {

            for (let i = sortedArenaFloors.length - 1; i >= 0; i--) {

                if (floor >= sortedArenaFloors[i]) {

                    return i + 1;

                }

            }

            return 1;

        }

        function getArenaStrategyProfile() {

            const arenaNumber = Math.max(1, getArenaNumberFromFloor(currentArenaFloor));

            return {

                arenaNumber,

                earlyArena: arenaNumber <= 3,

                smartArena: arenaNumber >= 6,

                preferSpells: arenaNumber >= 7

            };

        }

        let currentArenaFloor = 0;

        let currentArenaTheme = 'arena-1'; // For canvas styling

        // --- NEW: Level Cap at 15 ---

        const upgradeCosts = {

            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },

            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },

            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },

            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },

            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },

        };

        let isDataSaved = true; // Flag to control saving

        let isInitialAuthCheck = true; // Flag to stop auto-login

        let loadTimeout; // Timer for stuck loads

        let isLoading = false; // Flag to prevent double-loads

        let hasShownUpdateLog = false; // Flag to track if update log has been shown this session

        let generateKeyTimeout; // NEW: Timer for save key generation

        let isDemoMode = false; // Demo mode flag (set when unauthorized domain detected)

        const emojiDashConfig = {

            canvasWidth: 768,

            canvasHeight: 360,

            groundHeight: 52,

            gravity: 2500,

            moveSpeed: 260,

            aiSpeed: 180,

            jumpStrength: 650,

            spawnCost: 6,

            maxElixir: 10,

            regenRate: 3.1,

            playerDamage: 34,

            aiDamage: 26,

            attackCooldown: 0.6,

            aiAttackCooldown: 1.4,

            aiSpawnDelay: 3.5,

            kingTowerHealth: 1400

        };

        const emojiDashLevels = [

            { id: 1, name: 'Level 1', label: 'Starter Run', floor: 0 },

            { id: 2, name: 'Level 2', label: 'Launch Ridge', floor: 25 },

            { id: 3, name: 'Level 3', label: 'Skyline Circuit', floor: 50 }

        ];

        let emojiDashTrophies = 0;

        let emojiDashLevelId = emojiDashLevels[0].id;

        function getEmojiDashLevelByTrophies(value = emojiDashTrophies) {

            return emojiDashLevels.slice().reverse().find(level => value >= level.floor) || emojiDashLevels[0];

        }

        function getEmojiDashLevelById(id) {

            return emojiDashLevels.find(level => level.id === id) || emojiDashLevels[0];

        }

        function updateEmojiDashLevelFromTrophies() {

            const level = getEmojiDashLevelByTrophies();

            emojiDashLevelId = level.id;

            return level;

        }

        function adjustEmojiDashTrophies(isWin) {

            const delta = isWin ? 1 : -1;

            const currentLevel = getEmojiDashLevelByTrophies();

            let nextValue = emojiDashTrophies + delta;

            if (!isWin && nextValue < currentLevel.floor) {

                nextValue = currentLevel.floor;

            }

            const nextLevel = getEmojiDashLevelByTrophies(nextValue);

            emojiDashTrophies = nextValue;

            emojiDashLevelId = nextLevel.id;

            if (emojiDashState && emojiDashState.levelId !== nextLevel.id) {

                applyEmojiDashLevelToState(nextLevel.id);

            }

            if (typeof updateEmojiDashHUD === 'function') updateEmojiDashHUD();

            return nextLevel;

        }

        function setEmojiDashTrophiesForLevel(levelId) {

            const level = getEmojiDashLevelById(levelId);

            if (!level) return;

            emojiDashTrophies = level.floor;

            emojiDashLevelId = level.id;

            if (emojiDashState) {

                applyEmojiDashLevelToState(level.id);

            }

            if (typeof updateEmojiDashHUD === 'function') updateEmojiDashHUD();

        }

        function applyEmojiDashLevelToState(levelId) {

            if (!emojiDashState) return;

            const levelInfo = getEmojiDashLevelById(levelId);

            emojiDashState.levelId = levelInfo.id;

            emojiDashState.levelName = levelInfo.name;

            emojiDashState.levelLabel = levelInfo.label;

            emojiDashState.spikes = buildEmojiDashSpikes(levelId);

            emojiDashState.jumpPads = buildEmojiDashJumpPads(levelId);

            emojiDashState.platforms = buildEmojiDashPlatforms(levelId);

        }

        function buildEmojiDashSpikes(levelId) {

            const spikes = [];

            const limit = emojiDashConfig.canvasWidth - 160;

            let start = 180;

            let spacing = 150;

            let width = 40;

            let height = 30;

            if (levelId === 2) {

                start = 200;

                spacing = 180;

                width = 50;

                height = 36;

            } else if (levelId === 3) {

                start = 220;

                spacing = 140;

                width = 38;

                height = 34;

            }

            for (let x = start; x < limit; x += spacing) {

                spikes.push({ x, width, height });

            }

            if (levelId === 3) {

                spikes.push({ x: 90, width: 60, height: 42 });

            }

            return spikes;

        }

        function buildEmojiDashJumpPads(levelId) {

            if (levelId === 2) {

                return [

                    { x: 240, width: 130, boost: -890 },

                    { x: 520, width: 110, boost: -860 }

                ];

            }

            if (levelId === 3) {

                return [

                    { x: 200, width: 120, boost: -930 },

                    { x: 460, width: 100, boost: -880 }

                ];

            }

            return [];

        }

        function buildEmojiDashPlatforms(levelId) {

            const groundLine = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight;

            const baseY = groundLine;

            if (levelId === 1) {

                return [

                    { x: 140, y: baseY - 86, width: 180, height: 18 },

                    { x: 420, y: baseY - 110, width: 160, height: 18 }

                ];

            }

            if (levelId === 2) {

                return [

                    { x: 220, y: baseY - 138, width: 200, height: 18 },

                    { x: 540, y: baseY - 96, width: 140, height: 18 }

                ];

            }

            return [

                { x: 120, y: baseY - 152, width: 180, height: 18 },

                { x: 360, y: baseY - 128, width: 200, height: 18 },

                { x: 600, y: baseY - 102, width: 120, height: 18 }

            ];

        }

        function checkEmojiDashJumpPads(entity) {

            if (!entity || !emojiDashState || !emojiDashState.jumpPads) return false;

            const groundLimit = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight - entity.height;

            if (entity.y < groundLimit - 1 || entity.vy < 0) return false;

            for (const pad of emojiDashState.jumpPads) {

                if (entity.x + entity.width > pad.x && entity.x < pad.x + pad.width) {

                    entity.vy = pad.boost;

                    return true;

                }

            }

            return false;

        }

        function resolveEmojiDashPlatformCollision(entity, previousY) {

            if (!entity || !emojiDashState || !Array.isArray(emojiDashState.platforms) || emojiDashState.platforms.length === 0) return false;

            const bottom = entity.y + entity.height;

            const prevBottom = previousY + entity.height;

            const descending = bottom >= prevBottom;

            if (!descending && entity.vy <= 0) return false;

            for (const platform of emojiDashState.platforms) {

                const platformTop = platform.y;

                const platformRight = platform.x + platform.width;

                const horizontalOverlap = entity.x + entity.width > platform.x && entity.x < platformRight;

                const cameFromAbove = prevBottom <= platformTop + 2;

                const overlappingFromEdge = prevBottom > platformTop && previousY < platformTop;

                const crossingVertically = bottom >= platformTop - 2;

                if (horizontalOverlap && crossingVertically && (cameFromAbove || overlappingFromEdge)) {

                    entity.y = platformTop - entity.height;

                    entity.vy = 0;

                    return true;

                }

            }

            return false;

        }

        const emojiDashKeys = { left: false, right: false, jump: false };

        let emojiDashState = null;

        let emojiDashCtx = null;

        let emojiDashLoopId = 0;

        let emojiDashLastTimestamp = 0;

        let emojiDashActive = false;

        const VOTE_TOTALS_KEY = 'emojiRoyaleVoteTotals';

        const VOTE_FLAG_KEY = 'emojiRoyaleHasVoted';

        const VOTE_CHOICE_KEY = 'emojiRoyaleVoteChoice';

        let voteTotals = { yes: 0, no: 0 };

        let hasVoted = false;

        let playerVoteChoice = null;

        let pendingUpdateLogAfterVote = false;

        let voteScheduled = false;

        let menuVoteTimer = null;

        const ANNOUNCEMENTS_ENABLED = false;

        let allowMenuAnnouncements = false;

        let menuAnnouncementsArmed = false;

        // --- Background Particle System ---

        const bgCanvas = document.getElementById('bgCanvas');

        const bgCtx = bgCanvas.getContext('2d');

        let bgParticles = [];

        function resizeBg() {

            bgCanvas.width = window.innerWidth;

            bgCanvas.height = window.innerHeight;

        }

        window.addEventListener('resize', resizeBg);

        resizeBg();

        class BgParticle {

            constructor(initial = false) { 

                this.reset(initial); 

            }

            reset(initial = false) {

                this.x = Math.random() * bgCanvas.width;

                this.y = Math.random() * bgCanvas.height;

                this.size = Math.random() * 4 + 1; // Smaller: 1-5px

                this.speedX = (Math.random() - 0.5) * 1.5; // Faster

                this.speedY = (Math.random() - 0.5) * 1.5;

                this.maxLife = Math.random() * 300 + 200;

                this.life = initial ? Math.random() * this.maxLife : 0;

                this.state = initial ? 'idle' : 'in';

                this.targetAlpha = 0.3 + Math.random() * 0.3; // More varied opacity

                this.alpha = initial ? this.targetAlpha : 0;

            }

            update() {

                this.x += this.speedX; 

                this.y += this.speedY;

                

                // Wrap around screen

                if (this.x < 0) this.x = bgCanvas.width;

                if (this.x > bgCanvas.width) this.x = 0;

                if (this.y < 0) this.y = bgCanvas.height;

                if (this.y > bgCanvas.height) this.y = 0;

                if (this.state === 'in') {

                    this.alpha += 0.01;

                    if (this.alpha >= this.targetAlpha) this.state = 'idle';

                } else if (this.state === 'idle') {

                    this.life++;

                    if (this.life > this.maxLife) this.state = 'out';

                } else if (this.state === 'out') {

                    this.alpha -= 0.01;

                    if (this.alpha <= 0) this.reset();

                }

            }

            draw() {

                // Dull green particles that match the background palette

                bgCtx.fillStyle = `rgba(5, 90, 41, ${this.alpha})`;

                bgCtx.beginPath();

                bgCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);

                bgCtx.fill();

            }

        }

        // More particles, start pre-populated

        for(let i=0; i<80; i++) bgParticles.push(new BgParticle(true));

        let bgAnimationId = null;

        function animateBg() {

            if (!bgAnimationId) return; // Stop if animation was cancelled

            

            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);

            // Draw Grid

            bgCtx.strokeStyle = 'rgba(13, 89, 44, 0.25)';

            bgCtx.lineWidth = 1;

            const gridSize = 40;

            

            for(let x=0; x<=bgCanvas.width; x+=gridSize) { bgCtx.moveTo(x,0); bgCtx.lineTo(x, bgCanvas.height); }

            for(let y=0; y<=bgCanvas.height; y+=gridSize) { bgCtx.moveTo(0,y); bgCtx.lineTo(bgCanvas.width, y); }

            bgCtx.stroke();

            

            bgParticles.forEach(p => { p.update(); p.draw(); });

            bgAnimationId = requestAnimationFrame(animateBg);

        }

        function startBgAnimation() {

            if (!bgAnimationId) {

                bgAnimationId = requestAnimationFrame(animateBg);

            }

        }

        function stopBgAnimation() {

            if (bgAnimationId) {

                cancelAnimationFrame(bgAnimationId);

                bgAnimationId = null;

            }

        }

        // Start background animation initially

        startBgAnimation();

        // --- NEW: Game Mode State ---

        let gameMode = 'trophy'; // 'trophy', 'party1v1', '2v2', 'emojiDash', 'chaos', 'snowman_challenge'

        let lastRegularGameMode = 'trophy';

        let returnModeAfterSnowman = 'trophy';

        let snowmanChallengeActive = false;

        let lastSeenEventVersion = null;

        let newYearEventActive = false;

        let heroOverrideForEvent = null;
        let newYearPlayerHero = null;
        let newYearAIHero = null;
        let aiEventHero = null;

        function updateNewYearAIHero(value) {
            newYearAIHero = value;
            aiEventHero = value;
        }
        function clearNewYearHeroes() {
            newYearEventActive = false;
            heroOverrideForEvent = null;
            newYearPlayerHero = null;
            updateNewYearAIHero(null);
        }

        function ensureNewYearHeroes() {
            if (!newYearPlayerHero) {
                newYearPlayerHero = getRandomHeroId({ allowLocked: true });
            }
            if (!newYearAIHero) {
                updateNewYearAIHero(getRandomHeroId({ allowLocked: true, exclude: newYearPlayerHero }));
            }
            heroOverrideForEvent = newYearPlayerHero;
        }

            function isMaxLevelMatch(mode = gameMode) {

                return mode === 'party1v1' || mode === '2v2' || mode === 'emojiDash' || mode === 'chaos' || mode === 'new_year_new_me';

            }

        function isRankedMode(mode = gameMode) {

            return mode === 'trophy';

        }

        let is2v2Friend = false;

        let is2v2AITeammate = false;

        let twoVtwoLobbyCode = null;

        let twoVtwoLobbyLocked = false;

        let twoVtwoInFriendMatch = false;

        let twoVtwoPlayAgainRequested = false;

        // --- Start Game ---

        window.onload = () => {

            // --- Domain Lock Security ---

            const isLocalFile = window.location.protocol === 'file:';

            const allowedHosts = [

                'coolrandomwebsite99-lab.github.io',

                'scf.usercontent.goog',

                'emoji-royale.netlify.app',

                'schoolgames899.github.io',

                'emojiroyale.space'

            ];

            const currentHost = window.location.hostname;

            const isLocalhost = currentHost === "localhost" || currentHost === "";

            

            const isAllowed = allowedHosts.some(host => currentHost.endsWith(host)) || isLocalhost;

            if (!isAllowed) {

                console.error("Game running on unauthorized domain:", currentHost);

                

                document.getElementById('loginScreen').style.display = 'none';

                document.getElementById('introScreen').style.display = 'none';

                const gameScreen = document.getElementById('gameScreen');

                if (gameScreen) gameScreen.style.display = 'flex';

                

                const unauthScreen = document.getElementById('unauthorizedScreen');

                if (unauthScreen) {

                    unauthScreen.style.display = 'flex';

                    unauthScreen.querySelector('#errorReasonText').textContent = 'Error: This game is not authorized to run on this domain.';

                    unauthScreen.querySelector('#imagineText').textContent = 'Imagine... what could have been.';

                }

                document.getElementById('cardHand').style.display = 'none';

                document.getElementById('nextCardSlot').parentElement.style.display = 'none';

                document.getElementById('elixirBar').parentElement.parentElement.style.display = 'none';

                const demoTimer = document.getElementById('timerDisplay');
                if (demoTimer) demoTimer.style.display = 'none';

                document.getElementById('menuButton').style.display = 'none';

                isDemoMode = true;

                lastTime = performance.now();

            }

            if (!window.isLocalFile) {

                document.documentElement.setAttribute('data-no-debug', '');

            }

            // --- END: Domain Lock Security ---

            // --- Game Constants ---

            const WIDTH = 400; // Define constants first

            const HEIGHT = 500;

            const RIVER_Y = HEIGHT / 2;

            const BRIDGE_Y = RIVER_Y;

            const PLAYER_SPAWN_LIMIT_Y = RIVER_Y;

            const AI_SPAWN_LIMIT_Y = RIVER_Y;

            const AI_SPAWN_ZONE_LIMIT = HEIGHT * 0.3; // NEW: 30% from top

            const LANE_LEFT_X = WIDTH / 4;

            const LANE_RIGHT_X = (WIDTH / 4) * 3;

            const MAX_ELIXIR = 10;

            const BASE_ELIXIR_REGEN_RATE = 0.008;

            const REGULATION_TIME = 120 * 60;

            const OVERTIME_TIME = 120 * 60;

            const UNIT_SPEED_MULTIPLIER = 0.78; // 22% slower troops for more tactical battles

            // NEW: Drag sensitivity

            const DRAG_SENSITIVITY = 10; // Pixels

            let isDragging = false;

            let dragStartX = 0;

            let dragStartY = 0;

            // --- Enemy AI (2v2: two AIs) ---

            let aiThinkTimer = 0;

            let ai2ThinkTimer = 0;

            let aiElixir = 0;

            let ai2Elixir = 0;

            let aiHand = [];

            let ai2Hand = [];

            let aiDeck = [];

            let ai2Deck = [];

            let aiDiscardPile = [];

            let ai2DiscardPile = [];

            let aiNextCard = null;

            let ai2NextCard = null; // Add NEXT card for second AI

            let aiTowerLevel = 1;

            let ai2TowerLevel = 1;

            let currentAiStatLevel = 1;

            let currentAi2StatLevel = 1;

            let gameTimer = REGULATION_TIME;

            let isOvertime = false;

            let currentElixirRate = BASE_ELIXIR_REGEN_RATE;

            let isTieBreaker = false;

            let tieBreakerTick = 0;

            let overtimeInitialPlayerTowers = 0; // NEW: For sudden death

            let overtimeInitialAiTowers = 0; // NEW: For sudden death

            // NEW: Track destroyed towers for spawn zones

            let playerLeftTowerDestroyed = false;

            let playerRightTowerDestroyed = false;

            let aiLeftTowerDestroyed = false;

            let aiRightTowerDestroyed = false;

            // --- Game State ---

            let gameObjects = [];

            let playerElixir = 7; // Start with 7 elixir instead of 3

            let gameRunning = false;

            const lastPlayedCardByTeam = { player: null, ai: null };

            // --- DOM Elements ---

            const screens = document.querySelectorAll('.screen');

            const navButtons = document.querySelectorAll('.nav-btn');

            const persistentNav = document.getElementById('bottomNav');

            const navHighlight = document.getElementById('navHighlight');

            const SAVE_KEY_VERSION = 'v2';

            const EVENT_NOTIFICATION_VERSION = 'superhero-launch-v1';

            const navEventsBadge = document.getElementById('navEventsBadge');

            function updateEventBadge() {

                if (!navEventsBadge) return;

                const showBadge = lastSeenEventVersion !== EVENT_NOTIFICATION_VERSION;

                navEventsBadge.classList.toggle('hidden', !showBadge);

            }

            function markEventsViewed() {

                if (lastSeenEventVersion === EVENT_NOTIFICATION_VERSION) return;

                lastSeenEventVersion = EVENT_NOTIFICATION_VERSION;

                updateEventBadge();

                if (typeof saveUserData === 'function') saveUserData();

                if (typeof persistBrowserSave === 'function') persistBrowserSave(true);

            }

            updateEventBadge();

            let lastNavIndex = 0;

        let menuReadyForAnnouncements = false;

        const logoutBtn = document.getElementById('logoutBtn');

        function enableMenuAnnouncements() {

            menuReadyForAnnouncements = true;

        }

            if (logoutBtn) {

                // Direct assignment to replace any existing listeners

                logoutBtn.onclick = async (e) => {

                    e.preventDefault();

                    if (confirm('Log out and return to title screen?')) {

                        try {

                            if (auth) await signOut(auth);

                        } catch (e) {

                            console.warn("Sign out error (ignoring):", e);

                        }

                        

                        // Reset local session state

                        initGuestSession();

                        

                        // Force UI updates

                        const intro = document.getElementById('introScreen');

                        if (intro) intro.style.display = 'none';

                        if (persistentNav) persistentNav.style.display = 'none';

                        

                        // Reset all screens scroll position

                        document.querySelectorAll('.screen').forEach(s => s.scrollTop = 0);

                        // Navigate to login

                        showScreen('login');

                    }

                };

            }

            const loginScreen = document.getElementById('loginScreen');

            const googleLoginBtn = document.getElementById('googleLoginBtn');

            const trueGuestLoginBtn = document.getElementById('trueGuestLoginBtn'); // FIXED

            const loginError = document.getElementById('loginError'); 

            const loadingScreen = document.getElementById('loadingScreen');

            const menuScreen = document.getElementById('menuScreen');

            const gameScreen = document.getElementById('gameScreen');

            const deckScreen = document.getElementById('deckScreen');

            const towerScreen = document.getElementById('towerScreen');

            const arenaScreen = document.getElementById('arenaScreen'); // NEW

            const arenaButton = document.getElementById('arenaButton');

            const debugScreen = document.getElementById('debugScreen'); // NEW

            const battleButton = document.getElementById('battleButton');

            function updateBattleButtonState() {

                if (!battleButton) return;

                const deck = getDeckForMode(gameMode) || [];

                const heroAssigned = superheroesUnlocked && Boolean(getHeroSlotForMode());

                const totalDeckCount = Math.min(8, deck.length + (heroAssigned ? 1 : 0));

                const isReady = totalDeckCount === 8 || gameMode === 'emojiDash';

                battleButton.disabled = !isReady;

                battleButton.textContent = isReady ? 'BATTLE!' : `Deck must have 8 cards (${totalDeckCount}/8)`;

                battleButton.classList.toggle('opacity-50', !isReady);

                battleButton.classList.toggle('cursor-not-allowed', !isReady);

            }

            const emojiDashScreen = document.getElementById('emojiDashScreen');

            const emojiDashCanvas = document.getElementById('emojiDashCanvas');

            const emojiDashDeckBar = document.getElementById('emojiDashDeckBar');

            const emojiDashElixirFill = document.getElementById('emojiDashElixirFill');

            const emojiDashElixirText = document.getElementById('emojiDashElixirText');

            const emojiDashLevelLabel = document.getElementById('emojiDashLevelLabel');

            const emojiDashTrophyLabel = document.getElementById('emojiDashTrophyLabel');

            const modeTrophy = document.getElementById('modeTrophy');

            const modeParty1v1 = document.getElementById('modeParty1v1');

            const mode2v2 = document.getElementById('mode2v2');

            const modeEmojiDash = document.getElementById('modeEmojiDash');

            const modeChaos = document.getElementById('modeChaos');

            const modeDescriptionPanel = document.getElementById('modeDescriptionPanel');

            const modeDescriptionTitle = document.getElementById('modeDescriptionTitle');

            const modeDescriptionText = document.getElementById('modeDescriptionText');

            const modeDisplay = document.getElementById('modeDisplay');

            const arenaBackButton = document.getElementById('arenaBackButton'); // NEW

            const trophyDisplay = document.getElementById('trophyDisplay');

            const goldDisplay = document.getElementById('goldDisplay');

            const chestSlots = document.getElementById('chestSlots');

            const arenaName = document.getElementById('arenaName');

            const arenaEmoji = document.getElementById('arenaEmoji');

            const deckCardGrid = document.getElementById('deckCardGrid');

            const collectionCardGrid = document.getElementById('collectionCardGrid');

            const lockedCardGrid = document.getElementById('lockedCardGrid');

            const unlockableSection = document.getElementById('unlockableSection');

            const unlockableCardGrid = document.getElementById('unlockableCardGrid');

            const HERO_SLOT_INDEX = 2; // Reserve the third deck slot for the hero overlay.

            const deckCount = document.getElementById('deckCount');


            const modeDescriptions = {

                trophy: {

                    title: 'Trophy Road',

                    text: 'Craft a balanced eight-card deck, climb the arenas, and adapt your cards as new opponents and unlocks arrive.',

                    accent: '239, 68, 68',

                    auraColor: '248, 113, 113',

                    auraLabel: 'Trophy Glow'

                },

                party1v1: {

                    title: 'Party 1v1',

                    text: 'Lock in your personal deck, sit across a single rival, and execute your favorite builds in a pure one-on-one run.',

                    accent: '244, 114, 182',

                    auraColor: '236, 72, 153',

                    auraLabel: 'Solo Rush'

                },

                '2v2': {

                    title: '2v2 Duo',

                    text: 'Pair up for a shared lane, time your spells around your partner, and control the center together.',

                    accent: '14, 165, 233',

                    auraColor: '59, 130, 246',

                    auraLabel: 'Lane Sync'

                },

                emojiDash: {

                    title: 'Emoji Dash',

                    text: 'Speed through waves, avoid hazards, and keep cards in motion inside the dash-inspired arena.',

                    accent: '16, 185, 129',

                    auraColor: '34, 197, 94',

                    auraLabel: 'Dash Surge'

                },

                chaos: {

                    title: 'Chaos Works',

                    text: 'Craft a full level-15 1v1 deck with every card unlocked, and every troop you or your rival drops summons a random siege-beating unit behind your king tower.',

                    accent: '249, 115, 22',

                    auraColor: '249, 115, 22',

                    auraLabel: 'Chaos Pulse'

                }

            };

            function refreshModeDescription(modeKey) {

                const info = modeDescriptions[modeKey] || modeDescriptions.trophy;

                if (modeDescriptionTitle) modeDescriptionTitle.textContent = info.title;

                if (modeDescriptionText) modeDescriptionText.textContent = info.text;

                if (modeDescriptionPanel) {

                    modeDescriptionPanel.style.setProperty('--mode-panel-accent-rgb', info.accent);

                }

                document.documentElement.style.setProperty('--active-mode-glow', info.accent);

            }

            // Chaos visual overlays removed; nothing to toggle here anymore.

            const teammateChoiceModal = document.getElementById('teammateChoiceModal');

            const aiTeammateBtn = document.getElementById('aiTeammateBtn');

            const friendTeammateBtn = document.getElementById('friendTeammateBtn');

            const cancelTeammateBtn = document.getElementById('cancelTeammateBtn');

            const friendCodeModal = document.getElementById('friendCodeModal');

            const createCodeBtn = document.getElementById('createCodeBtn');

            const joinCodeBtn = document.getElementById('joinCodeBtn');

            const cancelFriendBtn = document.getElementById('cancelFriendBtn');

            const createCodeModal = document.getElementById('createCodeModal');

            const generatedCode = document.getElementById('generatedCode');

            const cancelCreateBtn = document.getElementById('cancelCreateBtn');

            const joinCodeModal = document.getElementById('joinCodeModal');

            const codeInput = document.getElementById('codeInput');

            const confirmJoinBtn = document.getElementById('confirmJoinBtn');

            const cancelJoinBtn = document.getElementById('cancelJoinBtn');

            const aiTeammateUI = document.getElementById('aiTeammateUI');

            const aiTeammateHand = document.getElementById('aiTeammateHand');

            const aiTeammateNext = document.getElementById('aiTeammateNext');

            const aiTeammateElixirBar = document.getElementById('aiTeammateElixirBar');

            const aiTeammateElixirCount = document.getElementById('aiTeammateElixirCount');

            const cardHandEl = document.getElementById('cardHand');

            const nextCardSlotEl = document.getElementById('nextCardSlot');

            const placementIndicator = document.getElementById('placementIndicator');

            const placementOverlay = document.getElementById('placementOverlay'); // NEW

            const menuButton = document.getElementById('menuButton');

            const emojiDashResultOverlay = document.getElementById('emojiDashResultOverlay');

            const emojiDashResultText = document.getElementById('emojiDashResultText');

            const emojiDashResultRewardText = document.getElementById('emojiDashResultRewardText');

            const emojiDashResultMenuButton = document.getElementById('emojiDashResultMenuButton');

            // Attach a click handler to the in-game "Back to Menu" button once. When a match

            // concludes (victory or defeat) the menu button is shown inside the messageOverlay.

            // Without a handler, clicking "Back to Menu" would do nothing. Assigning it via

            // `.onclick` ensures we never accumulate duplicate listeners across games. When

            // clicked, hide the overlay, hide the menu/start buttons, restart the background

            // animation (if it isn't already running) and navigate back to the main menu.

            function returnToMenuFromOverlay() {

                if (messageOverlay) messageOverlay.style.display = 'none';

                if (emojiDashResultOverlay) emojiDashResultOverlay.style.display = 'none';

                if (startButton) startButton.style.display = 'none';

                if (menuButton) menuButton.style.display = 'none';

                if (typeof gameLoopId !== 'undefined') {

                    cancelAnimationFrame(gameLoopId);

                }

                if (typeof emojiDashLoopId !== 'undefined' && emojiDashLoopId) {

                    cancelAnimationFrame(emojiDashLoopId);

                    emojiDashLoopId = 0;

                }

                gameRunning = false;

                if (typeof startBgAnimation === 'function') {

                    startBgAnimation();

                }

                document.querySelectorAll('.screen').forEach(s => s.scrollTop = 0);

                if (typeof showScreen === 'function') {

                    restoreFromSnowmanChallenge();

                    showScreen('menu');

                }

            }

            function restoreFromSnowmanChallenge() {

                if (!snowmanChallengeActive && !newYearEventActive && gameMode !== 'snowman_challenge' && gameMode !== 'new_year_new_me') return;

                const nextMode = returnModeAfterSnowman || lastRegularGameMode || 'trophy';

                gameMode = nextMode;

                lastRegularGameMode = nextMode;

                snowmanChallengeActive = false;

                clearNewYearHeroes();

                returnModeAfterSnowman = 'trophy';

                updateModeUI();

                renderDeckScreen();

                updateBattleButtonState();

                updateHeroSlotDecorations();

            }

            if (menuButton) {

                menuButton.onclick = null;

                menuButton.onclick = returnToMenuFromOverlay;

            }

            if (emojiDashResultMenuButton) {

                emojiDashResultMenuButton.onclick = null;

                emojiDashResultMenuButton.addEventListener('click', returnToMenuFromOverlay);

            }

            const loadingBattleContainers = Array.from(document.querySelectorAll('[data-loading-battle]'));

            const LOADING_CHARGERS_PER_WAVE = 5;

            const LOADING_WAVE_INTERVAL = 620;

            let loadingBattleInterval = null;

            function getLoadingTroopEmojiPool() {

                const pool = new Set();

                Object.values(allCards).forEach(card => {

                    if (!card || typeof card.emoji !== 'string') return;

                    if (!card.emoji.trim()) return;

                    if (card.type === 'Building' || card.type === 'Tower') return;

                    pool.add(card.emoji);

                });

                if (!pool.size) return ['ðŸ¤º','ðŸ¹','ðŸ§™â€â™‚ï¸','ðŸ‰','âš”ï¸','ðŸ›¡ï¸'];

                return [...pool];

            }

            function randomInRange(min, max) {

                return Math.random() * (max - min) + min;

            }

            function spawnLoadingCharger(container) {

                if (!container) return;

                const rect = container.getBoundingClientRect();

                if (!rect.width || !rect.height) return;

                const angle = Math.random() * Math.PI * 2;

            const outerRadius = Math.max(rect.width, rect.height) * 0.85 + 90 + Math.random() * 60;

            const minDimension = Math.min(rect.width, rect.height);

            const maxStopRadius = Math.max(60, minDimension / 2 - 35);

            const safeRadius = Math.min(maxStopRadius - 15, Math.max(90, minDimension * 0.18));

            const stopRange = Math.max(25, maxStopRadius - safeRadius);

            let stopRadius = safeRadius + Math.random() * stopRange;

            let exitX = Math.cos(angle) * stopRadius;

            let exitY = Math.sin(angle) * stopRadius;

            const existing = container.__loadingExitPoints || [];

            let tries = 0;

            while (tries < 10 && existing.some(p => Math.hypot(p.x - exitX, p.y - exitY) < 50)) {

                stopRadius = safeRadius + Math.random() * stopRange;

                exitX = Math.cos(angle) * stopRadius;

                exitY = Math.sin(angle) * stopRadius;

                tries++;

            }

            const startX = Math.cos(angle) * outerRadius;

            const startY = Math.sin(angle) * outerRadius;

                const charger = document.createElement('span');

                charger.className = 'loading-battle-unit loading-battle-charger';

                const emojiPool = getLoadingTroopEmojiPool();

                charger.textContent = emojiPool[Math.floor(Math.random() * emojiPool.length)];

                charger.style.setProperty('--enter-x', `${startX}px`);

                charger.style.setProperty('--enter-y', `${startY}px`);

                charger.style.setProperty('--exit-x', `${exitX}px`);

                charger.style.setProperty('--exit-y', `${exitY}px`);

                charger.style.animationDuration = `${randomInRange(2.4, 3.5)}s`;

                charger.style.animationDelay = `${Math.random() * 0.45}s`;

                charger.style.transform = `translate(${startX}px, ${startY}px)`;

                charger.style.opacity = '0';

                const exitId = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`;

                existing.push({ id: exitId, x: exitX, y: exitY });

                container.__loadingExitPoints = existing;

                container.appendChild(charger);

                charger.addEventListener('animationend', () => {

                    container.__loadingExitPoints = (container.__loadingExitPoints || []).filter(p => p.id !== exitId);

                    charger.remove();

                });

            }

            function spawnLoadingWave() {

                loadingBattleContainers.forEach(container => {

                    for (let i = 0; i < LOADING_CHARGERS_PER_WAVE; i++) {

                        spawnLoadingCharger(container);

                    }

                });

            }

            function startLoadingBattleAnimation() {

                if (loadingBattleInterval) return;

                spawnLoadingWave();

                loadingBattleInterval = setInterval(spawnLoadingWave, LOADING_WAVE_INTERVAL);

            }

            function stopLoadingBattleAnimation() {

                if (loadingBattleInterval) {

                    clearInterval(loadingBattleInterval);

                    loadingBattleInterval = null;

                }

                loadingBattleContainers.forEach(container => {

                    container.querySelectorAll('.loading-battle-charger').forEach(el => el.remove());

                });

            }

            startLoadingBattleAnimation();

            const towerLevelDisplay = document.getElementById('towerLevelDisplay');

            const towerInfoStats = document.getElementById('towerInfoStats');

            const towerInfoProgressContainer = document.getElementById('towerInfoProgressContainer');

            const towerInfoProgressBar = document.getElementById('towerInfoProgressBar');

            const towerInfoProgressText = document.getElementById('towerInfoProgressText');

            const towerUpgradeButton = document.getElementById('towerUpgradeButton');

            const cardInfoModal = document.getElementById('cardInfoModal');

            const cardInfoCloseBtn = document.getElementById('cardInfoCloseBtn');

            const cardInfoDisplay = document.getElementById('cardInfoDisplay');

            const cardInfoName = document.getElementById('cardInfoName');

            const cardInfoType = document.getElementById('cardInfoType');

            const cardInfoLevel = document.getElementById('cardInfoLevel');

            const cardInfoStats = document.getElementById('cardInfoStats');
            const cardAbilityBlock = document.getElementById('cardAbilityBlock');
            const cardAbilityName = document.getElementById('cardAbilityName');
            const cardAbilityDetails = document.getElementById('cardAbilityDetails');
            const cardAbilityTestButton = document.getElementById('cardAbilityTestButton');
            const cardAbilityTestStatus = document.getElementById('cardAbilityTestStatus');

            const cardInfoButtons = document.getElementById('cardInfoButtons'); 
            
            const cardInfoProgressContainer = document.getElementById('cardInfoProgressContainer');

            const cardInfoProgressBar = document.getElementById('cardInfoProgressBar');

            const cardInfoProgressText = document.getElementById('cardInfoProgressText');

            const cardInfoButton = document.getElementById('cardInfoButton');

            const previewRefreshButton = document.getElementById('previewRefreshButton');
            const heroAbilityPanel = document.getElementById('heroAbilityPanel');
            const heroAbilityButton = document.getElementById('heroAbilityButton');
            const heroAbilityName = document.getElementById('heroAbilityName');
            const heroAbilityUses = document.getElementById('heroAbilityUses');

            if (cardInfoDisplay) {

                const abilityObserver = new MutationObserver(() => {

                    const cardEl = cardInfoDisplay.querySelector('.card-ui');

                    const cardId = cardEl && cardEl.dataset ? cardEl.dataset.unit : null;

                    if (cardId) {

                        refreshCardAbilityInfo(cardId);

                    } else {

                        hideCardAbilityInfo();

                    }

                });

                abilityObserver.observe(cardInfoDisplay, { childList: true, subtree: true });

                const initialCard = cardInfoDisplay.querySelector('.card-ui');

                if (initialCard && initialCard.dataset) {

                    refreshCardAbilityInfo(initialCard.dataset.unit);

                } else {

                    hideCardAbilityInfo();

                }

            } else {

                hideCardAbilityInfo();

            }

            if (cardAbilityTestButton) {

                                cardAbilityTestButton.onclick = (event) => {

                                    event.preventDefault();

                                    event.stopPropagation();

                                    if (previewHeroAbilityCardId) {

                                        triggerPreviewHeroAbility(previewHeroAbilityCardId);

                                    }

                                };

            }


            const chestOpenOverlay = document.getElementById('chestOpenOverlay');

            const chestRewardList = document.getElementById('chestRewardList');

            const chestCloseButton = document.getElementById('chestCloseButton');

            // Debug Buttons

            const debugArena2 = document.getElementById('debugArena2');

            const debugArena3 = document.getElementById('debugArena3');

            const debugArena4 = document.getElementById('debugArena4'); // NEW

            const debugArena5 = document.getElementById('debugArena5'); // NEW

            const debugArena6 = document.getElementById('debugArena6');

            const debugArena7 = document.getElementById('debugArena7');

            const debugArena8 = document.getElementById('debugArena8');

            const debugArena9 = document.getElementById('debugArena9');

            const debugArena10 = document.getElementById('debugArena10');

            const debugArena11 = document.getElementById('debugArena11');

            const debugArena12 = document.getElementById('debugArena12');

            const debugArena13 = document.getElementById('debugArena13');

            const debugArena14 = document.getElementById('debugArena14');

            const debugArena15 = document.getElementById('debugArena15');

            const debugArena16 = document.getElementById('debugArena16');

            const debugArena17 = document.getElementById('debugArena17');

            const debugArena18 = document.getElementById('debugArena18');

            const debugArena19 = document.getElementById('debugArena19');

            const debugArena20 = document.getElementById('debugArena20');

            const debugArena21 = document.getElementById('debugArena21');

            const debugUnlockAll = document.getElementById('debugUnlockAll');

            const debugUpgradeAll = document.getElementById('debugUpgradeAll');

            const debugGetChest = document.getElementById('debugGetChest');

            const debugAddGold = document.getElementById('debugAddGold');

            const debugReset = document.getElementById('debugReset');

            const debugEmojiDashLevel1 = document.getElementById('debugEmojiDashLevel1');

            const debugEmojiDashLevel2 = document.getElementById('debugEmojiDashLevel2');

            const debugEmojiDashLevel3 = document.getElementById('debugEmojiDashLevel3');

            // Debug Password

            const debugPasswordOverlay = document.getElementById('debugPasswordOverlay');

            const debugPasswordInput = document.getElementById('debugPasswordInput');

            const debugPasswordSubmit = document.getElementById('debugPasswordSubmit');

            const debugPasswordCancel = document.getElementById('debugPasswordCancel');

            // NEW: Save/Load Data

            const saveDataBtn = document.getElementById('saveDataBtn');

            const saveDataOverlay = document.getElementById('saveDataOverlay');

            const generateKeyBtn = document.getElementById('generateKeyBtn');

            const saveKeyOutput = document.getElementById('saveKeyOutput');

            const saveDataCancel = document.getElementById('saveDataCancel');

            const restoreBrowserSaveLoginBtn = document.getElementById('restoreBrowserSaveLoginBtn');

            const loadKeyBtn = document.getElementById('loadKeyBtn');

            const loadDataOverlay = document.getElementById('loadDataOverlay');

            const loadKeyInput = document.getElementById('loadKeyInput');

            const loadKeySubmit = document.getElementById('loadKeySubmit');

            const loadDataCancel = document.getElementById('loadDataCancel');

            // Update Log

            const updateLogOverlay = document.getElementById('updateLogOverlay');

            const updateLogContent = document.getElementById('updateLogContent');

            const updateLogClose = document.getElementById('updateLogClose');

            const announcementOverlay = document.getElementById('announcementOverlay');

            const announcementOkBtn = document.getElementById('announcementOkBtn');

            const voteOverlay = document.getElementById('voteOverlay');

            const voteYesButton = document.getElementById('voteYesButton');

            const voteNoButton = document.getElementById('voteNoButton');

            const voteStatusText = document.getElementById('voteStatusText');

            const voteResults = document.getElementById('voteResults');

            const voteContinueButton = document.getElementById('voteContinueButton');

            if (announcementOkBtn) {

                announcementOkBtn.addEventListener('click', () => {

                    if (announcementOverlay) announcementOverlay.style.display = 'none';

                    showVoteWorkflow();

                });

            }

            if (voteYesButton) {

                voteYesButton.addEventListener('click', () => recordVote('yes'));

            }

            if (voteNoButton) {

                voteNoButton.addEventListener('click', () => recordVote('no'));

            }

            if (voteContinueButton) {

                voteContinueButton.addEventListener('click', () => {

                    if (!hasVoted) return;

                    if (voteOverlay) voteOverlay.style.display = 'none';

                    displayUpdateLogContent();

                    if (updateLogOverlay) updateLogOverlay.style.display = 'flex';

                    pendingUpdateLogAfterVote = false;

                });

            }

            // Vote & update log helpers

            function showUpdateLog() {

                pendingUpdateLogAfterVote = true;

                if (ANNOUNCEMENTS_ENABLED && announcementOverlay) {

                    announcementOverlay.style.display = 'flex';

                } else {

                    displayUpdateLogContent();

                }

            }

            function loadVoteState() {

                if (typeof localStorage === 'undefined') return;

                try {

                    const storedTotals = localStorage.getItem(VOTE_TOTALS_KEY);

                    if (storedTotals) voteTotals = JSON.parse(storedTotals);

                    hasVoted = localStorage.getItem(VOTE_FLAG_KEY) === 'true';

                    const storedChoice = localStorage.getItem(VOTE_CHOICE_KEY);

                    playerVoteChoice = storedChoice === 'yes' || storedChoice === 'no' ? storedChoice : null;

                } catch (error) {

                    console.warn('Vote state load failed', error);

                }

            }

            function saveVoteState() {

                if (typeof localStorage === 'undefined') return;

                try {

                    localStorage.setItem(VOTE_TOTALS_KEY, JSON.stringify(voteTotals));

                    if (hasVoted) {

                        localStorage.setItem(VOTE_FLAG_KEY, 'true');

                        if (playerVoteChoice) {

                            localStorage.setItem(VOTE_CHOICE_KEY, playerVoteChoice);

                        } else {

                            localStorage.removeItem(VOTE_CHOICE_KEY);

                        }

                    } else {

                        localStorage.removeItem(VOTE_FLAG_KEY);

                        localStorage.removeItem(VOTE_CHOICE_KEY);

                    }

                } catch (error) {

                    console.warn('Vote state save failed', error);

                }

            }

            function updateVoteDisplay() {

                if (voteResults) {

                    voteResults.textContent = `Yes: ${voteTotals.yes} Â· No: ${voteTotals.no}`;

                }

                if (voteStatusText) {

                    if (hasVoted) {

                        const label = playerVoteChoice === 'yes'

                            ? 'Yes'

                            : playerVoteChoice === 'no'

                                ? 'No'

                                : 'your vote';

                        voteStatusText.textContent = `You already voted ${label}.`;

                    } else {

                        voteStatusText.textContent = 'You can only vote once per browser.';

                    }

                }

            }

            function showVoteWorkflow() {

                if (!ANNOUNCEMENTS_ENABLED) return;

                updateVoteDisplay();

                if (voteOverlay) {

                    voteOverlay.style.display = 'flex';

                }

            }

            function scheduleVoteWorkflow() {

                if (!ANNOUNCEMENTS_ENABLED) return;

                if (!allowMenuAnnouncements || hasShownUpdateLog || voteScheduled) return;

                voteScheduled = true;

                if (menuVoteTimer) clearTimeout(menuVoteTimer);

                menuVoteTimer = setTimeout(() => {

                    menuVoteTimer = null;

                    voteScheduled = false;

                    const battleReady = battleButton && battleButton.offsetParent !== null && battleButton.style.display !== 'none';

                    if (!hasShownUpdateLog && currentScreen === 'menu' && battleReady) {

                        hasShownUpdateLog = true;

                        showUpdateLog();

                    } else if (!hasShownUpdateLog) {

                        scheduleVoteWorkflow();

                    }

                }, 1500);

            }

            function armMenuAnnouncements() {

                if (menuAnnouncementsArmed) return;

                menuAnnouncementsArmed = true;

                triggerMenuAnnouncements();

            }

            function triggerMenuAnnouncements() {

                if (!ANNOUNCEMENTS_ENABLED) return;

                if (!menuAnnouncementsArmed || allowMenuAnnouncements) return;

                allowMenuAnnouncements = true;

                scheduleVoteWorkflow();

            }

            function recordVote(choice) {

                if (hasVoted) return;

                if (choice !== 'yes' && choice !== 'no') return;

                voteTotals[choice]++;

                hasVoted = true;

                playerVoteChoice = choice;

                saveVoteState();

                updateVoteDisplay();

                if (voteOverlay) voteOverlay.style.display = 'none';

                pendingUpdateLogAfterVote = true;

            }

            if (voteContinueButton) {

                voteContinueButton.addEventListener('click', () => {

                    if (!hasVoted) return;

                    if (voteOverlay) voteOverlay.style.display = 'none';

                    displayUpdateLogContent();

                    if (updateLogOverlay) {

                        updateLogOverlay.style.display = 'flex';

                    }

                    pendingUpdateLogAfterVote = false;

                });

            }

            function displayUpdateLogContent() {

            const updates = [

                    { date: '12/25/2025', title: 'Quarter Star 2: Snack Pit', items: [

                        'Arena 21: Snack Pit opens at 5000 trophies with a goofy grill-and-sauceboard layout for Quarter Star Jr. II.',

                        'Superheroes arrive! Super Skeleton, Super Goblin, and Super Magician unlock from a new shard system and sit in the yellow hero slot.',

                        'Star Boxes now drop 1-2 Superhero Shards per chest so every chest gets you closer to the heroes; you only need one shard per hero once the slot is open.',

                        'Hero cards live outside your eight-card deck, display a special ability button with emoji + elixir cost, and show their ability text in the stats panel.',

                        'Preview the heroes too: the Test Ability button runs Bone Toss, Teleport Bomb, or Magnetic Rift without spamming the main loop.'

                    ]},

                    { date: '12/23/2025', title: 'Celestial Cascade & Cosmic Troops', items: [

                        'ðŸŒŒ Arena 20: Celestial Cascade stretches auroras over each lane so the preview now renders both bridges while the camera scrolls in real time.',

                        'âš¡ Starline Corsair (Win Condition, 4 elixir) now rides a single sparkling projectile across the bridge before reforming so the camera follows it without extra bolts.',

                        'ðŸ”¶ Prism Vanguard (Troop) charges with a burst of geometric shards, spawning agile tracer drones that keep pressure on whichever lane you choose.',

                        'ðŸŒ€ Nebula Drift (Troop) ejects dual micro-cores that drift toward buildings, splitting into sentinels that chase towers while the mothership stays safe.',

                        'ðŸŒ  Starlight Marauder (Troop) leaps from wall to wall, trading ranged burst damage for precise control and dragging nearby troops toward its beam.',

                        'ðŸ›¡ï¸ Astral Bastion (Troop) anchors near the bridge and radiates defensive pulses, buffing allies while only shifting toward towers when both sides are quiet.'

                    ]},

                    { date: '12/22/2025', title: 'Persistent Playfield', items: [

                        'âœ¨ Auto-save now keeps your decks, trophies, coins, and arena progress fresh every few seconds so you can pick up where you left off.',

                        'ðŸš€ Restore last browser save lives on the login screenâ€”tap it anytime to bounce back into the very last session.',

                        'ðŸ—ï¸ Manual save keys still work, but the browser now offers a quick, up-to-the-moment backup right where you start the game.'

                    ]},

                    { date: '12/19/2025', title: 'Chaos Works Awakening', items: [

                        'â˜ ï¸ Chaos Works new gamemode launches: level 15 decks, random spawns, and the new menu are live.',

                        'â˜ ï¸ Bug fixes.'

                    ]},

                    { date: '12/18/2025', title: 'Stellar Observatory Showcase', items: [

                        'âš¡ Zap Tesla (Arena 18) burrows until a ground troop wanders into its circle, pops up, and zaps the lane while staying spell-immune underground.',

                        'ðŸªµ Big Stick (Arena 17) finally rolls across the bridge slowly enough to see, clears every ground unit it touches, and appears in the preview again.',

                        'âœ¨ Arena 19\'s Stellar Observatory cardsâ€”Resonant Beacon, Prism Lattice, Echo Rift, and Bullet Goblinâ€”give the cosmic tier new utilities beyond tanks and snipers.',

                        'ðŸ› ï¸ Bug fixes: Big Stick placement/preview behave again and the update log visuals now match the new emoji art.'

                    ]},

                    { date: '12/17/2025', title: 'Evolution Volley & Fireball Bounce', items: [

                        'ðŸ² Fire Dragon evolution: the burning rectangle is now exclusive to the evo, doing moderate damage while still splashing at the endpoint and firing a bounce shot for area control every time.',

                        'ðŸ· Pigs evolution: their iron snouts shove enemies back and deal skeleton-lethal damage when they collide, so swarms punished by the push never get a chance to reset.',

                        'ðŸŽ¯ Arrows evolution: fires a second delayed volley at the same location for reduced damage.'

                    ]},

	                    { date: '12/15/2025', title: 'Spectral Goblins & Iron Snouts', items: [

                        'ðŸ‘¹ Goblin Group evolves on a 1-cycle trigger so any fallen gang member becomes a ghost that trails the squad, waits 3 seconds, and then respawns once while a single ghost per group is enforced.',

                        'ðŸ· Pigs evolve on a 2-cycle trigger, earning iron snouts that shove aside enemy troops while charging and deal bonus damage to towers when they land a hit.',

                        'ðŸ‘¨â€ðŸŒ¾ Farmer evolves on a 1-cycle trigger, planting vines that pull an out-of-rectangle enemy into his strike so the rectangle attack hits reliably.'

                    ]},

                    { date: '12/13/2025', title: 'Celestial Citadel & Nebula Nexus', items: [

                        'âœ¨ Arena 17: Celestial Citadel sparkles above the clouds with starlit floors and reflective glass panels.',

                        'ðŸ›¡ï¸ Celestial Guardian (6 elixir) rushes the bridge, drawing fire and radiating boosts that steady nearby allies.',

                        'ðŸŒŒ Arena 18: Nebula Nexus warps space into a starfield with neon storms on each lane.',

                        'ðŸŒ  Nebula Sentinel (5 elixir) fires slowing cosmic bolts that pierce air/ground troops before dissolving into stardust.'

                    ]},

                    { date: '12/11/2025', title: 'Mirror Plateau Launch', items: [

                        'ðŸ’Ž Arena 16: Mirror Plateau opens with a crystal floor so the final arena finally has its own horizon.',

                        'ðŸª„ Clone (Spell) duplicates every friendly troop inside the circle into 1 HP impostors with a distinctive aura so they are easy to spot and cannot be cloned again.',

                        'ðŸªž Mirror (Spell) immediately replays the last non-Mirror card for +1 elixir and +1 level while skipping evolutions so it always mirrors the base form, and it cannot be cast before another card.',

                        'ðŸ§¿ Goblin Hex (Spell) lays a cursed ring that slowly damages trapped enemies, then turns anything that dies inside it into a Goblin even if the kill came from another source.'

                    ]},

                    { date: '12/10/2025', title: 'Buried Kingdom Chronicle', items: [

                        'ðŸª¨ Arena 15: Buried Kingdom (3500 trophies) unveils buried stone floors, a debug jump button on the arenas screen, and lighting that matches every new card.',

                        'ðŸŒ Earth Spirit (3 elixir) spans a 60px circle that freezes every troop once, slows them by 25% (air included), and disappears without a health bar after the effect ends.',

                        'ðŸ‰ Earth Dragon (4 elixir) fires Earth Rocks that slow and damage their first hit target while chasing towers like a focused win condition.',

                        'ðŸª¨ Barricade (5 elixir) drops a non-targetable three-rock wall with a visible timer so troops must path around it without blocking the bridge.',

                        'âš°ï¸ Arena 14: Forsaken Lands (3250 trophies) keeps its glowstone and cursed-tower palette to showcase the undead theme throughout the arena UI.',

                        'ðŸ§Ÿ Necromancer (5 elixir) fires green orbs from close-range like the Mage, marks air and ground units, and turns their deaths into nerfed necromancer zombies.',

                        'ðŸ’€ Death Spirit (1 elixir) jumps onto troops or towers, leaves the zombie curse, and raises a zombie for your side once the cursed unit dies (the necromancer zombie stays nerfed).',

                        'ðŸ§ª Lab (6 elixir) instantly spawns a zombie, drains health, spawns another every 5 seconds, and ejects three zombies when destroyed.',

                        'âš°ï¸ Tombstone (4 elixir) now reliably produces three skeletons every 3 seconds and bursts four more when it finally crumbles.',

                        'ðŸ•¸ï¸ Rotter (7 elixir) marches through troops like a win condition, only targets buildings, and shatters into seven worms that hit non-flying enemies.',

                        'ðŸª¸ Coral (5 elixir) spawns Wave Spirits every 3 seconds; each spirit jumps, pushes enemies back, and deals light damage without touching buildings.',

                        'ðŸŸ Fish (2 elixir) lurks invisible until it attacks, splashes low-health troops, and fades before the opponent can react.',

                        'ðŸ§œâ€â™€ï¸ Fishergirl (6 elixir) now hooks ground troops into her melee range, slows their movement and attacks for 3 seconds, and zips toward towers to drag them across bridges.',

                        'ðŸ  Flying Fish (3 elixir) ignores every troop except air-targeting ground units and dives straight toward buildings with big damage but low health.',

                        'ðŸ¡ Stonefish (6 elixir) hides until triggered, one-shots a single ground troop, and only the owner can see its draining health bar.',

                        'ðŸ’§ Wave Spirit (1 elixir) jumps like a spirit, pushing and damaging enemies before Coral keeps spawning more every 3 seconds.',

                        'ðŸ”® Warlock (5 elixir) gets a slight nerf so he stays balanced while the new arena cards debut.',

                        'â›„ Snowman Challenge now restores your last queue so tornado, Zap Wizard, Zap Giant, Pig Jockey, Horse Rider, and similar cards stay available after the mode ends.',

                        'âš™ï¸ AI opponents now mirror your deck\'s highest level (or +1) so matches scale with you while Arena 13 remains level 1 until you level up cards.',

                        'ðŸŒŠ Arena 13: Aqua Arena (3000 trophies) stays at the bottom of the list as the watery floor that introduced Fish, Fishergirl, Stonefish, Coral, and Wave Spirits.',

                    ]},

                    { date: '12/09/2025', title: 'Emoji Dash Expedition', items: [

                        'Emoji Dash is now listed in the menu as its own platformer run, mirroring the battle button flow and HUD refresh.',

                        'Deck setup insists on eight unlocked cards at level 15 while blocking spells, swarms, buildings, air swarms, and evolutions, and the save key now remembers your Emoji Dash deck.',

                        'Each level ships with unique spike, jump pad, and platform layouts plus level-specific trophy floors (0 / 25 / 50) that cap losses while still rewarding +1 trophy for wins.',

                        'Side-view king towers get health bars, projectiles cannot hurt towers, and the win/lose overlay now shows â€œYou Win!/You Lose!â€ with +50 gold and a chest just like 1v1.',

                        'Controls stay limited to D move, space jump, and attack clicks, and both player and AI change facing so they can traverse platforms and spikes reliably.'

                    ]},

                { date: '12/06/2025', title: 'Mythic Arena Update', items: [

                        'ðŸŽðŸ‰âš¡ Mythic Arena (Arena 12) premieres with a celestial orientation, Mythic trophy goals, and a new visual mood.',

                        'Horse Rider charges after a 3-second pause, smashes with charge damage, and jumps the river whenever the bridge is too far.',

                        'Zap Dragon fires a chaining beam that hits up to ten enemies in sequence and can activate King Towers just like Zap Spirit.',

                        'Pig Jockey leaps over the river and bulldozes straight toward buildings as a win condition that ignores bridges.',

                        'ðŸ§ª Elixir Giant charges Buildings, splitting into smaller shards on death and nudging the opponent\'s elixir bar by 1 / 0.5 / 0.25 instead of showing weird totals.',

                        'AI levels and chest rewards now stretch into Mythic Arena so the new cards appear in decks and star boxes.'

                    ]},

                    { date: '12/05/2025', title: 'Stars & Evolutions Update', items: [

                        'â­ Introduced Quarter Stars: earn a star every 2500 trophies with a flashy animation.',

                        'ðŸ“¦ Added Star Boxes: spend Quarter Stars to open Star Boxes instantly. Future boxes coming soon!',

                        'ðŸ§¬ Evolutions Unlocked: Collect Evolution Shards from Star Boxes and play evolved cards in special deck slots.',

                        'âš”ï¸ Battle & UI: New battle animation on intro/loading screens and dynamic troop icons in the update log.',

                        'ðŸŒ€ Collision Overhaul: Units, towers, and buildings now nudge each other so bridges stay clear and troops can walk around obstacles.',

                        'âœ¨ Chests Sparkle: Enhanced chest opening effects with sparkles.',

                        'ðŸ› ï¸ Balance Fixes: Added dirt trail and tower targeting for Diddy Miner; Diddy Giant now targets towers only.',

                        'ðŸžï¸ New Arena & Cards: Added Diddyâ€™s Prison arena and new Diddy troops.'

                    ]},

                    { date: '11/28/2025', title: 'Tower Power & Arena Update', items: [

                        'ðŸ° New Towers! Waffle Maker ðŸ§‡, Machine Gun ðŸ”«, Rocketeer ðŸš€',

                        'ðŸª¦ Added Arena 9: Titan\'s Peak (2000+ trophies)!',

                        'ðŸ¦´ New Card: Skeleton Yard - Spell that continuously spawns Skeletons.',

                        'ðŸ’€ðŸ’£ New Card: Huge Skeleton - Tank that drops a giant bomb on death.',

                        'ðŸ¥· New Card: Ninja - Fast melee unit with high burst damage.',

                        'â˜„ï¸ New Card: Meteor - Powerful damage spell.',

                        'ðŸ”¥ Added Arena 10: Chaos Realm (2250+ trophies)!',

                        'âš¡ðŸ’ª New Card: Zap Giant - Tank with electric field that zaps nearby enemies.',

                        'ðŸ’¥ New Card: Mega Smasher - Tank that deals spawn damage and jumps on enemies.',

                        'ðŸ²ðŸ”¥ New Card: Flame Dragon - Flying unit that ramps up damage over time.',

                        'ðŸ¯ðŸ”¥ New Card: Flame Tower - Defensive building with a ramping damage beam.',

                        'ðŸ¤– New Card: Bot - A tanky, hard-hitting mechanical walker.'

                    ]},

                    { date: '11/27/2025', title: 'Winter Event', items: [

                        'ðŸŽ„ Winter Wonderland Event is Live!',

                        'â˜ƒï¸ Snowman Challenge: Battle the Snowman King!',

                        'âœ¨ Visual Updates: New glowing text effects in Events tab'

                    ]},

                    { date: '11/25/2025', title: 'Previous Update', items: [

                        'Added 2v2 Mode: Team up with an AI teammate against two AI opponents',

                        'New King Tower Visuals: Combined king tower in 2v2 mode shows two crowns',

                        'AI Improvements: 2v2 AI opponents and teammates now use all available cards',

                        'UI Updates: Added health text display on all towers',

                        'Fixed various bugs with card restrictions and deck initialization'

                    ]},

                    { date: '11/24/2025', title: 'Previous Update', items: [

                        'Added Arena 8: Chaos Canyon (1750+ trophies) with custom card classes',

                        'Added Chaos Elemental card - Melee unit with high damage and speed (ðŸ‘¹)',

                        'Added Shadow Clone card - Ranged unit with moderate damage (ðŸ‘¤)',

                        'Added Void Trap spell - Area damage spell for area control (âš«)',

                        'Added Stone Giant card - Tank unit with high health (ðŸ—¿)',

                        'Added Chaos Orb spell - Damage spell for offense (ðŸŒ€)',

                        'Buffed all Spirits: health increased from 50 to 150 (now takes 3 tower hits to kill)',

                        'Updated AI difficulty scaling per arena: Arena 1 lvl 1, Arena 2 lvl 1-2, Arena 3 lvl 2-3, Arena 4 lvl 2-3, Arena 5 lvl 4-5, Arena 6 lvl 4-5, Arena 7 lvl 5-6, Arena 8 lvl 5-6, Arena 9 lvl 6-7',

                        'Chests now give more money and cards in higher arenas'

                    ]},

                    { date: '11/22/2025', title: 'Previous Update', items: [

                        'Added Arena 7: Mages Graveyard (1500+ trophies)',

                        'Added Mage card - Ranged unit with splash damage, attacks ground and air. Every 5 seconds, spawns 4 Skeletons in a square around her.',

                        'Added Phantom Knight card: Spawns invisible and cannot be seen by enemy troops. Only attacks ground units. When attacking, becomes fully visible and can be targeted by enemy troops. Returns to invisible after 3 seconds of not attacking. Spells still hit invisible Phantom Knights. Spirits cannot see invisible Phantom Knights. Visual effect shows semi-transparent ghost when invisible.',

                        'Added Spirit Lantern card - Spawns a random spirit (Zap, Cold, or Life Spirit) every 6 seconds.',

                        'Added Arena 6: Warlock\'s Workshop (1250+ trophies)',

                        'Added Warlock card - Ranged unit with splash damage, attacks ground and air',

                        'Added Zap Spirit - Jumps on enemies and chains electricity to up to 10 targets',

                        'Added Cold Spirit - Jumps and freezes enemies in area for 3 seconds',

                        'Added Life Spirit - Jumps and creates healing circle for friendly units (3 seconds)',

                        'Added Bomb Spirit - Jumps and explodes damaging enemies in area',

                        'Added Spear Goblins card - Spawns 3 spear goblins (unlocks Arena 2)',

                        'Added Anger spell - Purple pool that gives 2x damage and 1.5x attack speed (5 seconds, persists 3s after leaving)',

                        'Buffed Skeletons and Skeleton Group: damage increased from 2 to 5'

                    ]},

                    { date: 'Previous Updates', title: 'Previous Features', items: [

                        'Arena system with 5 arenas',

                        'Card collection and deck building',

                        'Tower upgrades',

                        'Chest system',

                        'Multiple unit types and spells',

                        'AI opponents',

                        'Save/load system'

                    ]
                }

                ];

            let html = '';

            updates.forEach(update => {

                    html += `<div class=\"mb-4\"><h3 class=\"font-bold text-lg text-yellow-400 mb-2\">${update.title} - ${update.date}</h3><ul class=\"list-disc list-inside space-y-1\">`;

                    update.items.forEach(item => {

                        html += `<li>${item}</li>`;

                    });

                    html += `</ul></div>`;

                });

                updateLogContent.innerHTML = html;

                if (updateLogOverlay) updateLogOverlay.style.display = 'flex';

            }

            if (updateLogClose) updateLogClose.addEventListener('click', () => {

                if (updateLogOverlay) updateLogOverlay.style.display = 'none';

            });

            function showDebugPassword() {

                if (!window.isLocalFile) return;

                debugPasswordInput.value = '';

                debugPasswordOverlay.style.display = 'flex';

                debugPasswordInput.focus();

            }

            if (debugPasswordSubmit) debugPasswordSubmit.addEventListener('click', () => {

                if (!window.isLocalFile) return;

                if (debugPasswordInput && debugPasswordInput.value.toUpperCase() === 'GEOMETRIC') {

                    if (debugPasswordOverlay) debugPasswordOverlay.style.display = 'none';

                    document.documentElement.removeAttribute('data-no-debug');

                    showScreen('debug');

                } else if (debugPasswordInput) {

                    debugPasswordInput.value = '';

                    debugPasswordInput.placeholder = 'Wrong! Try again.';

                }

            });

            if (debugPasswordCancel) debugPasswordCancel.addEventListener('click', () => {

                if (debugPasswordOverlay) debugPasswordOverlay.style.display = 'none';

            });

            loadVoteState();

            updateVoteDisplay();

            // --- Game Elements (from gameScreen) ---

    const canvas = document.getElementById('gameCanvas');
    const previewCanvas = document.getElementById('cardPreviewCanvas');

    let ctx;
    let previewCtx = null;
    let previewListEvoOnly = false;
    let previewListHeroOnly = false;

    if (!canvas) {

        console.error("Critical Error: Game canvas not found. Stopping game initialization.");

        return;

    }

    ctx = canvas.getContext('2d');
    if (previewCanvas) {
        previewCtx = previewCanvas.getContext('2d');
    } else {
        console.warn('Preview canvas missing; preview animations will be unavailable.');
    }

    // Store the main game context for later restoration (used by previews)

    let mainCtx = ctx;

            const elixirBar = document.getElementById('elixirBar');

            const elixirText = document.getElementById('elixirText');

            const messageOverlay = document.getElementById('messageOverlay');

            const messageText = document.getElementById('messageText');

            const messageRewardText = document.getElementById('messageRewardText');

            const startButton = document.getElementById('startButton');

            const timerDisplay = document.getElementById('timerDisplay');

            // ==============================================

            // FIREBASE & USER DATA

            // ==============================================

            

            // This is the function that runs after a login attempt

            async function handleAuth(user) {

                // This 'if' block stops the auto-login on page load

                if (isInitialAuthCheck) {

                    isInitialAuthCheck = false;

                    

                    // --- REFERENCEERROR FIX ---

                    // initCardSystem() call REMOVED from here. It's now called *after* classes are defined.

                    // --- END FIX ---

                    

                    return;

                }

                

                // If the login was real (not auto), and not a guest

                if (user && !user.isAnonymous) {

                    // Prevent this from running twice if it's already loading

                    if (isLoading) return;

                    isLoading = true;

                    userId = user.uid;

                    userDocRef = doc(db, 'artifacts', appId, 'users', userId);

                    isDataSaved = true; // Assume we can save unless timer fires

                    

                    showScreen('loading');

                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';

                    

                    // Clear any old timer

                    clearTimeout(loadTimeout);

                    

                    // --- NEW: The 8-second "failsafe" timer ---

                    loadTimeout = setTimeout(() => {

                        console.warn("Firebase load took too long! (8s)");

                        // If it's still loading, force it to stop and start a new game

                        if (isLoading) {

                            isLoading = false;

                            isDataSaved = false; // Disable saving to prevent overwrite

                            initNewUser(); // Load a blank game locally

                            enableMenuAnnouncements();

                            showScreen('menu'); // Go to menu

                        }

                    }, 8000); // 8 seconds

                    try {

                        await loadUserData();

                    } catch (error) {

                        console.error("Error in loadUserData:", error);

                        initNewUser(); // If loading fails, start a new game

                    } finally {

                        // This code runs *only if* loading finishes *before* the 8-second timer

                    if (isLoading) {

                        clearTimeout(loadTimeout); // Cancel the failsafe timer

                        isLoading = false;

                        enableMenuAnnouncements();

                        showScreen('menu'); // Go to menu normally

                    }

                    }

                } else {

                    // Not logged in or is anonymous

                    userId = null;

                    userDocRef = null;

                    isDataSaved = false;

                    isLoading = false;

                    showScreen('login');

                }

            }

        function normalizeChestSlots() {

                if (!Array.isArray(trophyChests)) trophyChests = [];

                while (trophyChests.length < 4) trophyChests.push(undefined);

                if (trophyChests.length > 4) trophyChests.length = 4;

            }

            function initNewUser() {

                clearNewYearHeroes();

                trophies = 0;

                gold = 500;

                towerLevel = 1;

                towerCardCount = 0;

                selectedTower = 'princess';

                towerCollection = { 'princess': { level: 1, count: 0, unlocked: true } };

                trophyChests = [];

                normalizeChestSlots();

                cardCollection = ensureCardCollectionEntries(initNewUserCards(false));

                playerDeck = initNewUserCards(true);

                playerDeck2v2 = []; 

                playerDeckParty = [];

                playerDeckChaos = [];

                playerDeckEmojiDash = [];

                playerHeroSlot = null;

                playerHeroSlot2v2 = null;

                playerHeroSlotParty = null;

                playerHeroSlotChaos = null;

                playerHeroSlotEmojiDash = null;

                superheroShards = 0;

                emojiDashTrophies = 0;

                emojiDashLevelId = emojiDashLevels[0].id;

                lastClaimDate = "";

                lastSeenEventVersion = null;

                // We don't save here, we let the game save after a win/loss

            }

            // NEW: "Guest (No Save)" logic

            function initGuestSession() {

                initNewUser(); // Load default data

                

                // Disable saving

                userDocRef = null; 

                userId = null;

                isDataSaved = false; // Prevent save attempts

            }

            async function loadUserData(dataToLoad = null) {

                // Load from a manual save key (guest-style)

                if (dataToLoad) {

                    if (!dataToLoad.saveKeyVersion || dataToLoad.saveKeyVersion !== SAVE_KEY_VERSION) {

                        alert('This save key is outdated. Generate a new one from the menu.');

                        return;

                    }

                    trophies = dataToLoad.trophies || 0;

                    gold = dataToLoad.gold || 500;

                    towerLevel = dataToLoad.towerLevel || 1;

                    towerCardCount = dataToLoad.towerCardCount || 0;

                    selectedTower = dataToLoad.selectedTower || 'princess';

                    // Load quarter star and evolution data for manual save keys

                    quarterStars = dataToLoad.quarterStars || 0;

                    lastQuarterMilestone = dataToLoad.lastQuarterMilestone || (quarterStars * 2500);

                    evolutionsUnlocked = dataToLoad.evolutionsUnlocked || false;

                    evolutionShards = dataToLoad.evolutionShards || 0;

                    evoUnlockedCards = dataToLoad.evoUnlockedCards || {};

                    

                    // Handle tower collection migration for manual loads

                    if (dataToLoad.towerCollection) {

                        towerCollection = dataToLoad.towerCollection;

                    } else {

                        // Migrate from old system

                        towerCollection = { 

                            'princess': { 

                                level: dataToLoad.towerLevel || 1, 

                                count: dataToLoad.towerCardCount || 0, 

                                unlocked: true 

                            } 

                        };

                    }

                    

                    // Ensure all tower types have proper structure

                    Object.keys(towerDefs).forEach(towerId => {

                        if (!towerCollection[towerId]) {

                            towerCollection[towerId] = { 

                                level: 1, 

                                count: 0, 

                                unlocked: towerId === 'princess' 

                            };

                        }

                    });

                    

                    trophyChests = dataToLoad.trophyChests || [];

                    normalizeChestSlots();

                    cardCollection = dataToLoad.cardCollection || initNewUserCards(false);

                    playerDeck = dataToLoad.playerDeck || initNewUserCards(true);

                    playerDeck2v2 = dataToLoad.playerDeck2v2 || [];

                    playerDeckParty = dataToLoad.playerDeckParty || [];

                    playerDeckChaos = dataToLoad.playerDeckChaos || [];

                    playerDeckEmojiDash = dataToLoad.playerDeckEmojiDash || [];

                    playerHeroSlot = dataToLoad.playerHeroSlot || null;

                    playerHeroSlot2v2 = dataToLoad.playerHeroSlot2v2 || null;

                    playerHeroSlotParty = dataToLoad.playerHeroSlotParty || null;

                    playerHeroSlotChaos = dataToLoad.playerHeroSlotChaos || null;

                    playerHeroSlotEmojiDash = dataToLoad.playerHeroSlotEmojiDash || null;

                    superheroShards = dataToLoad.superheroShards || 0;

                    superheroesUnlocked = dataToLoad.superheroesUnlocked || false;

                    starBoxesOpened = dataToLoad.starBoxesOpened || 0;
                    reconcileStarBoxUnlocks();

                emojiDashTrophies = dataToLoad.emojiDashTrophies || 0;
                updateEmojiDashLevelFromTrophies();
                lastClaimDate = dataToLoad.lastClaimDate || "";
                lastSeenEventVersion = dataToLoad.lastSeenEventVersion || null;
                updateEventBadge();

                newYearEventActive = !!dataToLoad.newYearEventActive;
                newYearPlayerHero = dataToLoad.newYearPlayerHero || null;
                    updateNewYearAIHero(dataToLoad.newYearAIHero || null);
                heroOverrideForEvent = dataToLoad.heroOverrideForEvent || newYearPlayerHero;
                if (newYearEventActive) {
                    ensureNewYearHeroes();
                } else {
                    clearNewYearHeroes();
                }

                return;

                }

                // Normal Firebase-backed load

                if (!userDocRef) {

                    // No user doc; just start a new user locally

                    initNewUser();

                    return;

                }

                try {

                    const docSnap = await getDoc(userDocRef);

                    if (docSnap.exists()) {

                        const data = docSnap.data();

                        trophies = data.trophies || 0;

                        gold = data.gold || 500;

                        towerLevel = data.towerLevel || 1;

                        towerCardCount = data.towerCardCount || 0;

                        selectedTower = data.selectedTower || 'princess';

                        // Load quarter star and evolution data from Firebase

                        quarterStars = data.quarterStars || 0;

                        lastQuarterMilestone = data.lastQuarterMilestone || (quarterStars * 2500);

                        evolutionsUnlocked = data.evolutionsUnlocked || false;

                        evolutionShards = data.evolutionShards || 0;

                        evoUnlockedCards = data.evoUnlockedCards || {};

                        

                        // Migration logic for tower collection

                        if (data.towerCollection) {

                            towerCollection = data.towerCollection;

                        } else {

                            // Migrate from old system

                            towerCollection = { 

                                'princess': { 

                                    level: data.towerLevel || 1, 

                                    count: data.towerCardCount || 0, 

                                    unlocked: true 

                                } 

                            };

                        }

                        

                        // Ensure all tower types have proper structure

                        Object.keys(towerDefs).forEach(towerId => {

                            if (!towerCollection[towerId]) {

                                towerCollection[towerId] = { 

                                    level: 1, 

                                    count: 0, 

                                    unlocked: towerId === 'princess' 

                                };

                            }

                        });

                        trophyChests = data.trophyChests || [];

                        normalizeChestSlots();

                    cardCollection = ensureCardCollectionEntries(data.cardCollection || initNewUserCards(false));

                        playerDeck = data.playerDeck || initNewUserCards(true);

                        playerDeck2v2 = data.playerDeck2v2 || [];

                        playerDeckParty = data.playerDeckParty || [];

                        playerDeckChaos = data.playerDeckChaos || [];

                        playerDeckEmojiDash = data.playerDeckEmojiDash || [];

                        playerHeroSlot = data.playerHeroSlot || null;

                        playerHeroSlot2v2 = data.playerHeroSlot2v2 || null;

                        playerHeroSlotParty = data.playerHeroSlotParty || null;

                        playerHeroSlotChaos = data.playerHeroSlotChaos || null;

                        playerHeroSlotEmojiDash = data.playerHeroSlotEmojiDash || null;

                        superheroShards = data.superheroShards || 0;

                        superheroesUnlocked = data.superheroesUnlocked || false;

                        starBoxesOpened = data.starBoxesOpened || 0;
                        reconcileStarBoxUnlocks();

                        emojiDashTrophies = data.emojiDashTrophies || 0;

                    updateEmojiDashLevelFromTrophies();

                    lastClaimDate = data.lastClaimDate || "";

                    lastSeenEventVersion = data.lastSeenEventVersion || null;

                    updateEventBadge();

                    } else {

                        // First time user: init defaults

                        initNewUser();

                    }

                } catch (error) {

                    console.error("Error loading user data:", error);

                    // If loading fails, just start a new game locally and disable saving

                    isDataSaved = false;

                    initNewUser();

                }

            }

            function initNewUserCards(deckOnly = false) {

                let newCollection = {};

                

                // Add all cards to collection with count 0 (except Arena 1)

                for (const cardId in allCards) {

                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Don't add tower or internal mini to collection

                    if (allCards[cardId] && allCards[cardId].hidden) continue;

                    newCollection[cardId] = { level: 1, count: 0, unlocked: false }; // ADDED unlocked

                }

                

                // Add Arena 1 cards with count 1

                for (const cardId in allCards) {

                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Don't add tower or internal mini to collection

                    if (allCards[cardId] && allCards[cardId].hidden) continue;

                    if (allCards[cardId].arena === 1) {

                        newCollection[cardId] = { level: 1, count: 1, unlocked: true }; // ADDED unlocked

                    }

                }

                

                if (deckOnly) {

                    // FIX: Filter out 'tower' from starting deck

                    return Object.keys(allCards).filter(id => allCards[id] && !allCards[id].hidden && allCards[id].arena === 1 && id !== 'tower' && id !== 'stoneGiant' && id !== 'miniStoneGiant');

                }

                return newCollection;

            }

            function ensureCardCollectionEntries(collection) {

                if (!collection || typeof collection !== 'object') collection = {};

                for (const cardId in allCards) {

                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; 

                    if (allCards[cardId] && allCards[cardId].hidden) continue;

                    const arenaRequirement = allCards[cardId].arena || 1;

                    const existing = collection[cardId];

                    if (!existing) {

                        collection[cardId] = { level: 1, count: 0, unlocked: arenaRequirement === 1 };

                        continue;

                    }

                    if (existing.level === undefined) existing.level = 1;

                    if (existing.count === undefined) existing.count = 0;

                    if (existing.unlocked === undefined) existing.unlocked = arenaRequirement === 1;

                }

                return collection;

            }

            async function saveUserData() {

                if (!isDataSaved) return; // This will be false for guests

                // Use Firebase if logged in

                if (userDocRef) {

                    isDataSaved = false; // Prevent multiple saves

                    try {

                    const dataToSave = {

                        trophies,

                        gold,

                        towerLevel,

                        towerCardCount,

                        selectedTower,

                        towerCollection,

                        trophyChests,

                        cardCollection,

                        playerDeck,

                        playerDeck2v2,

                        playerDeckParty,

                        playerDeckChaos,

                        playerDeckEmojiDash,

                        playerHeroSlot,

                        playerHeroSlot2v2,

                        playerHeroSlotParty,

                        playerHeroSlotChaos,

                        playerHeroSlotEmojiDash,

                        emojiDashTrophies,

                        lastClaimDate,

                        // Persist quarter star and evolution data so progress is saved

                        quarterStars,

                        lastQuarterMilestone,

                        evolutionsUnlocked,

                        evolutionShards,

                        superheroShards,

                        superheroesUnlocked,

                        starBoxesOpened,

                        evoUnlockedCards,

                        lastSeenEventVersion,

                        saveKeyVersion: SAVE_KEY_VERSION,

                        lastSaved: new Date().toISOString()

                    };

                        await setDoc(userDocRef, dataToSave, { merge: true });

                    } catch (error) {

                        console.error("Error saving user data:", error);

                    }

                    isDataSaved = true; // Allow saving again

                }

                // If not logged in (e.g., guest mode), we simply don't save.

            }

            

            if (googleLoginBtn) googleLoginBtn.addEventListener('click', async () => {

                loginError.textContent = '';

                try {

                    // This will trigger the onAuthStateChanged listener

                    await signInWithPopup(auth, provider);

                } catch (error) {

                    isLoading = false; // Make sure loading stops on fail

                    if (error.code === 'auth/unauthorized-domain') {

                        loginError.textContent = 'Google Sign-in is not set up.';

                    } else if (error.code === 'auth/popup-blocked') {

                        loginError.textContent = 'Pop-up blocked! Please allow pop-ups.';

                    } else {

                        loginError.textContent = 'Could not sign in. Please try again.';

                    } 

                }

            });

            

            // "Play as Guest (No Save)" button

            if (trueGuestLoginBtn) trueGuestLoginBtn.addEventListener('click', () => {

                loginError.textContent = ''; // Clear errors

                initGuestSession(); // Load default data, disable saving

                allowBrowserSaveOverwrite();

                persistBrowserSave(true);

                showScreen('loading');

                loadingScreen.querySelector('p').textContent = 'Starting Guest Game...';

                enableMenuAnnouncements();

                setTimeout(() => {

                    showScreen('menu');

                }, 1000); // Short delay

            });

            // --- NEW: Save/Load Key Logic ---

            function buildSavePayload() {

                return {

                    trophies,

                    gold,

                    towerLevel,

                    towerCardCount,

                    selectedTower,

                    towerCollection,

                    trophyChests,

                    cardCollection,

                    playerDeck,

                    playerDeck2v2,

                    playerDeckParty,

                    playerDeckChaos,

                    playerDeckEmojiDash,

                    playerHeroSlot,

                    playerHeroSlot2v2,

                    playerHeroSlotParty,

                    playerHeroSlotChaos,

                    playerHeroSlotEmojiDash,

                    emojiDashTrophies,

                    lastClaimDate,

                // Include quarter star and evolution data in manual save keys

                quarterStars,

                lastQuarterMilestone,

                evolutionsUnlocked,

                evolutionShards,

                superheroShards,

                superheroesUnlocked,

                starBoxesOpened,

                evoUnlockedCards,

                lastSeenEventVersion,

                newYearEventActive,

                newYearPlayerHero,

                newYearAIHero,

                heroOverrideForEvent,

                saveKeyVersion: SAVE_KEY_VERSION

            };

            }

            if (saveDataBtn) saveDataBtn.addEventListener('click', () => {

                if (saveKeyOutput) saveKeyOutput.value = "Generating key...";

                if (generateKeyBtn) generateKeyBtn.disabled = true;

                if (generateKeyBtn) generateKeyBtn.textContent = 'Generate New Key (30s)';

                if (saveDataOverlay) saveDataOverlay.style.display = 'flex';

                // Generate key

                const dataToSave = buildSavePayload();

                const manager = getSaveKeyManager();

                if (!manager) {

                    console.error('Save key manager unavailable');

                    if (saveKeyOutput) saveKeyOutput.value = 'Save key unavailable';

                    if (generateKeyBtn) {

                        generateKeyBtn.disabled = false;

                        generateKeyBtn.textContent = 'Generate New Key';

                    }

                    return;

                }

                const saveKey = manager.encode(dataToSave);

                saveKeyOutput.value = saveKey;

                // Start cooldown

                let cooldown = 30;

                generateKeyBtn.textContent = `Generate New Key (${cooldown}s)`;

                clearTimeout(generateKeyTimeout);

                generateKeyTimeout = setInterval(() => {

                    cooldown--;

                    generateKeyBtn.textContent = `Generate New Key (${cooldown}s)`;

                    if (cooldown <= 0) {

                        clearInterval(generateKeyTimeout);

                        generateKeyBtn.textContent = 'Generate New Key';

                        generateKeyBtn.disabled = false;

                    }

                }, 1000);

            });

            const BROWSER_SAVE_STORAGE_KEY = 'emojiRoyaleBrowserSaveData';

            const BROWSER_SAVE_INTERVAL_MS = 3000;

            let browserAutoSaveIntervalId = null;

            let lastBrowserSaveSnapshot = '';

            let browserSaveNeedsPreserve = false;

            function getBrowserSaveWrapper() {

                if (typeof localStorage === 'undefined') return null;

                try {

                    const stored = localStorage.getItem(BROWSER_SAVE_STORAGE_KEY);

                    if (!stored) return null;

                    return JSON.parse(stored);

                } catch (error) {

                    console.warn('Failed to load browser save data', error);

                    return null;

                }

            }

            function updateBrowserRestoreButtonState() {

                if (!restoreBrowserSaveLoginBtn) return;

                const wrapper = getBrowserSaveWrapper();

                const hasBrowserSave = !!(wrapper && wrapper.payload);

                const titleText = hasBrowserSave && wrapper && wrapper.savedAt

                    ? `Last browser save: ${new Date(wrapper.savedAt).toLocaleString()}`

                    : 'Auto-saving is initializing.';

                restoreBrowserSaveLoginBtn.disabled = !hasBrowserSave;

                restoreBrowserSaveLoginBtn.classList.toggle('restore-ready', hasBrowserSave);

                restoreBrowserSaveLoginBtn.title = titleText;

            }

            function persistBrowserSave(force = false) {

                if (typeof localStorage === 'undefined') return;

                if (browserSaveNeedsPreserve && !force) return;

                try {

                    const payload = buildSavePayload();

                    const snapshot = JSON.stringify(payload);

                    if (!force && snapshot === lastBrowserSaveSnapshot) return;

                    const wrapper = {

                        payload,

                        savedAt: Date.now()

                    };

                    localStorage.setItem(BROWSER_SAVE_STORAGE_KEY, JSON.stringify(wrapper));

                    lastBrowserSaveSnapshot = snapshot;

                    browserSaveNeedsPreserve = false;

                    updateBrowserRestoreButtonState();

                } catch (error) {

                    console.warn('Browser auto-save failed', error);

                }

            }

            function allowBrowserSaveOverwrite() {

                browserSaveNeedsPreserve = false;

            }

            function startBrowserAutoSave() {

                if (browserAutoSaveIntervalId) return;

                browserSaveNeedsPreserve = !!getBrowserSaveWrapper();

                persistBrowserSave();

                browserAutoSaveIntervalId = setInterval(() => persistBrowserSave(), BROWSER_SAVE_INTERVAL_MS);

            }

            async function restoreBrowserSave() {

                const wrapper = getBrowserSaveWrapper();

                if (!wrapper || !wrapper.payload) return;

                initGuestSession();

                try {

                    await loadUserData(wrapper.payload);

                    finishGuestLoadFlow();

                } catch (error) {

                    console.error("Failed to restore browser save:", error);

                    alert('Unable to restore the auto-save. Please try again or load a manual save key.');

                }

            }

            if (saveDataCancel) saveDataCancel.addEventListener('click', () => {

                if (saveDataOverlay) saveDataOverlay.style.display = 'none';

                clearInterval(generateKeyTimeout);

                if (generateKeyBtn) generateKeyBtn.disabled = false;

                if (generateKeyBtn) generateKeyBtn.textContent = 'Generate New Key';

            });

            if (generateKeyBtn) generateKeyBtn.addEventListener('click', () => {

                // Re-generate key and start cooldown

                if (saveDataBtn) saveDataBtn.click(); // Just re-click the main button

            });

            if (restoreBrowserSaveLoginBtn) restoreBrowserSaveLoginBtn.addEventListener('click', async () => {

                await restoreBrowserSave();

            });

            if (loadKeyBtn) loadKeyBtn.addEventListener('click', () => {

                if (loadKeyInput) {

                    loadKeyInput.value = '';

                    loadKeyInput.placeholder = 'Paste your key here';

                }

                if (loadDataOverlay) loadDataOverlay.style.display = 'flex';

            });

            loadDataCancel.addEventListener('click', () => {

                loadDataOverlay.style.display = 'none';

            });

            function finishGuestLoadFlow() {

                if (loadDataOverlay) loadDataOverlay.style.display = 'none';

                if (typeof showScreen === 'function') showScreen('loading');

                if (loadingScreen) {

                    const loadingText = loadingScreen.querySelector('p');

                    if (loadingText) loadingText.textContent = 'Loading Progress...';

                }

                enableMenuAnnouncements();

                setTimeout(() => showScreen('menu'), 1000);

                if (typeof persistBrowserSave === 'function') {

                    persistBrowserSave(true);

                }

            }

            // --- Mode Selector Logic ---

            function updateArenaButtonVisibility() {

                if (!arenaButton) return;

                const showArenaButton = gameMode === 'trophy' && currentScreen === 'menu';

                arenaButton.style.display = showArenaButton ? 'block' : 'none';

            }

            function updateModeUI() {

                const modeInfo = modeDescriptions[gameMode] || modeDescriptions.trophy;

                const modeButtons = [modeTrophy, modeParty1v1, mode2v2, modeEmojiDash, modeChaos];

                modeButtons.forEach(btn => {

                    if (!btn) return;

                    btn.classList.remove('bg-red-600', 'text-white');

                    btn.classList.add('bg-gray-700', 'text-gray-400');

                    btn.classList.remove('active');

                    btn.style.removeProperty('background');

                    btn.style.removeProperty('box-shadow');

                    btn.style.removeProperty('color');

                    btn.style.removeProperty('border');

                });

                let activeBtn = null;

                if (gameMode === 'trophy') activeBtn = modeTrophy;

                else if (gameMode === 'party1v1') activeBtn = modeParty1v1;

                else if (gameMode === '2v2') activeBtn = mode2v2;

                else if (gameMode === 'emojiDash') activeBtn = modeEmojiDash;

                else if (gameMode === 'chaos') activeBtn = modeChaos;

                if (activeBtn) {

                    activeBtn.classList.remove('bg-gray-700', 'text-gray-400');

                    activeBtn.classList.add('active');

                    const accentRGB = (modeInfo && modeInfo.accent) ? modeInfo.accent : '239, 68, 68';

                    activeBtn.style.background = `linear-gradient(180deg, rgba(${accentRGB}, 0.95), rgba(${accentRGB}, 0.65))`;

                    activeBtn.style.boxShadow = `0 12px 30px rgba(${accentRGB}, 0.45), 0 0 30px rgba(${accentRGB}, 0.35)`;

                    activeBtn.style.color = '#ffffff';

                    activeBtn.style.border = `1px solid rgba(${accentRGB}, 0.5)`;

                }

                if (modeDisplay) modeDisplay.textContent = modeInfo ? modeInfo.title : 'Trophy Road';

                refreshModeDescription(gameMode);

                updateAITeammateUI(); // NEW: Update AI Teammate UI visibility when mode changes

                updateArenaButtonVisibility();

            }

            if (modeTrophy) modeTrophy.addEventListener('click', () => {

                gameMode = 'trophy';

                lastRegularGameMode = gameMode;

                snowmanChallengeActive = false;

                updateModeUI();

                renderDeckScreen();

                updateBattleButtonState();

            });

            if (modeParty1v1) modeParty1v1.addEventListener('click', () => {

                gameMode = 'party1v1';

                lastRegularGameMode = gameMode;

                snowmanChallengeActive = false;

                updateModeUI();

                renderDeckScreen();

                updateBattleButtonState();

            });

            if (mode2v2) mode2v2.addEventListener('click', () => {

                gameMode = '2v2';

                lastRegularGameMode = gameMode;

                snowmanChallengeActive = false;

                updateModeUI();

                renderDeckScreen();

                updateBattleButtonState();

            });

            if (modeEmojiDash) modeEmojiDash.addEventListener('click', () => {

                gameMode = 'emojiDash';

                lastRegularGameMode = gameMode;

                snowmanChallengeActive = false;

                updateModeUI();

                renderDeckScreen();

                updateBattleButtonState();

            });

            if (modeChaos) modeChaos.addEventListener('click', () => {

                gameMode = 'chaos';

                lastRegularGameMode = gameMode;

                snowmanChallengeActive = false;

                updateModeUI();

                renderDeckScreen();

                updateBattleButtonState();

            });

            // Initialize mode UI

            updateModeUI();

            // --- 2v2 Teammate Choice Modal ---

            function show2v2TeammateChoice() {

                // Always play with AI Teammate as 'friend' button is removed

                aiTeammateBtn.click();

            }

            function hide2v2TeammateChoice() {

                teammateChoiceModal.style.display = 'none';

            }

            if (aiTeammateBtn) aiTeammateBtn.addEventListener('click', () => {

                hide2v2TeammateChoice();

                is2v2AITeammate = true;

                is2v2Friend = false;

                // TODO: replace with 2v2 initGame2v2 later

                menuScreen.classList.remove('active');

                loadingScreen.classList.add('active');

                loadingScreen.querySelector('p').textContent = 'Finding 2v2 Match...';

                setTimeout(() => {

                    showScreen('game');

                    messageText.textContent = 'Get Ready!';

                    startButton.style.display = 'none';

                    menuButton.style.display = 'none';

                    messageOverlay.style.display = 'flex';

                    setTimeout(() => {

                        initGame(); // TEMP: use normal init until 2v2 logic is added

                        lastTime = performance.now();

                        gameLoopId = requestAnimationFrame(gameLoop);

                    }, 1500);

                }, 1000);

            });

            if (cancelTeammateBtn) cancelTeammateBtn.addEventListener('click', () => {

                hide2v2TeammateChoice();

            });

            function hideFriendCodeModal() {

                friendCodeModal.style.display = 'none';

            }

            function showCreateCodeModal() {

                alert("Multiplayer features are currently disabled.");

            }

            function hideCreateCodeModal() {

                createCodeModal.style.display = 'none';

            }

            function showJoinCodeModal() {

                joinCodeModal.style.display = 'flex';

                codeInput.value = '';

            }

            function hideJoinCodeModal() {

                joinCodeModal.style.display = 'none';

            }

            function startFriend2v2Match() {

                // This function is now handled by the multiplayer script at the bottom

            }

            // friendTeammateBtn event listener handled above

            if (cancelFriendBtn) cancelFriendBtn.addEventListener('click', () => {

                hideFriendCodeModal();

            });

            if (createCodeBtn) createCodeBtn.addEventListener('click', () => {

                hideFriendCodeModal();

                showCreateCodeModal();

            });

            // cancelCreateBtn is now handled in the multiplayer script

            if (joinCodeBtn) joinCodeBtn.addEventListener('click', () => {

                hideFriendCodeModal();

                showJoinCodeModal();

            });

            

                        // cancelJoinBtn is now handled in the multiplayer script

            if (loadKeySubmit) loadKeySubmit.addEventListener('click', async () => {

                const saveKey = (loadKeyInput.value || '').replace(/\s+/g, '');

                if (!saveKey) return;

                try {

                    // We're loading a key, so treat as a "Guest" session (no Firebase save)

                    initGuestSession(); 

                    // Now, load the data from the key

                    const parsedData = decodeSaveKeyString(saveKey);

                    if (!parsedData) throw new Error('Unable to decode save key');

                    await loadUserData(parsedData); 

                    finishGuestLoadFlow();

                } catch (error) {

                    console.error("Failed to load save key:", error);

                    loadKeyInput.value = '';

                    loadKeyInput.placeholder = 'Key expired. Generate a new save key.';

                }

            });

            // ==============================================

            // SCREEN & NAVIGATION LOGIC

            // ==============================================

            const navOrder = ['menu', 'deck', 'tower', 'events', 'debug'];

            function showScreen(targetScreenId) {

                const prevScreenIndex = navOrder.indexOf(currentScreen);

                const nextScreenIndex = navOrder.indexOf(targetScreenId);

                const isNavTransition = prevScreenIndex !== -1 && nextScreenIndex !== -1;

                currentScreen = targetScreenId;

                if (['intro', 'loading'].includes(targetScreenId)) {

                    startLoadingBattleAnimation();

                } else {

                    stopLoadingBattleAnimation();

                }

                screens.forEach(s => {

                    s.classList.remove('active', 'swipe-left', 'swipe-right', 'fade-in');

                    if (s.id === targetScreenId + 'Screen') {

                        s.classList.add('active');

                        if (isNavTransition) {

                            if (nextScreenIndex > prevScreenIndex) s.classList.add('swipe-right');

                            else s.classList.add('swipe-left');

                        } else {

                            s.classList.add('fade-in');

                        }

                    }

                });

                if (['menu', 'deck', 'tower', 'events', 'debug'].includes(targetScreenId)) {

                    persistentNav?.classList.remove('bottom-nav-hidden');

                    persistentNav?.classList.add('bottom-nav-visible');

                    navButtons.forEach((btn, index) => {

                        btn.classList.remove('text-yellow-400');

                        btn.classList.add('text-gray-400');

                        if (btn.dataset.screen === targetScreenId) {

                            btn.classList.add('text-yellow-400');

                            btn.classList.remove('text-gray-400');

                            const direction = index >= lastNavIndex ? 'right' : 'left';

                            lastNavIndex = index;

                            if (navHighlight) {

                                navHighlight.dataset.direction = direction;

                                navHighlight.classList.remove('nav-highlight-animate');

                                navHighlight.style.left = `${index * 20}%`;

                                if (typeof requestAnimationFrame === 'function') {

                                    requestAnimationFrame(() => navHighlight.classList.add('nav-highlight-animate'));

                                } else {

                                    navHighlight.classList.add('nav-highlight-animate');

                                }

                            }

                        }

                    });

                } else {

                    persistentNav?.classList.add('bottom-nav-hidden');

                    persistentNav?.classList.remove('bottom-nav-visible');

                }

                updateArenaButtonVisibility();

                if (targetScreenId === 'deck') { renderDeckScreen(); }

                if (targetScreenId === 'tower') { renderTowerScreen(); }

                if (targetScreenId === 'events') { markEventsViewed(); }

                if (targetScreenId === 'menu') {

                    restoreFromSnowmanChallenge();

                    updateArena();

                    trophyDisplay.textContent = `ðŸ† ${trophies}`;

                    goldDisplay.textContent = `ðŸ’° ${gold}`;

                    renderChests();

                    updateBattleButtonState();

                    if (menuReadyForAnnouncements && !hasShownUpdateLog) {

                        hasShownUpdateLog = true;

                        menuReadyForAnnouncements = false;

                        setTimeout(() => showUpdateLog(), 300);

                    }

                }

            }

            function updateArena() {

                // Reset theme first

                canvas.className = '';

                

                let currentTrophyFloor = 0;

                let arenaDisplayName = "Arena 1: Emoji Valley";

                let emoji = "ðŸžï¸";

                currentArenaTheme = 'arena-1';

                

                for (const floor in arenaFloors) { if (trophies >= parseInt(floor)) { currentTrophyFloor = parseInt(floor); arenaDisplayName = arenaFloors[floor]; } }

                currentArenaFloor = currentTrophyFloor;

                

                if (arenaDisplayName.includes("Laughing Village")) {

                    emoji = "ðŸ˜ï¸";

                    currentArenaTheme = 'arena-2';

                } else if (arenaDisplayName.includes("Lava Town")) {

                    emoji = "ðŸŒ‹";

                    currentArenaTheme = 'arena-3';

                } else if (arenaDisplayName.includes("Mages Graveyard")) {

                    emoji = "ðŸª¦";

                    currentArenaTheme = 'arena-7';

                } else if (arenaDisplayName.includes("The Farm")) { // NEW

                    emoji = "ðŸšœ"; // NEW

                    currentArenaTheme = 'arena-4'; // NEW

                } else if (arenaDisplayName.includes("Skull Kingdom")) { // NEW

                    emoji = "ðŸ’€"; // NEW

                    currentArenaTheme = 'arena-5'; // NEW

                } else if (arenaDisplayName.includes("Warlock's Workshop")) { // NEW

                    emoji = "ðŸ”®"; // NEW

                    currentArenaTheme = 'arena-6'; // NEW

                } else if (arenaDisplayName.includes("Chaos Canyon")) { // NEW

                    emoji = "âš¡"; // NEW

                    currentArenaTheme = 'arena-8'; // NEW

                } else if (arenaDisplayName.includes("Titan's Peak")) {

                    emoji = "ðŸ’€";

                    currentArenaTheme = 'arena-9';

                } else if (arenaDisplayName.includes("Chaos Realm")) {

                    emoji = "ðŸ”¥";

                    currentArenaTheme = 'arena-10';

                } else if (arenaDisplayName.includes("Mythic Arena")) {

                    emoji = "ðŸ‰";

                    currentArenaTheme = 'arena-12';

                } else if (arenaDisplayName.includes("Forsaken Lands")) {

                    emoji = "ðŸŒ‘";

                    currentArenaTheme = 'arena-14';

                } else if (arenaDisplayName.includes("Buried Kingdom")) {

                    emoji = "ðŸ—¿";

                    currentArenaTheme = 'arena-15';

                } else if (arenaDisplayName.includes("Mirror Plateau")) {

                    emoji = "ðŸªž";

                    currentArenaTheme = 'arena-16';

                } else if (arenaDisplayName.includes("Celestial Citadel")) {

                    emoji = "ðŸŒŸ";

                    currentArenaTheme = 'arena-17';

                } else if (arenaDisplayName.includes("Nebula Nexus")) {

                    emoji = "ðŸŒŒ";

                    currentArenaTheme = 'arena-18';

                } else if (arenaDisplayName.includes("Stellar Observatory")) {

                    emoji = "\u2728";

                    currentArenaTheme = 'arena-19';

                } else if (arenaDisplayName.includes("Celestial Cascade")) {

                    emoji = "ðŸŒ ";

                    currentArenaTheme = 'arena-20';

                } else if (arenaDisplayName.includes("Snack Pit")) {

                    emoji = "ðŸ”";

                    currentArenaTheme = 'arena-21';

                } else if (arenaDisplayName.includes("Aqua Arena")) {

                    emoji = "ðŸŒŠ";

                    currentArenaTheme = 'arena-13';

                } else if (arenaDisplayName.includes("Diddy's Prison")) {

                    // Diddy's Prison uses the new arena-11 theme

                    emoji = 'ðŸ’';

                    currentArenaTheme = 'arena-11';

                }

                arenaName.textContent = arenaDisplayName;

                arenaEmoji.textContent = emoji;

                

                if (gameMode === 'snowman_challenge') {

                    canvas.className = 'christmas';

                } else {

                    canvas.className = currentArenaTheme;

                }

                // After determining the current arena, check if the player has earned a new quarter star

                if (typeof checkQuarterStar === 'function') {

                    checkQuarterStar();

                }

                // Update star status displays whenever the arena updates

                if (typeof updateStarBoxesUI === 'function') {

                    updateStarBoxesUI();

                }

            }

            function buildEmojiDashSpikes() {

                const spikes = [];

                for (let x = 180; x < emojiDashConfig.canvasWidth - 160; x += 150) {

                    spikes.push({ x, width: 40, height: 30 });

                }

                return spikes;

            }

            function resetEmojiDashState() {

                const groundLine = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight;

                const leftTowerHeight = 140;

                const rightTowerHeight = 110;

                const levelInfo = getEmojiDashLevelById(emojiDashLevelId);

                emojiDashState = {

                    levelId: levelInfo.id,

                    levelName: levelInfo.name,

                    levelLabel: levelInfo.label,

                    player: null,

                    ai: null,

                    projectiles: [],

                    spikes: buildEmojiDashSpikes(levelInfo.id),

                    jumpPads: buildEmojiDashJumpPads(levelInfo.id),

                    platforms: buildEmojiDashPlatforms(levelInfo.id),

                    elixir: emojiDashConfig.maxElixir,

                    aiSpawnTimer: 1.5,

                    status: 'Select a card to dash!',

                    deckButtons: [],

                    finished: false,

                    finishTimeout: null,

                    aiCardId: null

                };

                emojiDashState.leftTower = {

                    x: 10,

                    width: 48,

                    height: leftTowerHeight,

                    base: groundLine,

                    y: groundLine - leftTowerHeight,

                    health: emojiDashConfig.kingTowerHealth,

                    maxHealth: emojiDashConfig.kingTowerHealth,

                    healthBarBounce: 0

                };

                emojiDashState.rightTower = {

                    x: emojiDashConfig.canvasWidth - 58,

                    width: 48,

                    height: rightTowerHeight,

                    base: groundLine,

                    y: groundLine - rightTowerHeight,

                    health: emojiDashConfig.kingTowerHealth,

                    maxHealth: emojiDashConfig.kingTowerHealth,

                    healthBarBounce: 0

                };

            }

            function getEmojiDashCardStats(cardId) {

                const card = allCards[cardId];

                if (!card) return { damage: emojiDashConfig.playerDamage, health: 140 };

                const level = 15;

                let statsRecord = card.stats;

                if (Array.isArray(statsRecord)) {

                    statsRecord = statsRecord[level - 1] || statsRecord[statsRecord.length - 1] || statsRecord[0];

                } else if (statsRecord && typeof statsRecord === 'object') {

                    statsRecord = statsRecord[String(level)] || statsRecord[String(level - 1)] || Object.values(statsRecord)[level - 1];

                }

                statsRecord = statsRecord || {};

                return {

                    damage: statsRecord.damage || emojiDashConfig.playerDamage,

                    health: statsRecord.health || 140

                };

            }

            function renderEmojiDashDeckBar() {

                if (!emojiDashDeckBar || !emojiDashState) return;

                emojiDashDeckBar.innerHTML = '';

                const deck = getDeckForMode('emojiDash') || [];

                emojiDashState.deckButtons = [];

                if (deck.length !== 8) {

                    return;

                }

                deck.forEach(cardId => {

                    const card = allCards[cardId];

                    if (!card) return;

                    const cost = card.cost || emojiDashConfig.spawnCost;

                    const btn = document.createElement('button');

                    btn.type = 'button';

                    btn.className = 'emoji-dash-deck-card';

                    btn.dataset.cardId = cardId;

                    btn.dataset.cost = cost;

                    btn.setAttribute('aria-label', `${card.name} â€¢ ${cost} Elixir`);

                    btn.innerHTML = `<span class="text-3xl -mb-0.5">${card.emoji}</span><span class="text-[10px] text-yellow-300">${cost}</span>`;

                    btn.addEventListener('click', () => spawnPlayerTroop(cardId));

                    emojiDashDeckBar.appendChild(btn);

                    emojiDashState.deckButtons.push(btn);

                });

                updateEmojiDashDeckBar();

            }

            function updateEmojiDashDeckBar() {

                if (!emojiDashDeckBar || !emojiDashState || !emojiDashState.deckButtons) return;

                emojiDashState.deckButtons.forEach(btn => {

                    const cost = parseFloat(btn.dataset.cost) || emojiDashConfig.spawnCost;

                    const canPlay = !emojiDashState.finished && !emojiDashState.player && emojiDashState.elixir >= cost;

                    btn.disabled = !canPlay;

                    btn.classList.toggle('disabled', !canPlay);

                });

            }

            function finishEmojiDash({ message, winner }) {

                if (!emojiDashState || emojiDashState.finished) return;

                adjustEmojiDashTrophies(winner === 'player');

                emojiDashState.finished = true;

                emojiDashState.status = message;

                updateEmojiDashHUD();

                if (emojiDashState.finishTimeout) clearTimeout(emojiDashState.finishTimeout);

                stopEmojiDashMode();

                showEmojiDashResult(winner === 'player', message);

            }

            function awardEmojiDashWinRewards() {

                gold += 50;

                if (goldDisplay) goldDisplay.textContent = `ðŸ’° ${gold}`;

                normalizeChestSlots();

                let emptySlotIndex = trophyChests.findIndex((chest, index) => index < 4 && !chest);

                if (emptySlotIndex === -1) {

                    normalizeChestSlots();

                    emptySlotIndex = trophyChests.findIndex((chest, index) => index < 4 && !chest);

                }

                if (emptySlotIndex !== -1) {

                    trophyChests[emptySlotIndex] = { id: 'wood', openTime: Date.now(), clicks: 0, stars: 1 };

                    renderChests();

                }

                if (typeof saveUserData === 'function') saveUserData();

            }

            function showEmojiDashResult(isWin, detail) {

                startBgAnimation();

                const resultText = isWin ? 'You Win!' : 'You Lose!';

                const detailText = detail ? `${resultText} ${detail}` : resultText;

                if (gameMode === 'emojiDash' && emojiDashResultOverlay && emojiDashResultText) {

                    emojiDashResultText.textContent = detailText;

                    if (emojiDashResultRewardText) emojiDashResultRewardText.textContent = isWin ? '(+50 ðŸ’°, ðŸ“¦)' : '';

                    emojiDashResultOverlay.style.display = 'flex';

                    if (messageOverlay) messageOverlay.style.display = 'none';

                    if (menuButton) menuButton.style.display = 'none';

                } else {

                    if (!messageOverlay || !messageText) return;

                    messageText.textContent = detailText;

                    if (messageRewardText) messageRewardText.textContent = isWin ? '(+50 ðŸ’°, ðŸ“¦)' : '';

                    messageOverlay.style.display = 'flex';

                    if (startButton) startButton.style.display = 'none';

                    if (menuButton) menuButton.style.display = 'inline-block';

                }

                if (isWin) {

                    awardEmojiDashWinRewards();

                }

            }

            function startEmojiDashMode() {

                if (!emojiDashCanvas) return;

                if (!emojiDashCtx) emojiDashCtx = emojiDashCanvas.getContext('2d');

                if (emojiDashState && emojiDashState.finishTimeout) {

                    clearTimeout(emojiDashState.finishTimeout);

                }

                resetEmojiDashState();

                if (emojiDashResultOverlay) {

                    emojiDashResultOverlay.style.display = 'none';

                }

                if (emojiDashResultRewardText) {

                    emojiDashResultRewardText.textContent = '';

                }

                renderEmojiDashDeckBar();

                emojiDashActive = true;

                emojiDashLastTimestamp = performance.now();

                if (emojiDashLoopId) cancelAnimationFrame(emojiDashLoopId);

                emojiDashLoopId = requestAnimationFrame(emojiDashLoop);

            }

            function stopEmojiDashMode() {

                emojiDashActive = false;

                if (emojiDashState && emojiDashState.finishTimeout) {

                    clearTimeout(emojiDashState.finishTimeout);

                    emojiDashState.finishTimeout = null;

                }

                if (emojiDashLoopId) {

                    cancelAnimationFrame(emojiDashLoopId);

                    emojiDashLoopId = 0;

                }

                emojiDashKeys.left = false;

                emojiDashKeys.right = false;

                emojiDashKeys.jump = false;

            }

            function spawnPlayerTroop(cardId) {

                if (!emojiDashState || emojiDashState.finished) return;

                if (emojiDashState.player) {

                    emojiDashState.status = 'Only one troop at a time.';

                    return;

                }

                const deck = getDeckForMode('emojiDash') || [];

                if (deck.length !== 8) {

                    emojiDashState.status = 'Deck needs 8 cards.';

                    return;

                }

                const selectedCardId = cardId || deck[0];

                const card = allCards[selectedCardId];

                if (!card) {

                    emojiDashState.status = 'Invalid card.';

                    return;

                }

                const cost = card.cost || emojiDashConfig.spawnCost;

                if (emojiDashState.elixir < cost) {

                    emojiDashState.status = 'Not enough elixir.';

                    return;

                }

                emojiDashState.elixir -= cost;

                const stats = getEmojiDashCardStats(selectedCardId);

                const groundY = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight - 36;

                const playerHealth = Math.max(80, stats.health);

                emojiDashState.player = {

                    x: 80,

                    y: groundY,

                    width: 36,

                    height: 36,

                    vx: 0,

                    vy: 0,

                    health: playerHealth,

                    maxHealth: playerHealth,

                    damage: stats.damage,

                    emoji: card.emoji || '??',

                    facing: 1,

                    attackCooldown: 0

                };

                emojiDashState.status = `${card.name} deployed!`;

                updateEmojiDashDeckBar();

            }

            function spawnAiTroop() {

                if (!emojiDashState) return;

                const deck = getDeckForMode('emojiDash') || [];

                const cardId = deck.length ? deck[Math.floor(Math.random() * deck.length)] : null;

                const stats = cardId ? getEmojiDashCardStats(cardId) : { damage: emojiDashConfig.aiDamage, health: 130 };

                const emojiSymbol = cardId && allCards[cardId] ? allCards[cardId].emoji : '??';

                const groundY = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight - 36;

                const aiHealth = Math.max(90, stats.health);

                emojiDashState.ai = {

                    x: emojiDashConfig.canvasWidth - 120,

                    y: groundY,

                    width: 36,

                    height: 36,

                    vx: 0,

                    vy: 0,

                    health: aiHealth,

                    maxHealth: aiHealth,

                    damage: stats.damage,

                    emoji: emojiSymbol,

                    aiAttackCooldown: emojiDashConfig.aiAttackCooldown,

                    jumpTimer: 1.2,

                    facing: -1

                };

                emojiDashState.aiCardId = cardId;

                emojiDashState.aiSpawnTimer = emojiDashConfig.aiSpawnDelay;

                emojiDashState.status = cardId ? `${allCards[cardId].name} is on the move!` : 'Enemy approaching.';

            }

            function emojiDashFireAttack() {

                if (!emojiDashState || !emojiDashState.player) {

                    if (emojiDashState) emojiDashState.status = 'Deploy a troop first.';

                    return;

                }

                if (emojiDashState.player.attackCooldown > 0) return;

                emojiDashState.player.attackCooldown = emojiDashConfig.attackCooldown;

                const player = emojiDashState.player;

                const facing = player.facing || 1;

                const spawnX = facing === 1 ? player.x + player.width : player.x;

                const vx = 420 * facing;

                emojiDashState.projectiles.push({

                    owner: 'player',

                    x: spawnX,

                    y: player.y + player.height / 2,

                    vx,

                    vy: 0,

                    size: 10,

                    damage: emojiDashState.player.damage,

                    life: 1.3

                });

                emojiDashState.status = 'Attack fired!';

            }

            function emojiDashLoop(timestamp) {

                if (!emojiDashActive) return;

                const delta = Math.min(0.06, (timestamp - emojiDashLastTimestamp) / 1000);

                emojiDashLastTimestamp = timestamp;

                updateEmojiDashEntities(delta);

                drawEmojiDashScene();

                updateEmojiDashHUD();

                emojiDashLoopId = requestAnimationFrame(emojiDashLoop);

            }

            function updateEmojiDashEntities(delta) {

                if (!emojiDashState || emojiDashState.finished) return;

                emojiDashState.elixir = Math.min(emojiDashConfig.maxElixir, emojiDashState.elixir + emojiDashConfig.regenRate * delta);

                emojiDashState.aiSpawnTimer = Math.max(0, emojiDashState.aiSpawnTimer - delta);

                if (!emojiDashState.ai && emojiDashState.aiSpawnTimer <= 0) {

                    spawnAiTroop();

                }

                const playerEntity = emojiDashState.player;

                if (playerEntity) {

                    updateEmojiDashPlayer(delta);

                }

                if (emojiDashState.ai) {

                    updateEmojiDashAi(delta);

                }

                updateEmojiDashProjectiles(delta);

                tickEmojiDashDamageEffects(delta);

            }

            function updateEmojiDashPlayer(delta) {

                const player = emojiDashState.player;

                if (!player) return;

                const groundLimit = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight - player.height;

                if (emojiDashKeys.left) {

                    player.vx = -emojiDashConfig.moveSpeed;

                    player.facing = -1;

                } else if (emojiDashKeys.right) {

                    player.vx = emojiDashConfig.moveSpeed;

                    player.facing = 1;

                } else {

                    player.vx = 0;

                }

                if (emojiDashKeys.jump && player.vy === 0 && player.y >= groundLimit - 1) {

                    player.vy = -emojiDashConfig.jumpStrength;

                }

                player.vy += emojiDashConfig.gravity * delta;

                player.x = Math.max(0, Math.min(emojiDashConfig.canvasWidth - player.width, player.x + player.vx * delta));

                const prevPlayerY = player.y;

                player.y += player.vy * delta;

                const landedOnPlatform = resolveEmojiDashPlatformCollision(player, prevPlayerY);

                if (player.y >= groundLimit && !landedOnPlatform) {

                    player.y = groundLimit;

                    player.vy = 0;

                    checkEmojiDashJumpPads(player);

                } else if (landedOnPlatform) {

                    checkEmojiDashJumpPads(player);

                }

                player.attackCooldown = Math.max(0, player.attackCooldown - delta);

                checkEmojiDashSpikeDamage(player, delta, 'player');

                if (player.health <= 0) {

                    emojiDashState.player = null;

                    emojiDashState.status = 'Troop defeated, spawn another.';

                }

            }

            function updateEmojiDashAi(delta) {

                const ai = emojiDashState.ai;

                if (!ai) return;

                const player = emojiDashState.player;

                const desiredFacing = player ? Math.sign(player.x - ai.x) : -1;

                ai.facing = desiredFacing || -1;

                const groundLimit = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight - ai.height;

                ai.vy += emojiDashConfig.gravity * delta;

                const prevAiY = ai.y;

                ai.y += ai.vy * delta;

                const aiLandedOnPlatform = resolveEmojiDashPlatformCollision(ai, prevAiY);

                if (ai.y >= groundLimit && !aiLandedOnPlatform) {

                    ai.y = groundLimit;

                    ai.vy = 0;

                    checkEmojiDashJumpPads(ai);

                } else if (aiLandedOnPlatform) {

                    checkEmojiDashJumpPads(ai);

                }

                ai.jumpTimer = Math.max(0, ai.jumpTimer - delta);

                if (ai.jumpTimer <= 0 && Math.random() < 0.35) {

                    ai.vy = -emojiDashConfig.jumpStrength * 0.65;

                    ai.jumpTimer = 1.6;

                }

                if (ai.y >= groundLimit - 1 && ai.vy === 0) {

                    const spikeAhead = (emojiDashState.spikes || []).some(spike => ai.x < spike.x + spike.width + 12 && ai.x > spike.x - 12);

                    if (spikeAhead) {

                        ai.vy = -emojiDashConfig.jumpStrength * 0.85;

                        ai.jumpTimer = 1.4;

                    }

                }

                ai.aiAttackCooldown = Math.max(0, ai.aiAttackCooldown - delta);

                if (ai.aiAttackCooldown <= 0) {

                    const facing = ai.facing || -1;

                    const projX = facing === 1 ? ai.x + ai.width : ai.x;

                    emojiDashState.projectiles.push({

                        owner: 'ai',

                        x: projX,

                        y: ai.y + ai.height / 2,

                        vx: 360 * facing,

                        vy: 0,

                        size: 10,

                        damage: ai.damage,

                        life: 1.5

                    });

                    ai.aiAttackCooldown = emojiDashConfig.aiAttackCooldown;

                    emojiDashState.status = 'Enemy fire incoming!';

                }

                let blocked = false;

                if (player && ai.x <= player.x + player.width + 6 && ai.x >= player.x) {

                    blocked = true;

                    ai.x = player.x + player.width + 6;

                    const playerDead = applyEmojiDashDamage(player, delta * 32);

                    emojiDashState.status = 'Enemy blocked by your troop!';

                    if (playerDead) {

                        emojiDashState.player = null;

                        emojiDashState.status = 'Troop defeated, spawn another.';

                    }

                }

                if (!blocked) {

                    ai.x += -emojiDashConfig.aiSpeed * delta;

                }

                const leftTower = emojiDashState.leftTower;

                if (leftTower && ai.x <= leftTower.x + leftTower.width + 4) {

                    const destroyed = applyEmojiDashDamage(leftTower, delta * 160);

                    if (destroyed) {

                        finishEmojiDash({ message: 'AI captured your king tower!', winner: 'ai' });

                        return;

                    }

                }

                checkEmojiDashSpikeDamage(ai, delta, 'ai');

                if (ai.health <= 0) {

                    emojiDashState.ai = null;

                    emojiDashState.aiSpawnTimer = emojiDashConfig.aiSpawnDelay;

                    emojiDashState.status = 'Enemy down.';

                }

            }

            function checkEmojiDashSpikeDamage(entity, delta, type) {

                if (!entity || !emojiDashState) return;

                const bottom = entity.y + entity.height;

                const spikeLine = emojiDashConfig.canvasHeight - emojiDashConfig.groundHeight;

                if (bottom < spikeLine - 2) return;

                for (const spike of emojiDashState.spikes) {

                    if (entity.x + entity.width > spike.x && entity.x < spike.x + spike.width) {

                        const died = applyEmojiDashDamage(entity, delta * 40);

                        if (type === 'player') {

                            emojiDashState.status = 'Spikes hurt you!';

                        } else {

                            emojiDashState.status = 'Enemy stumbled on spikes!';

                        }

                        if (died) {

                            if (type === 'player') {

                                emojiDashState.player = null;

                                emojiDashState.status = 'Troop defeated, spawn another.';

                            } else {

                                emojiDashState.ai = null;

                                emojiDashState.aiSpawnTimer = emojiDashConfig.aiSpawnDelay;

                            }

                        }

                        break;

                    }

                }

            }

            function updateEmojiDashProjectiles(delta) {

                if (!emojiDashState) return;

                emojiDashState.projectiles = emojiDashState.projectiles.filter(proj => {

                    proj.x += proj.vx * delta;

                    const rightTower = emojiDashState.rightTower;

                    const leftTower = emojiDashState.leftTower;

                    if (proj.owner === 'player' && rightTower && proj.vx > 0 && proj.x >= rightTower.x) {

                        const destroyed = applyEmojiDashDamage(rightTower, proj.damage);

                        if (destroyed) {

                            finishEmojiDash({ message: 'You destroyed the enemy king tower!', winner: 'player' });

                        }

                        return false;

                    }

                    if (proj.owner === 'ai' && leftTower && proj.vx < 0 && proj.x <= leftTower.x + leftTower.width) {

                        const destroyed = applyEmojiDashDamage(leftTower, proj.damage);

                        if (destroyed) {

                            finishEmojiDash({ message: 'AI captured your king tower!', winner: 'ai' });

                        }

                        return false;

                    }

                    proj.life -= delta;

                    if (proj.life <= 0 || proj.x < -20 || proj.x > emojiDashConfig.canvasWidth + 20) return false;

                    if (proj.owner === 'player' && emojiDashState.ai && checkProjectileOverlap(proj, emojiDashState.ai)) {

                        const aiDead = applyEmojiDashDamage(emojiDashState.ai, proj.damage);

                        emojiDashState.status = 'Attack landed!';

                        if (aiDead) {

                            emojiDashState.ai = null;

                            emojiDashState.aiSpawnTimer = emojiDashConfig.aiSpawnDelay;

                            emojiDashState.status = 'Enemy down.';

                        }

                        return false;

                    }

                    if (proj.owner === 'ai' && emojiDashState.player && checkProjectileOverlap(proj, emojiDashState.player)) {

                        const playerDead = applyEmojiDashDamage(emojiDashState.player, proj.damage);

                        emojiDashState.status = 'You were struck!';

                        if (playerDead) {

                            emojiDashState.player = null;

                            emojiDashState.status = 'Troop defeated, spawn another.';

                        }

                        return false;

                    }

                    return true;

                });

                if (emojiDashState.ai && emojiDashState.ai.health <= 0) {

                    emojiDashState.ai = null;

                    emojiDashState.aiSpawnTimer = emojiDashConfig.aiSpawnDelay;

                }

            }

            function applyEmojiDashDamage(entity, amount) {

                if (!entity || amount <= 0) return false;

                entity.health = Math.max(0, entity.health - amount);

                entity.healthBarBounce = Math.min(20, (entity.healthBarBounce || 0) + 18);

                return entity.health <= 0;

            }

            function tickEmojiDashDamageEffects(delta) {

                if (!emojiDashState) return;

                const targets = [emojiDashState.player, emojiDashState.ai, emojiDashState.leftTower, emojiDashState.rightTower];

                targets.forEach(obj => {

                    if (obj && obj.healthBarBounce > 0) {

                        obj.healthBarBounce = Math.max(0, obj.healthBarBounce - delta * 60);

                    }

                });

            }

            function checkProjectileOverlap(proj, entity) {

                if (!entity) return false;

                return proj.x >= entity.x && proj.x <= entity.x + entity.width &&

                    proj.y >= entity.y && proj.y <= entity.y + entity.height;

            }

            function drawEmojiDashScene() {

                if (!emojiDashCtx || !emojiDashCanvas || !emojiDashState) return;

                const ctx = emojiDashCtx;

                const cw = emojiDashCanvas.width;

                const ch = emojiDashCanvas.height;

                ctx.clearRect(0, 0, cw, ch);

                const gradient = ctx.createLinearGradient(0, 0, 0, ch);

                gradient.addColorStop(0, '#020617');

                gradient.addColorStop(1, '#050c1c');

                ctx.fillStyle = gradient;

                ctx.fillRect(0, 0, cw, ch);

                const groundLine = ch - emojiDashConfig.groundHeight;

                ctx.fillStyle = '#0b1220';

                ctx.fillRect(0, groundLine, cw, emojiDashConfig.groundHeight);

                ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';

                ctx.lineWidth = 1.5;

                ctx.beginPath();

                ctx.moveTo(0, groundLine);

                ctx.lineTo(cw, groundLine);

                ctx.stroke();

                const drawTowerHealthBar = (tower, towerY) => {

                    if (!tower) return;

                    const healthPct = Math.max(0, Math.min(1, (tower.health || 0) / Math.max(tower.maxHealth || 1, 1)));

                    const barWidth = tower.width + 20;

                    const barX = Math.max(0, Math.min(cw - barWidth, tower.x - 10));

                    const bounce = tower.healthBarBounce || 0;

                    const barY = towerY - 14 + bounce;

                    ctx.fillStyle = 'rgba(15, 23, 42, 0.85)';

                    ctx.fillRect(barX, barY, barWidth, 6);

                    ctx.fillStyle = '#34d399';

                    ctx.fillRect(barX, barY, barWidth * healthPct, 6);

                    ctx.strokeStyle = 'rgba(255,255,255,0.35)';

                    ctx.lineWidth = 1;

                    ctx.strokeRect(barX, barY, barWidth, 6);

                };

                const drawKingTower = (tower, hue) => {

                    if (!tower) return;

                    const towerY = typeof tower.y === 'number' ? tower.y : tower.base - tower.height;

                    ctx.fillStyle = hue;

                    ctx.fillRect(tower.x, towerY, tower.width, tower.height);

                    ctx.strokeStyle = 'rgba(255,255,255,0.45)';

                    ctx.lineWidth = 2;

                    ctx.strokeRect(tower.x, towerY, tower.width, tower.height);

                    ctx.fillStyle = '#fef3c7';

                    ctx.fillRect(tower.x + 6, towerY - 6, tower.width - 12, 5);

                    drawTowerHealthBar(tower, towerY);

                };

                drawKingTower(emojiDashState.leftTower, '#38bdf8');

                drawKingTower(emojiDashState.rightTower, '#fb7185');

                emojiDashState.platforms.forEach(platform => {

                    ctx.fillStyle = 'rgba(59, 130, 246, 0.15)';

                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';

                    ctx.lineWidth = 1.5;

                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);

                });

                emojiDashState.spikes.forEach(spike => {

                    ctx.fillStyle = '#f87171';

                    ctx.beginPath();

                    ctx.moveTo(spike.x, groundLine);

                    ctx.lineTo(spike.x + spike.width / 2, groundLine - spike.height);

                    ctx.lineTo(spike.x + spike.width, groundLine);

                    ctx.closePath();

                    ctx.fill();

                });

                emojiDashState.jumpPads.forEach(pad => {

                    ctx.fillStyle = 'rgba(99, 102, 241, 0.8)';

                    ctx.fillRect(pad.x, groundLine - 12, pad.width, 12);

                    ctx.fillStyle = 'rgba(165, 180, 252, 0.9)';

                    ctx.fillRect(pad.x + 6, groundLine - 10, pad.width - 12, 8);

                });

                if (emojiDashState.player) {

                    drawEmojiDashEntity(ctx, emojiDashState.player, '#34d399');

                }

                if (emojiDashState.ai) {

                    drawEmojiDashEntity(ctx, emojiDashState.ai, '#f472b6');

                }

                emojiDashState.projectiles.forEach(proj => {

                    ctx.beginPath();

                    ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);

                    ctx.fillStyle = proj.owner === 'player' ? '#34d399' : '#f97316';

                    ctx.fill();

                });

            }

            function drawEmojiDashEntity(ctx, entity, tint) {

                ctx.save();

                ctx.font = '32px Inter, sans-serif';

                ctx.textAlign = 'center';

                ctx.textBaseline = 'middle';

                ctx.fillStyle = tint;

                ctx.fillText(entity.emoji || '??', entity.x + entity.width / 2, entity.y + entity.height / 2);

                ctx.restore();

                const maxHealth = entity.maxHealth && entity.maxHealth > 0 ? entity.maxHealth : 150;

                const healthPct = Math.max(0, Math.min(1, (entity.health || 0) / maxHealth));

                const totalWidth = entity.width + 12;

                const barX = Math.max(0, Math.min(emojiDashCanvas.width - totalWidth, entity.x - 6));

                const bounce = entity.healthBarBounce || 0;

                const barY = entity.y - 18 + bounce;

                ctx.fillStyle = '#0b1220';

                ctx.fillRect(barX, barY, totalWidth, 6);

                ctx.fillStyle = '#34d399';

                ctx.fillRect(barX, barY, totalWidth * healthPct, 6);

                ctx.strokeStyle = 'rgba(255,255,255,0.25)';

                ctx.lineWidth = 1;

                ctx.strokeRect(barX, barY, totalWidth, 6);

            }

            function updateEmojiDashHUD() {

                const levelInfo = getEmojiDashLevelByTrophies();

                emojiDashLevelId = levelInfo.id;

                if (emojiDashLevelLabel) {

                    emojiDashLevelLabel.textContent = `${levelInfo.name} â€¢ ${levelInfo.label}`;

                }

                if (emojiDashTrophyLabel) {

                    emojiDashTrophyLabel.textContent = `${emojiDashTrophies} trophies`;

                }

                if (!emojiDashState) return;

                if (emojiDashElixirFill) {

                    const percent = Math.max(0, Math.min(1, emojiDashState.elixir / emojiDashConfig.maxElixir));

                    emojiDashElixirFill.style.width = `${percent * 100}%`;

                }

                if (emojiDashElixirText) {

                    emojiDashElixirText.textContent = `${Math.floor(emojiDashState.elixir)}`;

                }

                updateEmojiDashDeckBar();

            }

            function normalizeEmojiDashKey(event) {

                const rawKey = (event.key || '');

                let normalized = rawKey === ' ' ? 'space' : rawKey.toLowerCase();

                if (normalized === 'spacebar') normalized = 'space';

                return normalized;

            }

            function emojiDashHandleKeyDown(event) {

                if (!emojiDashActive) return;

                const key = normalizeEmojiDashKey(event);

                if (key === 'a') {

                    emojiDashKeys.left = true;

                    event.preventDefault();

                } else if (key === 'd') {

                    emojiDashKeys.right = true;

                    event.preventDefault();

                } else if (key === 'w' || key === 'space') {

                    emojiDashKeys.jump = true;

                    event.preventDefault();

                }

            }

            function emojiDashHandleKeyUp(event) {

                const key = normalizeEmojiDashKey(event);

                if (key === 'a') emojiDashKeys.left = false;

                if (key === 'd') emojiDashKeys.right = false;

                if (key === 'w' || key === 'space') emojiDashKeys.jump = false;

            }

            // ==============================

            // Star and Quarter Star Helpers

            // ==============================

            // Checks if the player has reached the next quarter star milestone based on trophies.

            function checkQuarterStar() {

                // Determine the next quarter star milestone based on the last milestone reached.

                // Award quarter stars whenever the player crosses one or more 2500â€‘trophy thresholds.

                // This loop handles cases where the trophy count jumps past a milestone (e.g. from 2490 to 2600)

                let nextMilestone = lastQuarterMilestone + 2500;

                let awarded = false;

                while (trophies >= nextMilestone) {

                    quarterStars++;

                    lastQuarterMilestone = nextMilestone;

                    nextMilestone = lastQuarterMilestone + 2500;

                    awarded = true;

                }

                // If a star was awarded during this update, show the overlay and refresh the UI once

                if (awarded) {

                    if (typeof showQuarterStarAward === 'function') showQuarterStarAward();

                    if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

                }

            }

            // Shows the overlay informing the player they earned a quarter star

            function showQuarterStarAward() {

                if (quarterStarOverlay) {

                    quarterStarOverlay.style.display = 'flex';

                    const awardCount = document.getElementById('quarterStarCountAward');

                    if (awardCount) awardCount.textContent = quarterStars;

                    // Also update the other star count displays

                    const countEl = document.getElementById('quarterStarCount');

                    if (countEl) countEl.textContent = quarterStars;

                    const menuCount = document.getElementById('quarterStarCountMenu');

                    if (menuCount) {

                        menuCount.textContent = quarterStars;

                        const statusDiv = document.getElementById('quarterStarStatus');

                        if (statusDiv) statusDiv.style.display = quarterStars > 0 ? 'block' : 'none';

                    }

                }

            }

            // Updates the star boxes UI: star counts and progress indicators

            function reconcileStarBoxUnlocks() {
                if (starBoxesOpened >= 1) {
                    evolutionsUnlocked = true;
                }
                if (starBoxesOpened >= 2) {
                    superheroesUnlocked = true;
                }
                if (evolutionsUnlocked && starBoxesOpened < 1) {
                    starBoxesOpened = 1;
                }
                if (superheroesUnlocked && starBoxesOpened < 2) {
                    starBoxesOpened = 2;
                }
            }

            function updateStarBoxesUI() {

                const qCount = document.getElementById('quarterStarCount');

                const awardCount = document.getElementById('quarterStarCountAward');

                if (qCount) qCount.textContent = quarterStars;

                if (awardCount) awardCount.textContent = quarterStars;

                // Update quarter star status on the main menu (if present)

                const menuCount = document.getElementById('quarterStarCountMenu');

                const statusDiv = document.getElementById('quarterStarStatus');

                if (menuCount) {

                    menuCount.textContent = quarterStars;

                    if (statusDiv) {

                        statusDiv.style.display = quarterStars > 0 ? 'block' : 'none';

                    }

                }

                // The new design removes upgrade progress. Simply enable the open button

                const openBtn = document.getElementById('openBox1Button');

                const readyForBox1 = quarterStars > 0 && starBoxesOpened < 1;

                if (openBtn) {

                    openBtn.disabled = !readyForBox1;

                    openBtn.classList.toggle('ready', readyForBox1);

                }

                // Update evolution shard status on the main menu

                const evoStatus = document.getElementById('evoShardStatus');

                const evoCountSpan = document.getElementById('evoShardCountMenu');

                if (evoStatus && evoCountSpan) {

                    if (evolutionsUnlocked) {

                        evoStatus.style.display = 'block';

                        evoCountSpan.textContent = evolutionShards;

                    } else {

                        evoStatus.style.display = 'none';

                    }

                }

                const heroStatus = document.getElementById('superheroShardStatus');

                const heroCountSpan = document.getElementById('superheroShardCount');

                if (heroStatus && heroCountSpan) {

                    heroStatus.style.display = superheroShards > 0 ? 'block' : 'none';

                    heroCountSpan.textContent = superheroShards;

                }

                const openBox2Btn = document.getElementById('openBox2Button');
                const hasBox1 = starBoxesOpened >= 1;
                const box2Opened = superheroesUnlocked || starBoxesOpened >= 2;
                const hasArena21 = trophies >= 5000;
                const readyForBox2 = !box2Opened && hasBox1 && quarterStars > 0 && hasArena21;
                if (openBox2Btn) {
                    openBox2Btn.disabled = !readyForBox2;
                    openBox2Btn.classList.toggle('ready', readyForBox2);
                }

            }

            // Handles opening the first star box and giving rewards

            function openStarBox1() {

                if (quarterStars <= 0 || starBoxesOpened >= 1) return;

                // Consume one quarter star to open the box

                quarterStars--;

                starBoxesOpened = Math.max(starBoxesOpened, 1);

                evolutionsUnlocked = true;

                // Award a random number of evolution shards between 1 and 6

                const shards = Math.floor(Math.random() * 6) + 1;

                evolutionShards += shards;

                const overlay = document.getElementById('starBoxOpenOverlay');

                if (overlay) {

                    overlay.style.display = 'flex';

                    const unlockList = document.getElementById('starBoxUnlocks');

                    const rewardList = document.getElementById('starBoxRewards');

                    if (unlockList) {

                        unlockList.innerHTML = '<li>ðŸ§¬ Evolutions Unlocked</li>';

                    }

                    if (rewardList) {

                        rewardList.innerHTML = `<li>Evolution Shards ðŸ§¬: ${shards}</li>`;

                    }

                }

                if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();
                if (typeof saveUserData === 'function') saveUserData();

            }

            function openStarBox2() {

                if (quarterStars <= 0 || starBoxesOpened < 1 || superheroesUnlocked) return;

                if (trophies < 5000) {

                    alert('Reach Arena 21 (5000 trophies) before opening Star Box II.');

                    return;

                }

                quarterStars--;

                starBoxesOpened = Math.max(starBoxesOpened, 2);

                superheroesUnlocked = true;

                const heroShardGain = Math.floor(Math.random() * 2) + 1;

                superheroShards += heroShardGain;

                const overlay = document.getElementById('starBoxOpenOverlay');

                if (overlay) {

                    overlay.style.display = 'flex';

                    const unlockList = document.getElementById('starBoxUnlocks');

                    const rewardList = document.getElementById('starBoxRewards');

                    if (unlockList) {

                        unlockList.innerHTML = '<li>ðŸ¦¸ Superheroes Unlocked</li>';

                    }

                    if (rewardList) {

                        rewardList.innerHTML = `<li>Superhero Shards ðŸ¦¸: ${heroShardGain}</li>`;

                    }

                }

                if (typeof updateHeroSlotDecorations === 'function') updateHeroSlotDecorations();

                if (typeof renderDeckScreen === 'function') renderDeckScreen();

                if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

                if (typeof saveUserData === 'function') saveUserData();

            }

            function renderChests() {

                const slots = document.querySelectorAll('#chestSlots .chest-slot');

                slots.forEach((slot, index) => {

                    slot.innerHTML = '';

                    slot.onclick = null;

                    if (trophyChests[index]) {

                        slot.innerHTML = `ðŸ“¦`;

                        slot.classList.remove('text-gray-500', 'bg-gray-700');

                        slot.classList.add('bg-yellow-700', 'cursor-pointer');

                        // Fix closure issue by creating a proper closure

                        slot.onclick = ((chestIndex) => {

                            return () => openChest(chestIndex);

                        })(index);

                    } else {

                        slot.innerHTML = ``;

                        slot.classList.add('text-gray-500', 'bg-gray-700');

                        slot.classList.remove('bg-yellow-700', 'cursor-pointer');

                    }

                });

            

            function getChestRewardMultiplier() {

                const arenaLevel = getAILevel();

                const multipliers = {

                    1: 1.0,

                    2: 1.2,

                    3: 1.4,

                    4: 1.6,

                    5: 1.8,

                    6: 2.0,

                    7: 2.3,

                    8: 2.6,

                    9: 2.9,

                    10: 3.2,

                    11: 3.5,

                    12: 3.8

                };

                return multipliers[arenaLevel] || 1.0;

            }

            

// -----------------------------------------------------------------------------

// Chest UI helper â€“ updates title, stars, and status text in the chest overlay

function updateChestUI(stars, statusMsg) {

    const chestTitle = document.getElementById('chestTitle');

    const chestStars = document.getElementById('chestStars');

    const chestStatusText = document.getElementById('chestStatusText');

    chestTitle.textContent = `${stars} Star Box`;

    chestStars.innerHTML = 'â­'.repeat(stars);

    chestStatusText.innerHTML = statusMsg;

}

// -----------------------------------------------------------------------------

// Chest state variables.  These must be defined outside of any function so they

// can be shared by all chest-related functions.

let currentChestIndex   = -1;

let currentChestStars   = 1;

let chestClicks         = 0;

let isOpeningChest      = false;

const MAX_CHEST_CLICKS  = 4;

// -----------------------------------------------------------------------------

// Opens a chest when the player taps on it from the menu.

// Resets per-chest state, verifies necessary DOM elements, and shows the UI.

function openChest(index) {

    const chest = trophyChests[index];

    if (!chest) return;

    currentChestIndex  = index;

    currentChestStars  = chest.stars || 1;

    chestClicks        = chest.clicks || 0;

    isOpeningChest     = true;

    // Fetch all required UI elements

    const overlay      = document.getElementById('chestOpenOverlay');

    const rewardList   = document.getElementById('chestRewardList');

    const closeButton  = document.getElementById('chestCloseButton');

    const emoji        = document.getElementById('chestEmoji');

    const clickArea    = document.getElementById('chestClickArea');

    const clickCounter = document.getElementById('chestClickCounter');

    if (!overlay || !rewardList || !closeButton || !emoji || !clickArea || !clickCounter) {

        console.error('Missing required chest elements');

        return;

    }

    // Initialize chest overlay UI

    overlay.style.display       = 'flex';

    rewardList.innerHTML        = '';

    closeButton.style.display   = 'none';

    emoji.textContent           = 'ðŸ“¦';

    emoji.style.display         = 'block';

    clickArea.style.pointerEvents = 'auto';

    clickCounter.textContent    = `Tap to Upgrade (${chestClicks}/4)`;

    updateChestUI(currentChestStars, 'Found a Basic Box!');

}

// -----------------------------------------------------------------------------

// Handles clicks inside the chest overlay (tap-to-upgrade and final open).

const chestClickArea = document.getElementById('chestClickArea');

if (chestClickArea) {

    // Use an `onclick` assignment instead of addEventListener so that only one

    // handler is ever attached to this element. When using addEventListener

    // repeatedly (for example after re-entering the debug screen or reloading

    // the module), multiple handlers would accumulate, causing the game to

    // register multiple clicks for each tap and eventually freeze or slow down

    // after opening several chests. Assigning to `.onclick` replaces any

    // previous handler, preventing this buildup.

    chestClickArea.onclick = () => {

        const overlay = document.getElementById('chestOpenOverlay');

        // Guard against clicks when no chest is selected or overlay is hidden

        if (!overlay || overlay.style.display !== 'flex' ||

            currentChestIndex === -1 || !trophyChests[currentChestIndex]) {

            console.log('No valid chest selected or overlay not visible!');

            return;

        }

        const chestEmoji = document.getElementById('chestEmoji');

        if (chestEmoji) {

            chestEmoji.classList.remove('shake-anim');

            void chestEmoji.offsetWidth; // force reflow to restart animation

            chestEmoji.classList.add('shake-anim');

        }

        // Upgrade logic for the first four taps

        if (chestClicks < MAX_CHEST_CLICKS) {

            chestClicks++;

            document.getElementById('chestClickCounter').textContent =

                `Tap to Upgrade (${chestClicks}/4)`;

            // Persist upgrade state on the chest object

            const chest = trophyChests[currentChestIndex];

            if (chest) {

                chest.clicks = chestClicks;

                chest.stars  = currentChestStars;

            }

            // Determine upgrade chances (better odds during Christmas event)

            let chances = { 1: 0.5,  2: 0.3,  3: 0.15, 4: 0.05 };

            const roll     = Math.random();

            const required = chances[currentChestStars] || 0;

            if (currentChestStars < 5 && roll < required) {

                currentChestStars++;

                chestEmoji.classList.add('animate-pulse');

                setTimeout(() => chestEmoji.classList.remove('animate-pulse'), 500);

                updateChestUI(currentChestStars, 'Upgrade Successful! âœ¨');

                if (chest) chest.stars = currentChestStars;

            } else {

                updateChestUI(currentChestStars, 'No Upgradeâ€¦');

            }

        } else {

            // Fifth tap: time to open the chest

            document.getElementById('chestClickArea').style.pointerEvents = 'none';

            document.getElementById('chestClickCounter').textContent = '';

            finalizeChest(currentChestIndex, currentChestStars);

        }

    };

}

// -----------------------------------------------------------------------------

// Finalizes a chest, awards rewards, and plays the sequential reward animation.

function finalizeChest(index, stars) {

    // Remove the chest immediately so it canâ€™t be reopened

    trophyChests[index] = undefined;

    // Reset state variables for the next chest

    currentChestIndex  = -1;

    chestClicks        = 0;

    currentChestStars  = 1;

    // Mark Christmas chest claim

    // Prepare the reward UI

    const chestEmoji  = document.getElementById('chestEmoji');

    if (chestEmoji) chestEmoji.style.display = 'none';

    document.getElementById('chestStatusText').textContent = 'Rewards';

    // Determine reward multipliers

    const starMultipliers = { 1: 1.0, 2: 1.5, 3: 2.5, 4: 4.0, 5: 10.0 };

    const starMult  = starMultipliers[stars];

    const arenaMult = getChestRewardMultiplier();

    const totalMult = starMult * arenaMult;

    // Gold reward

    const rewardGold = Math.floor((50 + Math.floor(Math.random() * 50)) * totalMult);

    gold += rewardGold;

    // Determine how many card/tower stacks to award

    const unlockedCards = getUnlockedCards(false);

    const arenaNumber = getArenaNumberFromFloor(currentArenaFloor);

    const baseStackCount = Math.min(4, 1 + Math.floor(arenaNumber / 3));

    const extraStack = Math.random() < 0.35 ? 1 : 0;

    const numCardStacks = Math.min(5, Math.max(1, baseStackCount + extraStack));

    // Build reward objects

    const rewards = [];

    rewards.push({ type: 'gold', count: rewardGold, name: 'Gold' });

    for (let i = 0; i < numCardStacks; i++) {

        const baseCount = 1 + Math.floor(Math.random() * 2);

        const arenaCardMultiplier = 0.6 + arenaNumber * 0.18;

        const rawCount = Math.round(baseCount * totalMult * arenaCardMultiplier * 0.25);

        const cardCount = Math.max(1, Math.min(5, rawCount));

        // Chance to award tower cards on 3-star chests and above

        const isTowerReward = stars >= 3 && Math.random() < (0.08 + stars * 0.03);

        if (isTowerReward) {

            // Build a list of available towers

            const availableTowers = [];

            if (Math.random() < 0.3) availableTowers.push('princess');

            const arenaLevel = getAILevel();

            if (arenaLevel >= 10) availableTowers.push('waffle', 'machineGun', 'rocketeer');

            Object.keys(towerCollection).forEach(tid => {

                if (tid !== 'princess' && towerCollection[tid]?.unlocked) {

                    availableTowers.push(tid);

                }

            });

            if (availableTowers.length === 0) availableTowers.push('princess');

            const towerId = availableTowers[Math.floor(Math.random() * availableTowers.length)];

            const towerCardsAwarded = Math.min(5, cardCount);

            rewards.push({

                type: 'tower',

                id: towerId,

                count: towerCardsAwarded,

                name: `${towerDefs[towerId].name} Cards`

            });

            // Add tower cards to the playerâ€™s collection

            if (!towerCollection[towerId]) {

                towerCollection[towerId] = { level: 1, count: 0, unlocked: false };

            }

            towerCollection[towerId].unlocked = true;

            towerCollection[towerId].count   += towerCardsAwarded;

        } else {

            // Award normal unit/spell cards

            const cardId = unlockedCards[Math.floor(Math.random() * unlockedCards.length)];

            rewards.push({ type: 'card', id: cardId, count: cardCount });

            if (!cardCollection[cardId]) {

                cardCollection[cardId] = { level: 1, count: 0, unlocked: false };

            }

            cardCollection[cardId].unlocked = true;

            cardCollection[cardId].count   += cardCount;

        }

    }

    if (typeof renderMusicDeckUI === 'function') {

        renderMusicDeckUI();

    }

    // NEW: Award evolution shards for high-star chests (4 stars and above)

    // Chests with 4 or 5 stars will include a random number of shards between 1 and 6.

    // Higher shard counts are progressively rarer. This reward is separate from card

    // stacks and gold, and is added to the playerâ€™s evolution shard total.

    if (stars >= 4) {

        // Weighted probabilities: counts [1,2,3,4,5,6] with weights decreasing for larger values

        const shardCounts = [1, 2, 3, 4, 5, 6];

        const weights =    [40, 30, 20, 7, 2, 1];

        const totalW = weights.reduce((a, b) => a + b, 0);

        let rand = Math.random() * totalW;

        let shardCount = 1;

        for (let j = 0; j < shardCounts.length; j++) {

            if (rand < weights[j]) { shardCount = shardCounts[j]; break; }

            rand -= weights[j];

        }

        // Increase shard total

        evolutionShards += shardCount;

        if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

        // Add to rewards list for display

        rewards.push({ type: 'shard', count: shardCount, name: 'Evolution Shards' });

        // If evolutions are unlocked and this is the first evolution (Knight) and not yet unlocked

        // do not automatically unlock here; only the first star box can auto-unlock.

    }

    if (superheroesUnlocked && stars >= 4) {

        const heroShardGain = Math.floor(Math.random() * 2) + 1;

        superheroShards += heroShardGain;

        if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

        rewards.push({ type: 'heroShard', count: heroShardGain, name: 'Superhero Shards' });

    }

    // Reward display animation

    const rewardList = document.getElementById('chestRewardList');

    rewardList.innerHTML = '';

    let i = 0;

    function showNextReward() {

        if (i >= rewards.length) {

            const closeBtn = document.getElementById('chestCloseButton');

            // Show the Awesome! button and animate it

            closeBtn.style.display = 'block';

            closeBtn.classList.add('animate-bounce');

            // If this was a Christmas chest, update the UI and clear the flag

            // We are no longer in the opening state

            isOpeningChest = false;

            // Save progress once after all rewards have been tallied

            saveUserData();

            // Auto-close the chest after a short delay to prevent the overlay from getting stuck

            setTimeout(() => {

                const overlayEl = document.getElementById('chestOpenOverlay');

                if (overlayEl) overlayEl.style.display = 'none';

                // Remove animation class and clear rewards list

                closeBtn.classList.remove('animate-bounce');

                const rewardContainer = document.getElementById('chestRewardList');

                if (rewardContainer) rewardContainer.innerHTML = '';

                // Re-render the chest slots now that this chest is opened

                renderChests();

            }, 600);

            return;

        }

        const r = rewards[i];

        const div = document.createElement('div');

        div.className = 'reward-item bg-gray-700 p-2 rounded flex items-center justify-center space-x-2';

        if (r.type === 'gold') {

            div.innerHTML =

                `<span class="text-3xl">ðŸ’°</span><div class="flex flex-col">` +

                `<span class="text-yellow-400 font-bold text-xl">+${r.count}</span>` +

                `<span class="text-xs text-gray-400">Gold</span></div>`;

        } else if (r.type === 'tower') {

            const tower = towerDefs[r.id];

            div.innerHTML =

                `<span class="text-3xl">${tower.emoji}</span><div class="flex flex-col">` +

                `<span class="font-bold text-xl text-white">+${r.count}</span>` +

                `<span class="text-xs text-gray-400">${tower.name}</span></div>`;

        } else if (r.type === 'shard') {

            // Display evolution shard reward

            div.innerHTML =

                `<span class="text-3xl">ðŸ§¬</span><div class="flex flex-col">` +

                `<span class="font-bold text-xl text-white">+${r.count}</span>` +

                `<span class="text-xs text-gray-400">Evolution Shards</span></div>`;

        } else if (r.type === 'heroShard') {

            div.innerHTML =

                `<span class="text-3xl">âš¡</span><div class="flex flex-col">` +

                `<span class="font-bold text-xl text-white">+${r.count}</span>` +

                `<span class="text-xs text-gray-400">Superhero Shards</span></div>`;

        } else {

            const card = allCards[r.id];

            div.innerHTML =

                `<span class="text-3xl">${card.emoji}</span><div class="flex flex-col">` +

                `<span class="font-bold text-xl text-white">+${r.count}</span>` +

                `<span class="text-xs text-gray-400">${card.name}</span></div>`;

        }

        rewardList.appendChild(div);

        i++;

        setTimeout(showNextReward, 300);

    }

    showNextReward();

}

// -----------------------------------------------------------------------------

// Clean up the chest overlay when the Close button is pressed.

const chestCloseButton = document.getElementById('chestCloseButton');

if (chestCloseButton) {

    // Always assign the click handler via `onclick` so that only one handler

    // exists at a time. Using addEventListener here caused the handler to be

    // stacked multiple times as chests were opened, eventually making the

    // button unresponsive after several chests. Assigning directly to

    // `.onclick` replaces any previous handler and prevents this buildup.

    chestCloseButton.onclick = () => {

        const overlay = document.getElementById('chestOpenOverlay');

        if (overlay) overlay.style.display = 'none';

        // Reset chest opening state

        isOpeningChest = false;

        chestCloseButton.classList.remove('animate-bounce');

        const rewardList = document.getElementById('chestRewardList');

        if (rewardList) rewardList.innerHTML = '';

        // Re-render chest slots now that one has been opened

        renderChests();

    };

}

            // Assign nav button clicks via `.onclick` to avoid stacking handlers

            navButtons.forEach(btn => {

                // Remove any existing click handlers by assigning null first

                btn.onclick = null;

                btn.onclick = () => {

                    if (btn.dataset.screen === currentScreen) return;

                    if (btn.dataset.screen === 'debug') {

                        // Show debug screen directly

                        showScreen('debug');

                    } else {

                        showScreen(btn.dataset.screen);

                    }

                };

            });

            // updateLogClose event listener handled above

            

            function beginStandardBattle(loadingText = 'Finding Opponent...') {

                menuScreen.classList.remove('active');

                loadingScreen.classList.add('active');

                loadingScreen.querySelector('p').textContent = loadingText;

                setTimeout(() => {

                    showScreen('game');

                    messageText.textContent = 'Get Ready!';

                    startButton.style.display = 'none';

                    menuButton.style.display = 'none';

                    messageOverlay.style.display = 'flex';

                    setTimeout(() => {

                        initGame();

                        lastTime = performance.now();

                        gameLoopId = requestAnimationFrame(gameLoop);

                    }, 1500);

                }, 1000);

            }

            if (battleButton) battleButton.addEventListener('click', () => { 

                if (battleButton.disabled) return; 

                restoreFromSnowmanChallenge(); 

                if (gameMode === 'emojiDash') { 

                    showScreen('emojiDash');

                    startEmojiDashMode();

                    return;

                }

                if (gameMode === 'party1v1') {

                     if (playerDeckParty.length !== 8) {

                        alert('Add 8 cards to your 1v1 Party deck first!');

                        showScreen('deck');

                        return;

                     }

                     beginStandardBattle('Finding Party Opponent...');

                     return;

                }

                if (gameMode === 'chaos') {

                     if (playerDeckChaos.length !== 8) {

                        alert('Add 8 cards to your Chaos Works deck first!');

                        showScreen('deck');

                        return;

                     }

                     beginStandardBattle('Finding Chaos Opponent...');

                     return;

                }

                if (gameMode === '2v2') {

                    if (playerDeck2v2.length !== 8) {

                        alert('Add 8 cards to your 2v2 deck first!');

                        showScreen('deck');

                        return;

                    }

                    // Show teammate choice modal

                    show2v2TeammateChoice();

                } else { 

                    beginStandardBattle(); 

                } 

            }); 

            if (heroAbilityButton) {

                heroAbilityButton.addEventListener('click', () => {

                    if (playerHeroUnit && playerHeroUnit.canUseHeroAbility()) {

                        playerHeroUnit.triggerHeroAbility();

                        updateHeroAbilityPanel();

                    }

                });

            }

            // NEW: Arena screen buttons

            if (arenaButton) {

                arenaButton.onclick = null;

                arenaButton.onclick = () => {

                    showScreen('arena');

                };

            }

            // Use `.onclick` for arenaBackButton to prevent multiple handlers

            if (arenaBackButton) {

                arenaBackButton.onclick = null;

                arenaBackButton.onclick = () => {

                    showScreen('menu');

                };

            }

            if (emojiDashCanvas) {

                emojiDashCanvas.addEventListener('click', emojiDashFireAttack);

            }

            window.addEventListener('keydown', emojiDashHandleKeyDown);

            window.addEventListener('keyup', emojiDashHandleKeyUp);

            // ==============================================

                if (debugArena2) {

                    // Use `.onclick` to avoid stacking multiple handlers

                    debugArena2.onclick = null;

                    debugArena2.onclick = () => {

                        trophies = 250;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena3) {

                    debugArena3.onclick = null;

                    debugArena3.onclick = () => {

                        trophies = 500;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena4) {

                    debugArena4.onclick = null;

                    debugArena4.onclick = () => {

                        trophies = 750;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena5) {

                    debugArena5.onclick = null;

                    debugArena5.onclick = () => {

                        trophies = 1000;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena6) {

                    debugArena6.onclick = null;

                    debugArena6.onclick = () => {

                        trophies = 1250;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena7) {

                    debugArena7.onclick = null;

                    debugArena7.onclick = () => {

                        trophies = 1500;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena8) {

                    debugArena8.onclick = null;

                    debugArena8.onclick = () => {

                        trophies = 1750;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena9) {

                    debugArena9.onclick = null;

                    debugArena9.onclick = () => {

                        trophies = 2000;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena10) {

                    debugArena10.onclick = null;

                    debugArena10.onclick = () => {

                        trophies = 2250;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena11) {

                    debugArena11.onclick = null;

                    debugArena11.onclick = () => {

                        trophies = 2500;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena12) {

                    debugArena12.onclick = null;

                    debugArena12.onclick = () => {

                        trophies = 2750;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena13) {

                    debugArena13.onclick = null;

                    debugArena13.onclick = () => {

                        trophies = 3000;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena14) {

                    debugArena14.onclick = null;

                    debugArena14.onclick = () => {

                        trophies = 3250;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena15) {

                    debugArena15.onclick = null;

                    debugArena15.onclick = () => {

                        trophies = 3500;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena16) {

                    debugArena16.onclick = null;

                    debugArena16.onclick = () => {

                        trophies = 3750;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena17) {

                    debugArena17.onclick = null;

                    debugArena17.onclick = () => {

                        trophies = 4000;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena18) {

                    debugArena18.onclick = null;

                    debugArena18.onclick = () => {

                        trophies = 4250;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena19) {

                    debugArena19.onclick = null;

                    debugArena19.onclick = () => {

                        trophies = 4500;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena20) {

                    debugArena20.onclick = null;

                    debugArena20.onclick = () => {

                        trophies = 4750;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugArena21) {

                    debugArena21.onclick = null;

                    debugArena21.onclick = () => {

                        trophies = 5000;

                        updateArena();

                        saveUserData();

                        showScreen('menu');

                    };

                }

                if (debugUnlockAll) {

                    debugUnlockAll.onclick = null;

                    debugUnlockAll.onclick = () => {

                        for (const cardId in allCards) {

                            if (cardId === 'tower' || cardId === 'miniStoneGiant') continue;

                            if (allCards[cardId] && allCards[cardId].hidden) continue;

                            if (!cardCollection[cardId]) {

                                cardCollection[cardId] = { level: 1, count: 1, unlocked: true };

                            } else {

                                cardCollection[cardId].unlocked = true;

                                if (cardCollection[cardId].count === 0) {

                                    cardCollection[cardId].count = 1;

                                }

                            }

                        }

                        saveUserData();

                        console.log('All cards unlocked!');

                    };

                }

                if (debugUpgradeAll) {

                    let isProcessingUpgrade = false;

                    debugUpgradeAll.onclick = () => {

                        if (isProcessingUpgrade) return;

                        isProcessingUpgrade = true;

                        

                        for (const cardId in cardCollection) {

                            const cardData = cardCollection[cardId];

                            if (cardData.unlocked && cardData.level < 15) {

                                cardData.level++;

                            }

                        }

                        saveUserData();

                        console.log('All cards upgraded by 1 level!');

                        

                        isProcessingUpgrade = false;

                    };

                }

                if (debugGetChest) {

                    let isProcessingChest = false;

                    debugGetChest.onclick = () => {

                        if (isProcessingChest) return;

                        isProcessingChest = true;

                        

                        // Ensure trophyChests has exactly 4 slots

                        while (trophyChests.length < 4) {

                            trophyChests.push(undefined);

                        }

                        

                        // Count actual chests (not undefined) in first 4 slots

                        const actualChestCount = trophyChests.slice(0, 4).filter(chest => chest).length;

                        

                        if (actualChestCount >= 4) {

                            console.log('Chest slots are full!');

                            isProcessingChest = false;

                            return;

                        }

                        

                        // Find first empty slot in first 4 positions

                        const emptySlotIndex = trophyChests.slice(0, 4).findIndex((chest, index) => !chest);

                        if (emptySlotIndex !== -1) {

                            trophyChests[emptySlotIndex] = { id: 'wood', openTime: Date.now(), clicks: 0, stars: 1 };

                            renderChests();

                            saveUserData();

                            console.log('Got a chest!');

                        } else {

                            console.log('Chest slots are full!');

                        }

                        

                        isProcessingChest = false;

                    };

                }

                if (debugReset) {

                    debugReset.onclick = null;

                    debugReset.onclick = () => {

                        initNewUser();

                        saveUserData();

                        showScreen('menu');

                        console.log('Account reset!');

                    };

                }

                // NEW: Debug button to grant evolution shards for testing

                const debugAddShards = document.getElementById('debugAddShards');
                const debugAddHeroShard = document.getElementById('debugAddHeroShard');

                if (debugAddShards) {

                    debugAddShards.onclick = null;

                    debugAddShards.onclick = () => {

                        evolutionShards += 6;

                        if (!evolutionsUnlocked && evolutionShards >= 6) evolutionsUnlocked = true;

                        saveUserData();

                        if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

                        console.log('Added 6 evolution shards via debug');

                    };

                }

                if (debugAddHeroShard) {

                    debugAddHeroShard.onclick = null;

                    debugAddHeroShard.onclick = () => {

                        superheroShards += 1;

                        reconcileStarBoxUnlocks();

                        if (typeof updateHeroSlotDecorations === 'function') updateHeroSlotDecorations();

                        if (typeof renderDeckScreen === 'function') renderDeckScreen();

                        if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

                        if (typeof saveUserData === 'function') saveUserData();

                        console.log('Added 1 hero shard via debug');

                    };

                }

                if (debugEmojiDashLevel1) {

                    debugEmojiDashLevel1.onclick = null;

                    debugEmojiDashLevel1.onclick = () => {

                        setEmojiDashTrophiesForLevel(1);

                        console.log('Emoji Dash Level 1 selected');

                    };

                }

                if (debugEmojiDashLevel2) {

                    debugEmojiDashLevel2.onclick = null;

                    debugEmojiDashLevel2.onclick = () => {

                        setEmojiDashTrophiesForLevel(2);

                        console.log('Emoji Dash Level 2 selected');

                    };

                }

                if (debugEmojiDashLevel3) {

                    debugEmojiDashLevel3.onclick = null;

                    debugEmojiDashLevel3.onclick = () => {

                        setEmojiDashTrophiesForLevel(3);

                        console.log('Emoji Dash Level 3 selected');

                    };

                }

            }

            const btnNewYearNewMe = document.getElementById('btnNewYearNewMe');

            if (btnNewYearNewMe) {

                btnNewYearNewMe.onclick = null;

                btnNewYearNewMe.onclick = () => startNewYearNewMeEvent();

            }

            function rollNewYearHero({ excludeCurrent = true } = {}) {
                const exclude = excludeCurrent ? newYearPlayerHero : null;
                const chosen = getRandomHeroId({ allowLocked: true, exclude });
                if (chosen) {
                    newYearPlayerHero = chosen;
                }
                heroOverrideForEvent = newYearPlayerHero;
                return heroOverrideForEvent;
            }

            function rollNewYearAIHero({ exclude = [] } = {}) {
                const excludeList = Array.isArray(exclude) ? [...exclude] : [exclude];
                if (newYearPlayerHero) excludeList.push(newYearPlayerHero);
                const chosen = getRandomHeroId({ allowLocked: true, exclude: excludeList });
                if (chosen) {
                    updateNewYearAIHero(chosen);
                }
                return newYearAIHero;
            }

            function startNewYearNewMeEvent() {

                returnModeAfterSnowman = lastRegularGameMode || 'trophy';

                snowmanChallengeActive = false;

                clearNewYearHeroes();
                newYearEventActive = true;

                const eventHeroId = rollNewYearHero({ excludeCurrent: false });
                rollNewYearAIHero({ exclude: eventHeroId });

                gameMode = 'new_year_new_me';

                updateArena();

                if (loadingScreen) {

                    const loadingText = loadingScreen.querySelector('p');

                    if (loadingText) {

                        loadingText.textContent = 'Warming up the Superhero Launch...';

                    }

                }

                showScreen('loading');

                setTimeout(() => {

                    showScreen('game');

                    if (messageText) messageText.textContent = 'New Year New Me';

                    if (startButton) startButton.style.display = 'none';

                    if (menuButton) menuButton.style.display = 'none';

                    if (messageOverlay) messageOverlay.style.display = 'flex';

                    setTimeout(() => {

                        initGame();

                        lastTime = performance.now();

                        gameLoopId = requestAnimationFrame(gameLoop);

                    }, 1500);

                }, 1000);

            }

            // ==============================================

            // CARD & DECK LOGIC

            // ==============================================

            function isEmojiDashRestrictedCard(card) {

                if (!card) return false;

                const typeLabel = (card.type || '').toLowerCase();

                const isSwarm = typeLabel.includes('swarm');

                const isBuilding = typeLabel === 'building';

                const isSpell = typeLabel === 'spell';

                return isSwarm || isBuilding || isSpell;

            }

            function createCardDOM(cardId, isSmall = false, inHand = false) {

                const card = allCards[cardId];

                if (!card || card.hidden) return null;

                

                const cardData = cardCollection[cardId] || { level: 1, count: 0, unlocked: false };

                    const isParty = (gameMode === '2v2' || gameMode === 'party1v1' || gameMode === 'chaos');

                const isEmojiDashMode = (gameMode === 'emojiDash');

                const collectionSearchInput = document.getElementById('collectionSearch');

                if (collectionSearchInput) {

                    collectionSearchInput.value = collectionSearchTerm;

                }

                const lockedSearchInput = document.getElementById('lockedSearch');

                if (lockedSearchInput) {

                    lockedSearchInput.value = lockedSearchTerm;

                }

                const emojiDashRestricted = isEmojiDashMode && isEmojiDashRestrictedCard(card);

                const generalLocked = !inHand && (!cardData || !cardData.unlocked);

                const isLocked = emojiDashRestricted || (!isEmojiDashMode && !isParty && generalLocked);

                

                const cardEl = document.createElement('div');

                // Added btn-shine to cards

                cardEl.className = `card-ui btn-shine ${isSmall ? 'card-ui-small' : ''}`;

                cardEl.dataset.unit = cardId;

                

                if (isLocked) { 

                    cardEl.classList.add('card-ui-locked');

                    let lockedText = ``;

                    if (emojiDashRestricted) {

                        lockedText = `<div class="card-ui-locked-arena">Not available in Emoji Dash</div>`;

                    } else if (!inHand && card.arena !== 1) {

                        lockedText = `<div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>`;

                    }

                    cardEl.innerHTML = `

                        <div class="card-ui-cost">${card.cost}</div>

                        <span class="card-ui-name">${card.name}</span>

                        <span class="card-ui-emoji">${card.emoji}</span>

                        <span class="card-ui-type">${card.type}</span>

                        ${lockedText}

                    `;

                    return cardEl;

                }

                const useMaxLevel = isMaxLevelMatch();

                const displayLevel = useMaxLevel ? 15 : ((cardData && cardData.level) ? cardData.level : 1);

                const displayCount = (cardData && cardData.count) ? cardData.count : 0;

                

                cardEl.dataset.cost = card.cost;

                cardEl.dataset.type = card.type;

                cardEl.dataset.emoji = card.emoji;

                cardEl.dataset.radius = card.placementRadius;

                if (card.radius) cardEl.dataset.spellRadius = card.radius;

                if (card.isSuperhero) {

                    cardEl.classList.add('hero-card');

                    const assignedHero = getHeroSlotForMode();

                    if (assignedHero === cardId) {

                        cardEl.classList.add('hero-card-assigned');

                    } else {

                        cardEl.classList.add('hero-card-available');

                    }

                }

                let progressBarHTML = '';

                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;

                if (!inHand) {

                    const costs = upgradeCosts[displayLevel];

                    let progress = 0;

                    let canUpgrade = false;

                    if (costs) {

                        progress = (displayCount / costs.cards) * 100;

                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }

                    } else { progress = 100; } // Max level

                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;

                } else { levelTextHTML = ''; }

            cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;

            return cardEl;

        }

            function isCardInEvoSlot(cardId) {

                if (!cardId || !evolutionsUnlocked || !evoUnlockedCards || !evoUnlockedCards[cardId]) return false;

                const modeKey = getMatchModeKey();

                const slots = matchEvoSlots[modeKey] || [];

                if (slots.includes(cardId)) return true;

                let deckForMode = playerDeck;

                if (modeKey === '2v2') deckForMode = playerDeck2v2;

                else if (modeKey === 'party1v1') deckForMode = playerDeckParty;

                else if (modeKey === 'chaos') deckForMode = playerDeckChaos;

                if (!deckForMode || !deckForMode.length) return false;

                const fallbackSlots = deckForMode.slice(0, 2);

                return fallbackSlots.includes(cardId);

            }

            function applyCardEvoDots(cardEl, cardId) {

                if (!cardEl || !cardId) return;

                let dotsWrapper = cardEl.querySelector('.card-ui-evo-dots');

                if (!isCardInEvoSlot(cardId)) {

                    if (dotsWrapper) dotsWrapper.remove();

                    cardEl.classList.remove('card-ui-evo-ready');

                    return;

                }

                const cardDef = allCards[cardId];

                if (!cardDef || !cardDef.evo) {

                    if (dotsWrapper) dotsWrapper.remove();

                    cardEl.classList.remove('card-ui-evo-ready');

                    return;

                }

                const baseCycle = Math.max(1, cardDef.evo.cycle || 1);

                const requiredCycles = baseCycle;

                const cycleDots = Math.max(1, baseCycle);

                const currentCount = playerEvoCycleCounts[cardId] || 0;

                if (!dotsWrapper) {

                    dotsWrapper = document.createElement('div');

                    dotsWrapper.className = 'card-ui-evo-dots';

                    cardEl.appendChild(dotsWrapper);

                }

                dotsWrapper.innerHTML = '';

                const filledCount = Math.min(currentCount, cycleDots);

                for (let i = 0; i < cycleDots; i++) {

                    const dot = document.createElement('span');

                    dot.className = 'card-ui-evo-dot';

                    if (i < filledCount) dot.classList.add('filled');

                    dotsWrapper.appendChild(dot);

                }

                const isReady = currentCount >= requiredCycles && evoUnlockedCards && evoUnlockedCards[cardId];

                cardEl.classList.toggle('card-ui-evo-ready', isReady);

                if (!cardEl.style.position || cardEl.style.position === 'static') {

                    cardEl.style.position = 'relative';

                }

            }

            function refreshCardEvoIndicators() {

                document.querySelectorAll('#cardHand .card-ui, #nextCardSlot .card-ui').forEach(el => {

                    const cardId = el.dataset.unit;

                    applyCardEvoDots(el, cardId);

                });

            }

function getUnlockedCards(includeTower = false, aiLevel = 0, mode = gameMode) {

    const unlocked = [];

    if (mode === 'chaos') {

        for (const cardId in allCards) {

            if (cardId === 'tower' || cardId === 'miniStoneGiant') continue;

            if (allCards[cardId] && allCards[cardId].hidden) continue;

            unlocked.push(cardId);

        }

        if (includeTower) {

            unlocked.push('tower');

        }

        return unlocked;

    }

    // Use AI level if provided, otherwise resolve the arena count from the trophy floor

    const arenaNum = aiLevel > 0 ? aiLevel : getArenaNumberFromFloor(currentArenaFloor);

                

                for (const cardId in allCards) {

                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Never include tower or internal mini in this list

                    if (allCards[cardId] && allCards[cardId].hidden) continue;

                    if (allCards[cardId].arena <= arenaNum) {

                        unlocked.push(cardId);

                    }

                }

                if (includeTower) {

                    unlocked.push('tower');

                }

                return unlocked;

            }

            function renderDeckScreen() {

                const isParty = gameMode === '2v2' || gameMode === 'party1v1' || gameMode === 'emojiDash' || gameMode === 'chaos';

                deckCardGrid.innerHTML = '';

                collectionCardGrid.innerHTML = '';

                lockedCardGrid.innerHTML = ''; 

                if (unlockableCardGrid) unlockableCardGrid.innerHTML = '';

                if (unlockableSection) unlockableSection.style.display = 'none';

                const heroUnlockableCards = [];

                

                const deckModeKey = getMatchModeKey();

                ensureMatchEvoSlotsForMode(deckModeKey);

                const currentDeck = getDeckForMode(gameMode);

                const isEmojiDashMode = (gameMode === 'emojiDash');

                const heroAssigned = superheroesUnlocked && Boolean(getHeroSlotForMode());

                const deckCountEl = document.getElementById('deckCount');
                const totalDeckCount = Math.min(8, currentDeck.length + (heroAssigned ? 1 : 0));
                if (deckCountEl) deckCountEl.textContent = `${totalDeckCount} / 8`;

                // Calculate Average Elixir

                let totalCost = 0;

                currentDeck.forEach(id => { if (allCards[id]) totalCost += allCards[id].cost; });

                const avg = currentDeck.length > 0 ? (totalCost / currentDeck.length).toFixed(1) : "0.0";

                const avgElixirEl = document.getElementById('avgElixir');

                if (avgElixirEl) avgElixirEl.textContent = avg;

                const deckDisplaySlots = buildDeckDisplaySlots(currentDeck, heroAssigned);

                deckDisplaySlots.forEach((cardId, displayIdx) => {

                    let cardEl = null;

                    if (displayIdx === HERO_SLOT_INDEX && heroAssigned) {

                        cardEl = createHeroSlotPlaceholderCard();

                    } else if (cardId) {

                        cardEl = createCardDOM(cardId, false);

                        if (cardEl) {

                            cardEl.addEventListener('click', () => openCardModal(cardId));

                        }

                    }

                    if (!cardEl) return;

                    // Highlight the first two slots when evolutions are unlocked

                    if (!isEmojiDashMode && evolutionsUnlocked && displayIdx < 2 && cardId) {

                        if (evoUnlockedCards && evoUnlockedCards[cardId]) {

                            cardEl.style.outline = '3px solid rgb(192,132,252)';

                            cardEl.style.outlineOffset = '-2px';

                        } else {

                            cardEl.style.outline = '2px dashed rgba(192,132,252,0.5)';

                            cardEl.style.outlineOffset = '-2px';

                        }

                    }

                    deckCardGrid.appendChild(cardEl);

                });

                if (!isEmojiDashMode) {

                    refreshCardEvoIndicators();

                } else {

                    const deckCards = deckCardGrid.querySelectorAll('.card-ui');

                    deckCards.forEach(el => {

                        el.style.outline = 'none';

                    });

                }

                // --- Enable Drag-and-Drop Reordering of Deck Cards ---

                // After rendering deck cards, attach HTML5 drag and drop handlers to allow

                // repositioning cards by dragging them within the deck grid. This enables

                // moving cards into the first two slots (evolution slots) and reordering

                // other cards. The updated deck order is saved and the UI is re-rendered.

                const deckCards = Array.from(deckCardGrid.children);

                let draggedIdx = null;

                deckCards.forEach((el, index) => {

                    if (el.classList.contains('hero-slot-base')) return;

                    el.setAttribute('draggable', 'true');

                    el.dataset.deckIndex = index;

                    el.addEventListener('dragstart', (ev) => {

                        draggedIdx = parseInt(el.dataset.deckIndex);

                        try {

                            ev.dataTransfer.setData('text/plain', draggedIdx.toString());

                            ev.dataTransfer.effectAllowed = 'move';

                        } catch(e) {}

                    });

                    // Prevent default dragover to allow dropping

                    el.addEventListener('dragover', (ev) => {

                        ev.preventDefault();

                        try { ev.dataTransfer.dropEffect = 'move'; } catch(e) {}

                    });

                    el.addEventListener('drop', (ev) => {

                        ev.preventDefault();

                        const fromIdx = draggedIdx !== null ? draggedIdx : parseInt(ev.dataTransfer.getData('text/plain'));

                        const toIdx = parseInt(el.dataset.deckIndex);

                        if (isNaN(fromIdx) || isNaN(toIdx) || fromIdx === toIdx) return;

                        let deckRef;

                        if (gameMode === '2v2') deckRef = playerDeck2v2;

                        else if (gameMode === 'party1v1') deckRef = playerDeckParty;

                        else if (gameMode === 'chaos') deckRef = playerDeckChaos;

                        else if (gameMode === 'emojiDash') deckRef = playerDeckEmojiDash;

                        else deckRef = playerDeck;

                        const temp = deckRef[toIdx];

                        deckRef[toIdx] = deckRef[fromIdx];

                        deckRef[fromIdx] = temp;

                        if (gameMode === '2v2') playerDeck2v2 = [...deckRef];

                        else if (gameMode === 'party1v1') playerDeckParty = [...deckRef];

                        else if (gameMode === 'chaos') playerDeckChaos = [...deckRef];

                        else if (gameMode === 'emojiDash') playerDeckEmojiDash = [...deckRef];

                        else playerDeck = [...deckRef];

                        draggedIdx = null;

                        if (typeof saveUserData === 'function') saveUserData();

                        renderDeckScreen();

                    });

                });

                

                // Render Collection & Locked Cards (SMALL CARDS, isSmall=true)

                const sortedCardIds = Object.keys(allCards)

                    .filter(cardId => cardId !== 'tower' && cardId !== 'miniStoneGiant')

                    .sort((a, b) => {

                        const arenaA = (allCards[a] && typeof allCards[a].arena === 'number') ? allCards[a].arena : Infinity;

                        const arenaB = (allCards[b] && typeof allCards[b].arena === 'number') ? allCards[b].arena : Infinity;

                        if (arenaA !== arenaB) return arenaA - arenaB;

                        return a.localeCompare(b);

                    });

                const collectionFilterLower = (collectionSearchTerm || '').toLowerCase();

                const lockedFilterLower = (lockedSearchTerm || '').toLowerCase();

                for (const cardId of sortedCardIds) {

                    const cardData = cardCollection[cardId];

                    const cardDef = allCards[cardId];

                    if (cardDef?.isSuperhero && !superheroesUnlocked) continue;

                    const specialMode = (gameMode === '2v2' || gameMode === 'party1v1' || gameMode === 'emojiDash' || gameMode === 'chaos');

                    const isLocked = specialMode ? false : (!cardData || !cardData.unlocked);

                    const cardEl = createCardDOM(cardId, true);

                    if (!cardEl) continue;

                    cardEl.addEventListener('click', () => openCardModal(cardId));

                    const cardName = (allCards[cardId] && allCards[cardId].name) ? allCards[cardId].name.toLowerCase() : cardId.toLowerCase();

                    const normalizedText = `${cardName} ${cardId.toLowerCase()}`;

                    const matchesCollection = !collectionFilterLower || normalizedText.includes(collectionFilterLower);

                    const matchesLocked = !lockedFilterLower || normalizedText.includes(lockedFilterLower);

                    const heroUnlockable = superheroesUnlocked && cardDef?.isSuperhero && (!cardData || !cardData.unlocked);

                    if (heroUnlockable) {

                        heroUnlockableCards.push({ cardEl, matchesLocked });

                        continue;

                    }

                    if (isParty) {

                        if (matchesCollection) {

                            collectionCardGrid.appendChild(cardEl);

                        }

                    } else {

                        if (isLocked) {

                            if (matchesLocked) {

                                lockedCardGrid.appendChild(cardEl);

                            }

                        } else if (matchesCollection) {

                            collectionCardGrid.appendChild(cardEl);

                        }

                    }

                }

                
                if (unlockableCardGrid && heroUnlockableCards.length > 0) {

                    heroUnlockableCards.forEach(({ cardEl, matchesLocked }) => {

                        cardEl.classList.remove('card-ui-locked', 'card-ui-locked-arena');

                        cardEl.classList.add('unlockable-hero-card');

                        if (matchesLocked) {

                            unlockableCardGrid.appendChild(cardEl);

                        }

                    });

                }

                if (unlockableSection) {

                    const visibleHeroes = heroUnlockableCards.some(item => item.matchesLocked);

                    unlockableSection.style.display = visibleHeroes ? 'flex' : 'none';

                }

                updateBattleButtonState();

                updateHeroSlotDecorations();

            }

function buildDeckDisplaySlots(currentDeck, heroAssigned) {

    const slots = currentDeck.slice(0, 8);

    while (slots.length < 8) {

        slots.push(null);

    }

    if (!heroAssigned) {

        return slots;

    }

    const heroIndex = Math.min(HERO_SLOT_INDEX, slots.length - 1);

    const displacedCard = slots[heroIndex];

    slots[heroIndex] = null;

    if (!displacedCard) {

        return slots;

    }

    slots.splice(heroIndex + 1, 0, displacedCard);

    if (slots.length > 8) {

        slots.pop();

    }

    return slots;

}


            function createHeroSlotPlaceholderCard() {

                const el = document.createElement('div');

                el.className = 'card-ui hero-slot-base';

                el.dataset.unit = 'hero-slot-placeholder';

                return el;

            }


            function updateHeroSlotDecorations() {

                if (!deckCardGrid) return;

                const heroSlotEl = deckCardGrid.children[HERO_SLOT_INDEX];

                if (!heroSlotEl) return;

                let overlay = heroSlotEl.querySelector('.hero-slot-overlay');

                if (!overlay) {

                    overlay = document.createElement('div');

                    overlay.className = 'hero-slot-overlay';

                    heroSlotEl.appendChild(overlay);

                }

                overlay.style.display = 'none';

                overlay.innerHTML = '';

                heroSlotEl.classList.remove('hero-slot-enabled');

                overlay.style.pointerEvents = 'none';

                overlay.onclick = null;

                if (!superheroesUnlocked) return;

                heroSlotEl.classList.add('hero-slot-enabled');

                overlay.style.display = 'flex';

                const heroId = getHeroSlotForMode();

                if (heroId && allCards[heroId]) {

                    const heroCardEl = createCardDOM(heroId, false);

                    if (heroCardEl) {

                        heroCardEl.classList.add('hero-slot-card');

                        heroCardEl.style.pointerEvents = 'auto';

                        heroCardEl.addEventListener('click', (event) => {

                            event.stopPropagation();

                            openCardModal(heroId);

                        });

                        overlay.appendChild(heroCardEl);

                        overlay.style.pointerEvents = 'auto';

                    }

                }

            }

            function attachDeckSearchHandlers() {

                const collectionSearchInput = document.getElementById('collectionSearch');

                if (collectionSearchInput) {

                    collectionSearchInput.addEventListener('input', (e) => {

                        collectionSearchTerm = e.target.value || '';

                        renderDeckScreen();

                    });

                }

                const lockedSearchInput = document.getElementById('lockedSearch');

                if (lockedSearchInput) {

                    lockedSearchInput.addEventListener('input', (e) => {

                        lockedSearchTerm = e.target.value || '';

                        renderDeckScreen();

                    });

                }

            }

            if (document.readyState === 'loading') {

                document.addEventListener('DOMContentLoaded', attachDeckSearchHandlers);

            } else {

                attachDeckSearchHandlers();

            }

            

            function renderTowerScreen() {

                // --- NEW: Render Collection Grid ---

                const screenDiv = document.querySelector('#towerScreen > div');

                screenDiv.innerHTML = `

                    <h1 class="text-3xl font-bold mb-4 ui-text-effect battle-arena-name">Tower Collection</h1>

                    <p class="text-sm text-gray-400 mb-6">Get tower cards from chests to unlock new towers!</p>

                    <div id="towerGrid" class="grid grid-cols-2 gap-4 w-full"></div>

                `;

                const grid = document.getElementById('towerGrid');

                

                Object.keys(towerDefs).forEach(type => {

                    const def = towerDefs[type];

                    const data = towerCollection[type] || { level: 1, count: 0, unlocked: false };

                    

                    const el = document.createElement('div');

                    el.className = `relative bg-gray-800 border-4 rounded-xl p-4 flex flex-col items-center cursor-pointer transition transform hover:scale-105 ${selectedTower === type ? 'border-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.5)]' : 'border-gray-600'}`;

                    if (!data.unlocked) el.classList.add('grayscale');

                    // Progress Bar Calculation

                    const costs = towerUpgradeCosts[data.level];

                    let progressHTML = '';

                    if (costs && data.unlocked) {

                        const pct = Math.min(100, (data.count / costs.cards) * 100);

                        const canUp = data.count >= costs.cards && gold >= costs.gold;

                        progressHTML = `<div class="w-full h-2 bg-gray-900 rounded-full mt-2 overflow-hidden border border-gray-700"><div class="h-full ${canUp ? 'bg-yellow-400' : 'bg-blue-500'}" style="width: ${pct}%"></div></div>`;

                    }

                    

                    el.innerHTML = `

                        <div class="text-5xl mb-2">${def.emoji}</div>

                        <h3 class="font-bold text-white">${def.name}</h3>

                        <p class="text-xs text-gray-400 text-center mt-1">${def.desc}</p>

                        ${data.unlocked ? `<div class="mt-2 text-yellow-300 font-bold">Lvl ${data.level}</div>` : '<div class="mt-2 text-red-400 font-bold text-xs">Arena 10+</div>'}

                        ${progressHTML}

                        ${selectedTower === type ? '<div class="absolute top-2 right-2 text-yellow-400">âœ…</div>' : ''}

                    `;

                    el.onclick = () => openTowerModal(type);

                    grid.appendChild(el);

                });

            }

            

            function openTowerModal(type) {

                const def = towerDefs[type];

                const data = towerCollection[type] || { level: 1, count: 0, unlocked: false };

                currentPreviewCardId = type; // Set for preview loop

                

                // Re-use card modal logic mostly

                cardInfoDisplay.innerHTML = `<div class="text-8xl">${def.emoji}</div>`;

                cardInfoName.textContent = def.name;

                cardInfoType.textContent = 'Tower';

                cardInfoLevel.textContent = `Level ${data.level}`;

                

                // Good/Weak Against

                const previewStrongHeader = document.getElementById('previewStrongHeader');

                const previewWeakHeader = document.getElementById('previewWeakHeader');

                const previewStrongList = document.getElementById('previewStrong');

                const previewWeakList = document.getElementById('previewWeak');

                let sText = "Good Against: Balanced Units";

                let wText = "Weak Against: Tanks, Swarms";

                let sDesc = "Versatile defense against most threats.";

                let wDesc = "Can be overwhelmed by large numbers.";

                if (type === 'waffle') {

                    sText = "Good Against: Friendly Troops (Support)";

                    wText = "Weak Against: Rushes";

                    sDesc = "King throws waffles to heal/level up allies. Princess towers are weaker.";

                    wDesc = "Lower stats make defense harder without troop support.";

                } else if (type === 'machineGun') {

                    sText = "Good Against: Swarms, Glass Cannons";

                    wText = "Weak Against: Tanks (Recharge)";

                    sDesc = "Bursts fire rapidly, shredding low HP units.";

                    wDesc = "Vulnerable during the long recharge period after bursting.";

                } else if (type === 'rocketeer') {

                    sText = "Good Against: Tanks, Clusters";

                    wText = "Weak Against: Fast Swarms";

                    sDesc = "Deals massive damage per hit.";

                    wDesc = "Very slow fire rate makes it bad against many small units.";

                }

                if (previewStrongHeader) previewStrongHeader.textContent = sText;

                if (previewWeakHeader) previewWeakHeader.textContent = wText;



                if (previewStrongList) { previewStrongList.style.display = 'flex'; previewStrongList.innerHTML = `<div class="text-xs text-gray-400">${sDesc}</div>`; }

                if (previewWeakList) { previewWeakList.style.display = 'flex'; previewWeakList.innerHTML = `<div class="text-xs text-gray-400">${wDesc}</div>`; }

                // Stats

                const base = towerStats[data.level];

                const hp = Math.round(base.princessHealth * def.healthMod);

                const dmg = Math.round(base.damage * def.dmgMod);

                const spd = (base.hitSpeed * def.speedMod).toFixed(1);

                

                let extraStats = '';

                if (type === 'waffle') extraStats = '<div>Ability: <span>Waffle Throw</span></div><div>Rate: <span>25s</span></div>';

                if (type === 'machineGun') extraStats = '<div>Ability: <span>Rapid Burst</span></div><div>Burst: <span>3s</span></div>';

                if (type === 'rocketeer') extraStats = '<div>Type: <span>High Damage</span></div><div>Speed: <span>Slow</span></div>';

                cardInfoStats.innerHTML = `

                    <div>Health: <span>${hp}</span></div>

                    <div>Damage: <span>${dmg}</span></div>

                    <div>Hit Speed: <span>${spd}s</span></div>

                    ${extraStats}

                    <div class="text-xs text-gray-400 mt-2">${def.desc}</div>

                `;

                

                cardInfoButtons.innerHTML = '';

                cardInfoProgressContainer.style.display = 'none';

                cardInfoButton.style.display = 'none';

                if (!isLocked && stats) {

                    const currentDeck = getDeckForMode();

                    const heroSlot = getHeroSlotForMode();

                    const heroAssigned = Boolean(heroSlot);

                    const deckCountWithHero = currentDeck.length + (heroAssigned ? 1 : 0);

                    const deckFull = deckCountWithHero >= 8;

                    const isHero = card.isSuperhero;

                    const isInDeck = isHero ? (heroSlot === cardId) : currentDeck.includes(cardId);

                    const addRemoveBtn = document.createElement('button');

                    addRemoveBtn.id = 'addRemoveBtn';

                    if (isHero) {

                        if (isInDeck) {

                            addRemoveBtn.textContent = 'Remove from Deck';

                            addRemoveBtn.className = 'modal-btn remove';

                            addRemoveBtn.onclick = () => removeHeroFromSlot(cardId);

                        } else if (heroAssigned) {

                            addRemoveBtn.textContent = 'Superhero Slot Full';

                            addRemoveBtn.className = 'modal-btn';

                            addRemoveBtn.disabled = true;

                        } else {

                            addRemoveBtn.textContent = deckFull ? 'Deck is Full (8/8)' : 'Add to Deck';

                            addRemoveBtn.className = 'modal-btn add';

                            addRemoveBtn.disabled = deckFull;

                            addRemoveBtn.onclick = () => addToDeck(cardId);

                        }

                    } else {

                        if (isInDeck) {

                            addRemoveBtn.textContent = 'Remove from Deck';

                            addRemoveBtn.className = 'modal-btn remove';

                            addRemoveBtn.onclick = () => removeFromDeck(cardId);

                        } else {

                            addRemoveBtn.textContent = deckFull ? 'Deck is Full (8/8)' : 'Add to Deck';

                            addRemoveBtn.className = 'modal-btn add';

                            addRemoveBtn.onclick = () => addToDeck(cardId);

                            addRemoveBtn.disabled = deckFull;

                        }

                    }

                    cardInfoButtons.appendChild(addRemoveBtn);

                    cardInfoProgressContainer.style.display = 'block';

                    cardInfoButton.style.display = 'block';
                    

                    const displayCount = cardData.count || 0;

                    const costs = upgradeCosts[displayLevel];

                    

                    if (costs) {

                        const progress = (displayCount / costs.cards);

                        cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;

                        cardInfoProgressText.textContent = `${displayCount} / ${costs.cards}`;

                        const canUpgrade = displayCount >= costs.cards && gold >= costs.gold;

                        cardInfoProgressBar.classList.toggle('can-upgrade', canUpgrade);

                        cardInfoButton.className = 'modal-btn upgrade';

                        cardInfoButton.textContent = `Upgrade (?? ${costs.gold})`;

                        cardInfoButton.disabled = !canUpgrade;

                        cardInfoButton.onclick = () => upgradeCard(cardId);

                    } else {

                        cardInfoProgressContainer.style.display = 'none';

                        cardInfoButton.className = 'modal-btn';

                        cardInfoButton.textContent = 'Max Level (15)';

                        cardInfoButton.disabled = true;

                    }

                    // If evolutions are unlocked and this card has an evolution defined then add an

                    // unlock button (if not already unlocked) and the DNA toggle button to switch

                    // between base and evolution stats/preview. The unlock button is only

                    // interactive when the player has at least 6 evolution shards and the card's

                    // evolution has not been unlocked yet.

                    if (evolutionsUnlocked && allCards[cardId] && allCards[cardId].evo) {

                        // If this evolution isn't unlocked, provide a button to unlock it

                        if (!evoUnlockedCards[cardId]) {

                            const unlockBtn = document.createElement('button');

                            unlockBtn.className = 'modal-btn flex items-center justify-center';

                            // Set text based on shard availability

                            if (evolutionShards >= 6) {

                                unlockBtn.textContent = 'Unlock Evolution (6ðŸ§¬)';

                                unlockBtn.disabled = false;

                            } else {

                                unlockBtn.textContent = 'Need 6ðŸ§¬ to Unlock';

                                unlockBtn.disabled = true;

                            }

                            unlockBtn.onclick = () => {

                                // Double check shard count and locked status

                                if (evolutionShards >= 6 && !evoUnlockedCards[cardId]) {

                                    evolutionShards -= 6;

                                    evoUnlockedCards[cardId] = true;

                                    // Persist the unlock

                                    if (typeof saveUserData === 'function') saveUserData();

                                    // Update any UI that shows shard counts

                                    if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

                                    // Re-render deck so evo slot highlights update

                                    if (typeof renderDeckScreen === 'function') renderDeckScreen();

                                    // Re-open the modal to refresh buttons and toggle state

                                    openCardModal(cardId);

                                    return;

                                }

                            };

                            cardInfoButtons.appendChild(unlockBtn);

                        }

                        // Always show the DNA toggle once evolutions are unlocked globally.

                        // This lets players preview the evolved stats even before unlocking that

                        // particular card's evolution.

                        originalStatsHTML = cardInfoStats.innerHTML;

                        const evoToggleBtn = document.createElement('button');

                        evoToggleBtn.className = 'modal-btn flex items-center justify-center';

                        evoToggleBtn.innerHTML = 'ðŸ§¬';

                        // Helper to update the button appearance based on previewUseEvo state

                        const updateToggleStyle = () => {

                            if (previewUseEvo) {

                                evoToggleBtn.classList.add('bg-blue-700', 'hover:bg-blue-800');

                            } else {

                                evoToggleBtn.classList.remove('bg-blue-700', 'hover:bg-blue-800');

                            }

                        };

                        updateToggleStyle();

                        evoToggleBtn.onclick = () => {

                            // Toggle previewUseEvo state

                            previewUseEvo = !previewUseEvo;

                            updateToggleStyle();

                            // When toggled on, show evolution stats; else restore original stats

                            if (previewUseEvo) {

                                showEvoStats(cardId);

                            } else {

                                cardInfoStats.innerHTML = originalStatsHTML;

                            }

                            // Restart preview loop to apply the evolved state in the preview

                            startPreviewLoop();

                        };

                        cardInfoButtons.appendChild(evoToggleBtn);

                    }

                }



                

                // --- Populate Preview Tab ---

                const roles = getCardRoles(cardId);

                

                const previewStrongHeaderEl = document.getElementById('previewStrongHeader');

                const previewWeakHeaderEl = document.getElementById('previewWeakHeader');

                if (previewStrongHeaderEl) previewStrongHeaderEl.textContent = `Good Against: ${roles.strong}`;

                if (previewWeakHeaderEl) previewWeakHeaderEl.textContent = `Weak Against: ${roles.weak}`;

                const previewWeakContainer = document.getElementById('previewWeakContainer');

                // Hide detailed lists as requested, but keep headers

                if (previewStrongList) { previewStrongList.innerHTML = ''; previewStrongList.style.display = 'none'; }

                if (previewWeakList) { previewWeakList.innerHTML = ''; previewWeakList.style.display = 'none'; }

            if (previewWeakContainer) previewWeakContainer.style.display = 'block';

                // --- NEW: Populate All Cards List ---

                const allCardsList = document.getElementById('previewAllCardsList');

                const searchInput = document.getElementById('previewSearchInput');

                allCardsList.innerHTML = '';

                searchInput.value = '';

                                const previewToggleContainer = searchInput.parentNode;

                const updatePreviewToggleStyle = (btn, active, accent) => {

                    btn.style.backgroundColor = active ? accent : 'rgba(148, 163, 184, 0.2)';

                    btn.style.border = `1px solid ${active ? accent : 'rgba(255, 255, 255, 0.3)'}`;

                    btn.style.color = '#fff';

                    btn.style.boxShadow = active ? `0 0 12px ${accent}80` : 'none';

                };

                const ensurePreviewToggle = ({ id, shouldShow, icon, title, getActive, setActive, accent, insertAfterId }) => {

                    if (!previewToggleContainer) return;

                    let btn = document.getElementById(id);

                    if (!shouldShow) {

                        if (btn) btn.remove();

                        if (setActive) setActive(false);

                        return;

                    }

                    if (!btn) {

                        btn = document.createElement('button');

                        btn.id = id;

                        btn.type = 'button';

                        btn.className = 'ml-2 px-2 py-1 rounded text-xl transition';

                        btn.innerHTML = icon;

                        btn.title = title;

                        btn.onclick = () => {

                            setActive(!getActive());

                            applyPreviewListFilters(searchInput, allCardsList);

                            updatePreviewToggleStyle(btn, getActive(), accent);

                        };

                        const referenceNode = insertAfterId ? document.getElementById(insertAfterId) : null;

                        const insertBeforeNode = referenceNode ? referenceNode.nextSibling : searchInput.nextSibling;

                        previewToggleContainer.insertBefore(btn, insertBeforeNode);

                    }

                    updatePreviewToggleStyle(btn, getActive(), accent);

                };

                ensurePreviewToggle({

                    id: 'previewListEvoToggle',

                    shouldShow: evolutionsUnlocked,

                    icon: 'ðŸ§¬',

                    title: 'Show only evolutions',

                    getActive: () => previewListEvoOnly,

                    setActive: (value) => { previewListEvoOnly = value; },

                    accent: '#2563eb'

                });

                ensurePreviewToggle({

                    id: 'previewListHeroToggle',

                    shouldShow: superheroesUnlocked,

                    icon: 'âš¡',

                    title: 'Show only superheroes',

                    getActive: () => previewListHeroOnly,

                    setActive: (value) => { previewListHeroOnly = value; },

                    accent: '#fcd34d',

                    insertAfterId: 'previewListEvoToggle'

                });

// Helper to clear all highlights

                const clearAllHighlights = () => {

                     document.querySelectorAll('#previewStrong .card-ui, #previewWeak .card-ui, #previewAllCardsList .card-ui').forEach(c => c.style.borderColor = '');

                };

                // Patch existing items in Strong/Weak to clear All List highlights

                [previewStrongList, previewWeakList].forEach(container => {

                    Array.from(container.children).forEach(child => {

                        if (child.classList.contains('card-ui')) {

                            const originalClick = child.onclick;

                            child.onclick = (e) => {

                                clearAllHighlights(); // Clear everything first

                                if (originalClick) originalClick(e); // Then let original logic run

                            };

                        }

                    });

                });

                // Populate All Cards

                const sortedCards = Object.keys(allCards)

                    .filter(id => id !== 'tower' && id !== 'miniStoneGiant')

                    .filter(id => !allCards[id] || !allCards[id].hidden)

                    .sort((a, b) => allCards[a].name.localeCompare(allCards[b].name));

                sortedCards.forEach(cid => {

                    const el = createCardDOM(cid, true);

                    if (!el) return;

                    // Mark whether this card has an evolution defined for filtering

                    el.dataset.hasEvo = (allCards[cid] && allCards[cid].evo) ? 'true' : 'false';
                    el.dataset.isHero = (allCards[cid] && allCards[cid].isSuperhero) ? 'true' : 'false';

                    el.onclick = (e) => {

                        e.stopPropagation();

                        currentPreviewOpponentId = cid;

                        clearAllHighlights();

                        el.style.borderColor = '#3b82f6'; // blue-500

                        startPreviewLoop();

                    };

                    el.dataset.searchName = allCards[cid].name.toLowerCase();

                    allCardsList.appendChild(el);

                });

                applyPreviewListFilters(searchInput, allCardsList);

                // Search Listener (Once)

                if (!searchInput.dataset.hasListener) {

                    searchInput.dataset.hasListener = 'true';

                    searchInput.addEventListener('input', () => applyPreviewListFilters(searchInput, allCardsList));

                }

                refreshCardAbilityInfo(cardId);
                cardInfoModal.style.display = 'flex';

            }

            function openCardModal(cardId) {
                const card = allCards[cardId];
                if (!card) return;
                const cardData = cardCollection[cardId];
                currentPreviewCardId = cardId;
                card.id = cardId;
                const isParty = (gameMode === '2v2' || gameMode === 'party1v1');
                const isLocked = isParty ? false : (!cardData || !cardData.unlocked);
                const storedLevel = (cardData && cardData.level) ? cardData.level : 1;
                const displayLevel = isParty ? 15 : storedLevel;
                const previewLevel = card.isSuperhero ? 10 : displayLevel;
                const statsForDisplay = card.stats ? (card.stats[previewLevel] || card.stats[displayLevel]) : null;

                // --- Header ---
                cardInfoDisplay.innerHTML = '';
                const cardDom = createCardDOM(cardId, false);
                if (cardDom) {

                    cardInfoDisplay.appendChild(cardDom);

                    if (card.isSuperhero) {

                        const levelBadge = cardDom.querySelector('.card-ui-level');

                        if (levelBadge) {

                            levelBadge.textContent = `Lvl ${previewLevel}`;

                        }

                    }

                }
                cardInfoName.textContent = card.name;
                cardInfoType.textContent = card.isSuperhero ? 'Superhero' : (card.type || 'Special');
                cardInfoLevel.textContent = isLocked ? "Not Unlocked" : `Level ${displayLevel}`;

                switchTab('stats');

                cardInfoStats.innerHTML = `<div>Targets: <span>${card.targets || '-'}</span></div>`;
                if (card.isFlying) cardInfoStats.innerHTML += `<div>Placement: <span>Air</span></div>`;
                else if (card.type !== 'Spell' && card.type !== 'Building') cardInfoStats.innerHTML += `<div>Placement: <span>Ground</span></div>`;

                if (statsForDisplay) {
                    for (const [key, value] of Object.entries(statsForDisplay)) {
                        if (key === 'barbLevel') continue;
                        cardInfoStats.innerHTML += `<div>${key.charAt(0).toUpperCase() + key.slice(1).replace('_', ' ')}: <span>${value}</span></div>`;
                    }
                    if (card.type === 'Spell') cardInfoStats.innerHTML += `<div>Radius: <span>${card.radius}</span></div>`;
                    if (statsForDisplay.damage && statsForDisplay.hitSpeed) {
                        const dps = (statsForDisplay.damage / statsForDisplay.hitSpeed).toFixed(1);
                        cardInfoStats.innerHTML += `<div>DPS: <span>${dps}</span></div>`;
                    }
                }

                if (cardId === 'mage') {
                    const skelStats = allCards['skeletons']?.stats?.[1];
                    if (skelStats) {
                        cardInfoStats.innerHTML += `<div class='mt-2 font-bold text-yellow-300'>Spawns 4 Skeletons every 5s:</div>`;
                        cardInfoStats.innerHTML += `<div>Skeleton HP: <span>${skelStats.health}</span></div>`;
                    }
                }
                if (cardId === 'stoneGiant') {
                    const miniStats = allCards['stoneGiant']?.miniStats?.[1];
                    if (miniStats) {
                        cardInfoStats.innerHTML += `<div class='mt-2 font-bold text-yellow-300'>Splits into 2 Mini Stone Giants:</div>`;
                        cardInfoStats.innerHTML += `<div>Mini HP: <span>${miniStats.health}</span></div>`;
                    }
                }

                cardInfoButtons.innerHTML = '';
                cardInfoProgressContainer.style.display = 'none';
                cardInfoButton.style.display = 'none';

                if (isLocked || !statsForDisplay) {
                    if (isLocked) cardInfoLevel.textContent = `Unlocks in Arena ${card.arena}`;
                } else {
                    const currentDeck = getDeckForMode();
                    const heroSlot = getHeroSlotForMode();
                    const heroAssigned = Boolean(heroSlot);
                    const deckCountWithHero = currentDeck.length + (heroAssigned ? 1 : 0);
                    const deckFull = deckCountWithHero >= 8;
                    const isHero = card.isSuperhero;
                    const isInDeck = isHero ? (heroSlot === cardId) : currentDeck.includes(cardId);
                    const addRemoveBtn = document.createElement('button');
                    addRemoveBtn.id = 'addRemoveBtn';
                    if (isHero) {
                        if (isInDeck) {
                            addRemoveBtn.textContent = 'Remove from Deck';
                            addRemoveBtn.className = 'modal-btn remove';
                            addRemoveBtn.onclick = () => removeHeroFromSlot(cardId);
                        } else if (heroAssigned) {
                            addRemoveBtn.textContent = 'Superhero Slot Full';
                            addRemoveBtn.className = 'modal-btn';
                            addRemoveBtn.disabled = true;
                        } else {
                            addRemoveBtn.textContent = deckFull ? 'Deck is Full (8/8)' : 'Add to Deck';
                            addRemoveBtn.className = 'modal-btn add';
                            addRemoveBtn.disabled = deckFull;
                            addRemoveBtn.onclick = () => addToDeck(cardId);
                        }
                    } else {
                        if (isInDeck) {
                            addRemoveBtn.textContent = 'Remove from Deck';
                            addRemoveBtn.className = 'modal-btn remove';
                            addRemoveBtn.onclick = () => removeFromDeck(cardId);
                        } else {
                            addRemoveBtn.textContent = deckFull ? 'Deck is Full (8/8)' : 'Add to Deck';
                            addRemoveBtn.className = 'modal-btn add';
                            addRemoveBtn.onclick = () => addToDeck(cardId);
                            addRemoveBtn.disabled = deckFull;
                        }
                    }
                    cardInfoButtons.appendChild(addRemoveBtn);
                    cardInfoProgressContainer.style.display = 'block';
                    cardInfoButton.style.display = 'block';

                    const displayCount = cardData?.count || 0;
                    const costs = upgradeCosts[displayLevel];

                    if (costs) {
                        const progress = (displayCount / costs.cards);
                        cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                        cardInfoProgressText.textContent = `${displayCount} / ${costs.cards}`;
                        const canUpgrade = displayCount >= costs.cards && gold >= costs.gold;
                        cardInfoProgressBar.classList.toggle('can-upgrade', canUpgrade);
                        cardInfoButton.className = 'modal-btn upgrade';
                        cardInfoButton.textContent = `Upgrade (ðŸ’° ${costs.gold})`;
                        cardInfoButton.disabled = !canUpgrade;
                        cardInfoButton.onclick = () => upgradeCard(cardId);
                    } else {
                        cardInfoProgressContainer.style.display = 'none';
                        cardInfoButton.className = 'modal-btn';
                        cardInfoButton.textContent = 'Max Level (15)';
                        cardInfoButton.disabled = true;
                    }
                }

                if (card.isSuperhero && (!cardData || !cardData.unlocked)) {
                    const shardCost = 1;
                    const unlockHeroBtn = document.createElement('button');
                    unlockHeroBtn.className = 'modal-btn flex items-center justify-center';
                    if (superheroShards >= shardCost) {
                        unlockHeroBtn.textContent = `Unlock âš¡ ${shardCost}`;
                        unlockHeroBtn.disabled = false;
                    } else {
                        unlockHeroBtn.textContent = `Need âš¡ ${shardCost}`;
                        unlockHeroBtn.disabled = true;
                    }
                    unlockHeroBtn.onclick = () => {
                        if (superheroShards < shardCost) return;
                        superheroShards -= shardCost;
                        if (!cardCollection[cardId]) cardCollection[cardId] = { level: 1, count: 0, unlocked: false };
                        cardCollection[cardId].unlocked = true;
                        if (typeof saveUserData === 'function') saveUserData();
                        if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();
                        renderDeckScreen();
                        openCardModal(cardId);
                    };
                    cardInfoButtons.appendChild(unlockHeroBtn);
                }

                // --- Populate Preview Tab ---

                const roles = getCardRoles(cardId);

                const previewStrongHeader = document.getElementById('previewStrongHeader');

                const previewWeakHeader = document.getElementById('previewWeakHeader');

                if (previewStrongHeader) previewStrongHeader.textContent = `Good Against: ${roles.strong}`;

                if (previewWeakHeader) previewWeakHeader.textContent = `Weak Against: ${roles.weak}`;

                const previewStrong = document.getElementById('previewStrong');

                const previewWeak = document.getElementById('previewWeak');

                const previewWeakContainer = document.getElementById('previewWeakContainer');

                // Hide detailed lists as requested, but keep headers

                if (previewStrong) { previewStrong.innerHTML = ''; previewStrong.style.display = 'none'; }

                if (previewWeak) { previewWeak.innerHTML = ''; previewWeak.style.display = 'none'; }

            if (previewWeakContainer) previewWeakContainer.style.display = 'block';

                // --- NEW: Populate All Cards List ---

                const allCardsList = document.getElementById('previewAllCardsList');

                const searchInput = document.getElementById('previewSearchInput');

                allCardsList.innerHTML = '';

                searchInput.value = '';

                // Helper to clear all highlights

                const clearAllHighlights = () => {

                     document.querySelectorAll('#previewStrong .card-ui, #previewWeak .card-ui, #previewAllCardsList .card-ui').forEach(c => c.style.borderColor = '');

                };

                // Patch existing items in Strong/Weak to clear All List highlights

                [previewStrong, previewWeak].forEach(container => {

                    if (!container) return;

                    Array.from(container.children).forEach(child => {

                        if (child.classList.contains('card-ui')) {

                            const originalClick = child.onclick;

                            child.onclick = (e) => {

                                clearAllHighlights(); // Clear everything first

                                if (originalClick) originalClick(e); // Then let original logic run

                            };

                        }

                    });

                });

                // Populate All Cards

                const sortedCards = Object.keys(allCards)

                    .filter(id => id !== 'tower' && id !== 'miniStoneGiant')

                    .filter(id => !allCards[id] || !allCards[id].hidden)

                    .sort((a, b) => allCards[a].name.localeCompare(allCards[b].name));

                sortedCards.forEach(cid => {

                    const el = createCardDOM(cid, true);

                    if (!el) return;

                    el.dataset.hasEvo = (allCards[cid] && allCards[cid].evo) ? 'true' : 'false';

                    el.onclick = (e) => {

                        e.stopPropagation();

                        currentPreviewOpponentId = cid;

                        clearAllHighlights();

                        el.style.borderColor = '#3b82f6'; // blue-500

                        startPreviewLoop();

                    };

                    el.dataset.searchName = allCards[cid].name.toLowerCase();

                    allCardsList.appendChild(el);

                });

                if (!searchInput.dataset.hasListener) {

                    searchInput.dataset.hasListener = 'true';

                    searchInput.addEventListener('input', () => applyPreviewListFilters(searchInput, allCardsList));

                }

                applyPreviewListFilters(searchInput, allCardsList);

                cardInfoModal.style.display = 'flex';

            }

        // Display evolution stats for a card. This helper is triggered when

        // the user clicks the "Evo Stats" button in the card info modal.

        // It replaces the contents of the stats panel with the evolution's

        // statistics, including its cycle requirement and a description of the

        // evolution's effect. If no evolution is defined for the card, this

        // function does nothing. To return to the normal stats view, the user

        // can close and reopen the card modal.

        function applyPreviewListFilters(searchInput, allCardsList) {

            if (!searchInput || !allCardsList) return;

            const term = (searchInput.value || '').toLowerCase();

            Array.from(allCardsList.children).forEach(child => {

                const matchEvo = !previewListEvoOnly || child.dataset.hasEvo === 'true';

                const matchHero = !previewListHeroOnly || child.dataset.isHero === 'true';

                const matchSearch = (child.dataset.searchName || '').includes(term);

                child.style.display = (matchEvo && matchHero && matchSearch) ? 'flex' : 'none';

            });

        }

        function showEvoStats(cardId) {

            const card = allCards[cardId];

            if (!card || !card.evo) return;

            const evo = card.evo;

            const evoStats = (evo && evo.stats) ? evo.stats : {};

            const displayLevel = currentModalCardLevel || 1;

            const levelStats = card.stats ? (card.stats[displayLevel] || {}) : {};

            const statOrder = ['health', 'damage', 'hitSpeed', 'speed', 'count', 'range'];

            const formatLabel = (key) => {

                const overrides = {

                    speed: 'Walk Speed',

                    hitSpeed: 'Hit Speed',

                    damageBoostPercent: 'Damage Boost',

                    shieldDuration: 'Shield Duration',

                    shieldHits: 'Shield Hits',

                    shieldReflect: 'Shield Reflect',

                    cloneLimit: 'Clone Limit',

                    splashRadius: 'Splash Radius',

                    splashDamage: 'Splash Damage',

                    pushRadius: 'Push Radius',

                    pushForce: 'Push Force',

                    towerBonusDamage: 'Tower Bonus Damage',

                    plantRange: 'Plant Range',

                    plantPull: 'Plant Pull',

                    plantLifetime: 'Plant Lifetime'

                };

                if (overrides[key]) return overrides[key];

                return key.charAt(0).toUpperCase() + key.slice(1).replace('_', ' ');

            };

            const formatValue = (key, value) => {

                if (value === undefined || value === null) return value;

                if ((key === 'hitSpeed' || key === 'speed' || key === 'plantLifetime') && typeof value === 'number') return `${value}s`;

                if (key === 'damageBoostPercent' || key === 'shieldReflect') return `${value}%`;

                return value;

            };

            const appendStatsBlock = (title, statsObj, includeDps = false) => {

                const keys = Object.keys(statsObj).filter(key => key !== 'barbLevel' && statsObj[key] !== undefined && statsObj[key] !== null);

                if (keys.length === 0) return false;

                html += `<div class="mt-2 font-bold text-yellow-300">${title}</div>`;

                const orderedKeys = [...statOrder, ...keys.filter(key => !statOrder.includes(key))];

                orderedKeys.forEach(key => {

                    if (!keys.includes(key)) return;

                    const value = formatValue(key, statsObj[key]);

                    html += `<div>${formatLabel(key)}: <span>${value}</span></div>`;

                });

                if (includeDps && statsObj.damage !== undefined && statsObj.hitSpeed !== undefined) {

                    const dps = (statsObj.damage / statsObj.hitSpeed).toFixed(1);

                    html += `<div>DPS: <span>${dps}</span></div>`;

                }

                return true;

            };

            let html = `<div class="font-bold text-purple-300 mb-2">Evolution Stats (Cycle: ${evo.cycle})</div>`;

            appendStatsBlock(`Base Stats (Level ${displayLevel})`, levelStats, true);

            if (card.type === 'Spell' && card.radius) {

                html += `<div>Radius: <span>${card.radius}</span></div>`;

            }

            if (Object.keys(evoStats).length > 0) {

                const evoDisplayKeys = {

                    knight: ['shieldDuration', 'shieldReflect'],

                    archer: ['splashRadius', 'splashDamage'],

                    skeletons: ['cloneLimit'],

                    barbarians: ['shieldHits'],

                    goblinGang: ['ghostDuration', 'respawnLimit']

                };

                const keyFilter = evoDisplayKeys[cardId];

                const statsToShow = keyFilter ? keyFilter.reduce((acc, key) => {

                    if (evoStats[key] !== undefined && evoStats[key] !== null) acc[key] = evoStats[key];

                    return acc;

                }, {}) : evoStats;

                appendStatsBlock('Evolved Stats', statsToShow, true);

            }

            if (evo.desc) {

                html += `<div class="mt-2 text-xs italic text-gray-400">Effect: ${evo.desc}</div>`;

            }

            if (!evo.desc && Object.keys(evoStats).length === 0) {

                html += `<div class="mt-2 text-xs italic text-gray-400">Evolves into enhanced form with special behavior.</div>`;

            }

            if (cardInfoStats) {

                cardInfoStats.innerHTML = html;

            }

        }

            // --- Tab Switching Logic ---

            const tabStats = document.getElementById('cardTabStats');

            const tabPreview = document.getElementById('cardTabPreview');

            const panelStats = document.getElementById('cardInfoStatsPanel');

            const panelPreview = document.getElementById('cardInfoPreviewPanel');

            tabStats.addEventListener('click', () => switchTab('stats'));

            tabPreview.addEventListener('click', () => switchTab('preview'));

            function switchTab(tab) {

                if(tab === 'stats') {

                    panelStats.style.display = 'block';

                    panelPreview.style.display = 'none';

                    panelPreview.classList.remove('flex');

                    tabStats.classList.add('bg-gray-600', 'text-white', 'shadow-md');

                    tabStats.classList.remove('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');

                    tabPreview.classList.remove('bg-gray-600', 'text-white', 'shadow-md');

                    tabPreview.classList.add('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');

                    stopPreviewLoop();

                } else {

                    panelStats.style.display = 'none';

                    panelPreview.style.display = 'flex';

                    tabPreview.classList.add('bg-gray-600', 'text-white', 'shadow-md');

                    tabPreview.classList.remove('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');

                    tabStats.classList.remove('bg-gray-600', 'text-white', 'shadow-md');

                    tabStats.classList.add('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');

                    startPreviewLoop();

                }

            }

            function getCardRoles(cardId) {

                const map = {

                    'knight': { strong: 'Support/Glass Cannons', weak: 'Air & Swarms' },

                    'archer': { strong: 'Air & Ground', weak: 'Splash & Burst' },

                    'giant': { strong: 'Buildings', weak: 'Swarms & Tank Killers' },

                    'goblins': { strong: 'Distraction/DPS', weak: 'Splash' },

                    'skeletons': { strong: 'Distraction', weak: 'Splash' },

                    'tinyBot': { strong: 'Killing Tanks', weak: 'Swarms' },

                    'fireball': { strong: 'Swarms & Clumps', weak: 'Tanks' },

                    'arrows': { strong: 'Low HP Swarms', weak: 'Tanks' },

                    'hut': { strong: 'Passive Pressure', weak: 'Spells' },

                    'skeletonArmy': { strong: 'Killing Tanks', weak: 'Splash' },

                    'goblinGang': { strong: 'Tanks & Air', weak: 'Splash' },

                    'spearGoblins': { strong: 'Air/Chip Damage', weak: 'Splash' },

                    'fireDragon': { strong: 'Swarms', weak: 'Single Ranged' },

                    'barbarians': { strong: 'Killing Tanks', weak: 'Splash' },

                    'battleRam': { strong: 'Buildings', weak: 'Swarms' },

                    'barbarianHut': { strong: 'Pressure', weak: 'Spells' },

                    'axeSwinger': { strong: 'Ground Swarms', weak: 'Air Units' },

                    'pigs': { strong: 'Buildings', weak: 'Splash' },

                    'farmer': { strong: 'Ground Area', weak: 'Air Units' },

                    'poison': { strong: 'Area Denial', weak: 'Fast Units' },

                    'flyingSkeletons': { strong: 'Ground Units', weak: 'Splash' },

                    'megaFlyingSkeleton': { strong: 'Killing Tanks', weak: 'Swarms' },

                    'flyingSkeletonGroup': { strong: 'Killing Tanks', weak: 'Splash' },

                    'warlock': { strong: 'Swarms', weak: 'High DPS' },

                    'mage': { strong: 'Swarms', weak: 'High DPS' },

                    'phantomKnight': { strong: 'Single Target', weak: 'Swarms' },

                    'spiritLantern': { strong: 'Support', weak: 'Spells' },

                    'zapSpirit': { strong: 'Swarms/Stun', weak: 'Ranged' },

                    'coldSpirit': { strong: 'Freeze/Stun', weak: 'Ranged' },

                    'lifeSpirit': { strong: 'Healing', weak: 'Ranged' },

                    'bombSpirit': { strong: 'Swarms', weak: 'Ranged' },

                    'anger': { strong: 'Boosting Units', weak: 'N/A' },

                    'chaosElemental': { strong: 'Killing Tanks', weak: 'Swarms' },

                    'shadowClone': { strong: 'Support', weak: 'Splash' },

                    'voidTrap': { strong: 'Area Control', weak: 'Spread Units' },

                    'stoneGiant': { strong: 'Buildings', weak: 'Swarms' },

                    'miniStoneGiant': { strong: 'Distraction', weak: 'Splash' },

                    'chaosOrb': { strong: 'Area Damage', weak: 'Tanks' },

                    'skeletonYard': { strong: 'Surprise Attack', weak: 'Poison/Splash' },

                    'titan': { strong: 'Anything Ground', weak: 'Inferno/Swarms' }

                };

                return map[cardId] || { strong: 'Specific Units', weak: 'Specific Counters' };

            }

            // Expose switchTab globally so inline onclick handlers can call it

            window.switchTab = switchTab;

            function refreshCardAbilityInfo(cardId) {

    const card = allCards[cardId];

    const ability = card?.ability;

    if (!card || !card.isSuperhero || !ability || !cardAbilityBlock) {

        hideCardAbilityInfo();

        return;

    }

    cardAbilityBlock.classList.remove('hidden');

    if (cardAbilityName) cardAbilityName.textContent = `${ability.emoji} ${ability.name}`;

    if (cardAbilityDetails) {

        const usesText = ability.uses == null ? 'âˆž' : ability.uses;

        const abilityDesc = ability.description || 'Special ability';

        cardAbilityDetails.innerHTML = `<div>${abilityDesc}</div><div class="text-xs text-yellow-300 mt-2">Cost: ${ability.cost} elixir Â· Uses: ${usesText} (preview unlimited)</div>`;

    }

    previewHeroAbilityCardId = cardId;

    previewHeroAbilityUsesLeft = null;

    previewHeroAbilityCooldown = 0;

    updatePreviewAbilityButtonState();

}

            function hideCardAbilityInfo() {

    if (cardAbilityBlock) cardAbilityBlock.classList.add('hidden');

    previewHeroAbilityCardId = null;

    previewHeroAbilityUsesLeft = null;

    previewHeroAbilityCooldown = 0;

    updatePreviewAbilityButtonState();

}

            function updatePreviewAbilityButtonState() {

    if (!cardAbilityTestButton) return;

    if (!previewHeroAbilityCardId) {

        cardAbilityTestButton.classList.add('hidden');

        if (cardAbilityTestStatus) cardAbilityTestStatus.textContent = '';

        return;

    }

    const ability = allCards[previewHeroAbilityCardId]?.ability;
    if (cardAbilityTestButton && ability && ability.name) {
        cardAbilityTestButton.textContent = `Test ${ability.name}`;
    } else if (cardAbilityTestButton) {
        cardAbilityTestButton.textContent = 'Test Ability';
    }

    if (!ability) {

        cardAbilityTestButton.classList.add('hidden');

        if (cardAbilityTestStatus) cardAbilityTestStatus.textContent = '';

        return;

    }

    cardAbilityTestButton.classList.remove('hidden');

    const ready = previewHeroAbilityCooldown <= 0;

    cardAbilityTestButton.disabled = !ready;

    if (cardAbilityTestStatus) {

        if (!ready) {

            cardAbilityTestStatus.textContent = `Ready in ${(previewHeroAbilityCooldown / 60).toFixed(1)}s`;

        } else {

            cardAbilityTestStatus.textContent = 'Ready (preview uses are unlimited)';

        }

    }

}

            function triggerPreviewHeroAbility(cardId) {
                console.log("The ability preview feature is currently disabled.");
            }

            function tickPreviewHeroAbilityCooldown(deltaSeconds) {
                // This function is now deprecated.
            }

            let previewAnimationId = null;
            let previewSimulationObjects = [];
            let currentPreviewCardId = null;
            let currentPreviewOpponentId = null;
            let previewSpellTimer = 0;
            let previewCameraY = 0;
            let previewCameraX = 0;
            let previewLaneShiftValue = 0;
            let previewCameraStartLeft = 0;
            let previewCameraStartRight = 0;
            let isPreviewActive = false;
            let isPreviewSimulationActive = false;
            let previewStarlinePhaseActive = false;
            let previewStarlinePhaseLane = null;
            let previewStarlinePhaseX = null;

            function resetPreviewStarlinePhaseState() {

                previewStarlinePhaseActive = false;

                previewStarlinePhaseLane = null;

                previewStarlinePhaseX = null;

            }

            function updatePreviewCameraForStarline(previewSceneWidth) {

                if (typeof previewSceneWidth !== 'number') return;

                const laneFocusX = previewStarlinePhaseLane === 'right' ? previewCameraStartRight : previewCameraStartLeft;

                let targetX = laneFocusX;

                if (previewStarlinePhaseActive && typeof previewStarlinePhaseX === 'number') {

                    const halfWidth = previewSceneWidth / 2;

                    targetX = Math.min(Math.max(previewStarlinePhaseX - halfWidth, previewCameraStartLeft), previewCameraStartRight);

                }

                previewCameraX = targetX;

                previewCameraY = 0;

            }

            function startPreviewLoop() {

                window.previewHeroInstance = null;
                if (previewAnimationId) cancelAnimationFrame(previewAnimationId);

                previewSimulationObjects = [];

                resetPreviewStarlinePhaseState();

                isPreviewActive = true;

                previewSpellTimer = 0;

                previewCameraX = 0;

                previewCameraY = 0;

                const previewViewOffset = 120;

                const leftCameraStart = Math.max(0, LANE_LEFT_X - previewViewOffset);

                const rightCameraStart = Math.max(0, LANE_RIGHT_X - previewViewOffset);

                const previewLaneShift = Math.max(0, rightCameraStart - leftCameraStart);

                previewCameraStartLeft = leftCameraStart;

                previewCameraStartRight = rightCameraStart;

                previewLaneShiftValue = previewLaneShift;

                previewCameraX = previewCameraStartLeft;

                if (typeof window !== 'undefined') {

                    window.onStarlineLaneSwitch = (laneKey) => {

                        previewStarlinePhaseLane = laneKey;

                    };

                    window.onStarlinePhaseStart = (laneKey) => {

                        previewStarlinePhaseActive = true;

                        previewStarlinePhaseLane = laneKey;

                        previewStarlinePhaseX = null;


                    };

                    window.onStarlinePhaseUpdate = (x, y, laneKey) => {

                        previewStarlinePhaseActive = true;

                        if (laneKey) previewStarlinePhaseLane = laneKey;

                        previewStarlinePhaseX = x;


                    };

                    window.onStarlinePhaseComplete = (laneKey) => {

                        previewStarlinePhaseActive = false;

                        previewStarlinePhaseX = null;

                        if (laneKey) previewStarlinePhaseLane = laneKey;


                    };

                }

                let previewOpponentSpellTimer = 0;

                let previewFrame = 0;

                // NEW: timers for tower preview restart and opponent spawn

                let previewResetCountdown = -1;

                let previewOpponentSpawnCountdown = -1;

                // Capture the global deltaTime before the preview loop overwrites it.

                const originalGlobalDeltaTime = deltaTime;

                // Use a dedicated timestamp for the preview loop to compute deltaTime independently of the main game

                let previewLastTime = performance.now();

                // Handle Tower Previews

                let card = allCards[currentPreviewCardId];

                let playerTowerType = 'princess';

                if (!card && towerDefs[currentPreviewCardId]) {

                    // It is a tower preview

                    card = { type: 'TowerPreview', name: towerDefs[currentPreviewCardId].name };

                    playerTowerType = currentPreviewCardId;

                }

                const opponent = currentPreviewOpponentId ? allCards[currentPreviewOpponentId] : null;


                const isOpponentKnightPreview = currentPreviewOpponentId === 'knight';

                // Switch drawing context to the preview canvas. This allows all preview drawing

                // operations to render inside the small card preview instead of the main game canvas.

                // The original game context is stored in `mainCtx` so it can be restored when the

                // preview loop stops.

                if (!previewCtx) {

                    console.error('Unable to start preview loop: preview canvas context is unavailable.');

                    return;

                }

                ctx = previewCtx;

                

                // --- Setup Simulation Board ---

                // 1. Add Towers (Arena 1 Theme)

                // Blue Princess (Bottom) - Use selected tower type if previewing tower

                const lanePositions = [LANE_LEFT_X, LANE_RIGHT_X];

                const playerTowers = lanePositions.map(x => new Tower(x, 180, 'player', false, 10, false, playerTowerType));

                const aiTowers = lanePositions.map(x => new Tower(x, 20, 'ai', false, 10));

                playerTowers.forEach(t => previewSimulationObjects.push(t));

                aiTowers.forEach(t => previewSimulationObjects.push(t));

                

                // Waffle Preview Extras

                if (currentPreviewCardId === 'waffle') {

                    // Add King Tower for Waffle Preview (off-screen normally, viewable via switch)

                    previewSimulationObjects.push(new Tower(130, 280, 'player', true, 10, false, 'waffle'));

                    // Add Friendly Unit to be buffed

                    previewSimulationObjects.push(new Knight(130, 240, 'player', 10));

                }

                const spawnX = LANE_LEFT_X;

                const blueSpawnY = 140;

                const redSpawnY = 60;

                // --- CONTEXT SWAP FOR SPAWN ---

                // We swap gameObjects to previewSimulationObjects so that Swarm classes (which push to gameObjects)

                // correctly populate the preview array instead of the main game array.

                const globalGameObjects = gameObjects;

                gameObjects = previewSimulationObjects;

                try {

                                // 2. Spawn Main Unit (Player Team) at Bottom

                                    if (card.isSuperhero) {

                                        try {

                                            const hero = new card.unitClass(spawnX, blueSpawnY, 'player', 10);

                                            if (hero instanceof GameObject) {

                                                previewSimulationObjects.push(hero);

                                                window.previewHeroInstance = hero;

                                            }

                                        } catch(e) { console.warn("Error creating preview hero", e); }

                                    } else if (card.type !== 'Spell' && card.type !== 'TowerPreview' && !card.isSuperhero) {

                        const level = 10;

                        if (card.unitClass) {

                            // Set global flags to propagate evolution to spawned units during this constructor call.  

                            // For the player unit in preview, use previewUseEvo to decide whether to spawn the evolved version.

                            try {

                                window.pendingEvoSpawn = (previewUseEvo && evolutionsUnlocked && card.evo) ? true : false;

                                window.currentSpawnCardHasEvo = window.pendingEvoSpawn;

                            } catch(e) {}

                            const unit = new card.unitClass(spawnX, blueSpawnY, 'player', level);

                            // Reset flags immediately after spawning

                            try {

                                window.pendingEvoSpawn = false;

                                window.currentSpawnCardHasEvo = false;

                            } catch(e) {}

                            // Apply special timers/effects for evolved units. Knight receives a

                            // 5â€‘second shield upon spawn that prevents damage while active.

                            if (previewUseEvo && evolutionsUnlocked && card.evo) {

                                // Knight-specific shield timer

                                if (currentPreviewCardId === 'knight') {

                                    unit.shieldTimer = 5;

                                }

                            }

                            // If it returned a Single Unit (GameObject), we push it manually.

                            // If it was a Swarm, it already pushed itself to gameObjects (aliased to previewSimulationObjects).

                            if (unit instanceof GameObject) previewSimulationObjects.push(unit);

                        }

                    } else if (currentPreviewCardId === 'diddyMiner') {

                        const previewTargetX = spawnX;

                        const previewTargetY = blueSpawnY - 30;

                        const miner = new DiddyMiner(previewTargetX, previewTargetY, 'player', 10);

                        miner.spawnX = spawnX;

                        miner.spawnY = blueSpawnY + 40;

                        miner.x = miner.spawnX;

                        miner.y = miner.spawnY;

                        miner.destX = previewTargetX;

                        miner.destY = previewTargetY;

                        miner.hasSurfaced = false;

                        miner.emergeTimer = 0;

                        miner.particleTimer = miner.particleInterval;

                        const previewDistance = getDistance({ x: miner.spawnX, y: miner.spawnY }, { x: previewTargetX, y: previewTargetY });

                        const previewNormalized = Math.min(1, previewDistance / (WIDTH * 0.75));

                        const previewBaseTravel = 180;

                        const previewExtra = 120;

                        miner.travelDuration = Math.round(Math.max(120, Math.min(320, previewBaseTravel + previewNormalized * previewExtra)));

                        previewSimulationObjects.push(miner);

                    } else {

                        previewSpellTimer = currentPreviewCardId === 'bigStick' ? 30 : 60;

                    }

                                        // 3. Spawn Opponent (AI Team) at Top

                                        if (opponent) {

                                            // If the user selected a test opponent from the list

                                            if (opponent.type !== 'Spell') {

                                                const level = 10;

                                                if (opponent.unitClass) {

                                                    // Propagate evolution to the opponent if the evo filter toggle is on (previewListEvoOnly) and the card has an evolution.  

                                                    // This ensures the opponent uses the evolved version only when the user explicitly chooses to view evolutions for test cards.

                                                    try {

                                                        window.pendingEvoSpawn = (previewListEvoOnly && evolutionsUnlocked && opponent.evo) ? true : false;

                                                        window.currentSpawnCardHasEvo = window.pendingEvoSpawn;

                                                    } catch(e) {}

                                                    const unit = new opponent.unitClass(spawnX, redSpawnY, 'ai', level);

                                                    try {

                                                        window.pendingEvoSpawn = false;

                                                        window.currentSpawnCardHasEvo = false;

                                                    } catch(e) {}

                                                    if (unit instanceof GameObject) {

                                                        if (previewListEvoOnly && isOpponentKnightPreview) {

                                                            unit.shieldTimer = 5;

                                                        }

                                                        previewSimulationObjects.push(unit);

                                                    }

                                                }

                                            } else {

                                                previewOpponentSpellTimer = 90;

                                            }

                                        } else {

                                        // No explicit opponent selected; by default do not spawn a mirrored unit.

                                        // Only spawn a demonstration tank for Machine Gun previews so users can see the slowdown effect

                                        if (currentPreviewCardId === 'machineGun') {

                                                const tank = new Giant(spawnX, redSpawnY, 'ai', 10);

                                                tank.health = 5000;

                                                tank.maxHealth = 5000;

                                                previewSimulationObjects.push(tank);

                                            }

                                        }

                } catch(e) {

                    console.warn("Preview spawn error", e);

                } finally {

                    // Restore global context immediately

                    gameObjects = globalGameObjects;

                }

                // --- Additional Preview Setup ---

                // If this is a tower preview, spawn a Knight behind the player's tower and schedule resets.

                // Otherwise, for troop previews, schedule the preview to reset after 10 seconds as well.

                if (card.type === 'TowerPreview') {

                    // Reset after 10 seconds

                    previewResetCountdown = 600;

                    // For the waffle tower preview, we already spawn an ally Knight in the extras section, so skip spawning another

                    if (currentPreviewCardId !== 'waffle') {

                        try {

                                                        // const knight = new Knight(spawnX, blueSpawnY + 20, 'player', 10);

                                                        // if (knight instanceof GameObject) previewSimulationObjects.push(knight);

                        } catch(e) {

                            console.warn('Knight spawn error in tower preview', e);

                        }

                    }

                    // If the player selected a test opponent card, schedule it to spawn after 10 seconds

                    if (currentPreviewOpponentId) {

                        previewOpponentSpawnCountdown = 600;

                    }

                } else {

                    // For troop and spell previews, reset the preview after 10 seconds

                    previewResetCountdown = 600;

                }

                function loop(timestamp) {

                    // Compute preview-specific deltaTime based on elapsed real time

                    const previewDt = (timestamp - previewLastTime) / 1000;

                    tickPreviewHeroAbilityCooldown(previewDt);

                    previewLastTime = timestamp;

                    // Temporarily override the global deltaTime so unit updates in the preview use the new dt

                    // Override global deltaTime for the preview loop; restore occurs in the finally block

                    deltaTime = previewDt;

                    // Clear the preview canvas for fresh drawing each frame

                    ctx.clearRect(0, 0, 300, 200);

                    const previewSceneWidth = 300 + Math.max(previewLaneShiftValue, 0);

                    updatePreviewCameraForStarline(previewSceneWidth);

                    ctx.save();

                    ctx.translate(-previewCameraX, -previewCameraY);

                    

                    // --- Draw Arena 1 Background (Extended for Scrolling) ---

                    ctx.fillStyle = '#15803d'; // Green Grass
                    ctx.fillRect(0, 0, previewSceneWidth, 400); // Taller for scroll

                    ctx.fillStyle = '#3b82f6'; // Blue River

                    const previewRiverY = 90;

                    ctx.fillRect(0, previewRiverY, previewSceneWidth, 20);

                    const bridgeWidth = 40;

                    const bridgeHeight = 20;

                    const drawBridge = (centerX) => {

                        ctx.fillStyle = '#a16207';

                        const previewBridgeY = previewRiverY + 10;

                        ctx.fillRect(centerX - bridgeWidth / 2, previewBridgeY - bridgeHeight / 2, bridgeWidth, bridgeHeight);

                    };

                    drawBridge(LANE_LEFT_X);

                    drawBridge(LANE_RIGHT_X);

                    // Swap Globals for Logic Update

                    const globalGameObjects = gameObjects;

                    isPreviewSimulationActive = true;

                    gameObjects = previewSimulationObjects;

                    try {

                        // Main Spell Logic

                        if (card.type === 'Spell' && previewSpellTimer > 0) {

                             previewSpellTimer--;

                             if (previewSpellTimer === 0) {

                                 const level = 10; const s = card.stats[level];

                                 // Target opponent unit if exists, else top tower

                                 let tx = 130, ty = 60;

                                 const target = gameObjects.find(o => o.team === 'ai' && o instanceof Unit);

                                 if (target) { tx = target.x; ty = target.y; }

                                 else { tx = 130; ty = 20; } // Fallback to tower

                                 if (currentPreviewCardId === 'poison') gameObjects.push(new PoisonSpell(tx, ty, 'player', s.damagePerSecond, card.radius, s.duration));

                                 else if (currentPreviewCardId === 'anger') gameObjects.push(new AngerSpell(tx, ty, 'player', card.radius, s.duration, s.damage));

                                 else if (currentPreviewCardId === 'voidTrap') gameObjects.push(new VoidTrapEffect(tx, ty, 'player', card.radius, s.damage));

                                 else if (currentPreviewCardId === 'chaosOrb') gameObjects.push(new ChaosOrbEffect(tx, ty, 'player', card.radius, s.damage));

                                 else if (currentPreviewCardId === 'skeletonYard') gameObjects.push(new SkeletonYard(tx, ty, 'player', s.duration, card.radius, 10));

                                 else if (currentPreviewCardId === 'tornado') gameObjects.push(new TornadoSpell(tx, ty, 'player', card.radius, s.duration, s.pullStrength, s.damagePerSecond, card.emoji));

                                 else if (currentPreviewCardId === 'bigStick') {

                                     const stickX = spawnX || 130;

                                     const stickY = BRIDGE_Y + 8;

                                     spawnSpellForCard('bigStick', 'player', level, stickX, stickY);

                                 } else {

                                     const isEvoSpell = previewUseEvo && evolutionsUnlocked && card.evo;

                                     gameObjects.push(new Spell(tx, ty, 'player', s.damage, card.radius, card.emoji, isEvoSpell));

                                 }

                             }

                        }

                        

                        // Opponent Spell Logic

                        if (opponent && opponent.type === 'Spell' && previewOpponentSpellTimer > 0) {

                             previewOpponentSpellTimer--;

                             if (previewOpponentSpellTimer === 0) {

                                 const level = 10; const s = opponent.stats[level];

                                 // Target player unit if exists, else bottom tower

                                 let tx = 130, ty = 140;

                                 const target = gameObjects.find(o => o.team === 'player' && o instanceof Unit);

                                 if (target) { tx = target.x; ty = target.y; }

                                 else { tx = 130; ty = 180; }

                                 

                                 if (currentPreviewOpponentId === 'poison') gameObjects.push(new PoisonSpell(tx, ty, 'ai', s.damagePerSecond, opponent.radius, s.duration));

                                 else if (currentPreviewOpponentId === 'anger') gameObjects.push(new AngerSpell(tx, ty, 'ai', opponent.radius, s.duration, s.damage));

                                 else if (currentPreviewOpponentId === 'voidTrap') gameObjects.push(new VoidTrapEffect(tx, ty, 'ai', opponent.radius, s.damage));

                                 else if (currentPreviewOpponentId === 'chaosOrb') gameObjects.push(new ChaosOrbEffect(tx, ty, 'ai', opponent.radius, s.damage));

                                 else if (currentPreviewOpponentId === 'skeletonYard') gameObjects.push(new SkeletonYard(tx, ty, 'ai', s.duration, opponent.radius, 10));

                                  else if (currentPreviewOpponentId === 'tornado') gameObjects.push(new TornadoSpell(tx, ty, 'ai', opponent.radius, s.duration, s.pullStrength, s.damagePerSecond, opponent.emoji));

                                  else if (currentPreviewOpponentId === 'bigStick') {

                                      const stickX = spawnX || 130;

                                      const stickY = BRIDGE_Y - 8;

                                      spawnSpellForCard('bigStick', 'ai', level, stickX, stickY);

                                  } else {

                                     const isEvoSpell = previewListEvoOnly && evolutionsUnlocked && opponent.evo;

                                     gameObjects.push(new Spell(tx, ty, 'ai', s.damage, opponent.radius, opponent.emoji, isEvoSpell));

                                 }

                             }

                        }

                        // Update All

                        previewSimulationObjects.forEach(o => o.update());

                        

                        // Cleanup Dead

                    // Cleanup Dead (Refactored to match main game loop pattern)

                    const newPreviewObjects = [];

                    for (const obj of previewSimulationObjects) {

                        if (obj.health > 0) {

                            newPreviewObjects.push(obj);

                            continue;

                        }

                        // Handle death effects and special spawns

                        if (obj instanceof Unit) {

                            newPreviewObjects.push(new DeathEffect(obj.x, obj.y, obj.emoji));

                        }

                        if (obj instanceof BattleRam && !obj.didHit) {

                            obj.spawnBarbs(); // This also sets health to 0, so it won't be re-added

                            // Note: spawnBarbs pushes directly to gameObjects, which is aliased to newPreviewObjects here

                        }

                        if (obj instanceof StoneGiant && !obj.didSpawnMinis) {

                            obj.spawnMinis(); // This also pushes directly

                        }

                        // Huge Skeleton specific logic

                        if (obj instanceof HugeSkeleton && !obj.droppedBomb) {

                            obj.droppedBomb = true; // Mark as dropped

                            // The GiantBomb itself should be added to the newPreviewObjects

                            newPreviewObjects.push(new GiantBomb(obj.x, obj.y, obj.team, obj.bombDamage, 100));

                        }

                        // Don't remove towers in preview, just let them sit at 0 HP

                        if (obj instanceof Tower) {

                            if (obj.health <= 0) obj.health = 0;

                            newPreviewObjects.push(obj); // Keep towers regardless of health for continuous preview

                        }

                        // Other dead objects (like spells, projectiles) are simply not pushed to newPreviewObjects.

                    }

                    previewSimulationObjects = newPreviewObjects;

                    } catch(e) { console.error("Preview Loop Error:", e); }

                    finally {

                        // Restore Globals

                        deltaTime = originalGlobalDeltaTime; // Restore global deltaTime

                        gameObjects = globalGameObjects;

                        // Removed redundant `ctx = mainCtx;` as it's handled once outside the finally block.

                    }

                    // Draw All

                    previewSimulationObjects.forEach(o => o.draw());

                    isPreviewSimulationActive = false;

                    

                    // Indicators

                    if (card.type === 'Spell' && previewSpellTimer > 0) {

                        ctx.save(); ctx.globalAlpha = 0.5; ctx.fillStyle = '#60a5fa';

                        ctx.beginPath(); ctx.arc(130, 60, card.radius, 0, Math.PI*2); ctx.fill(); ctx.restore();

                    }

                    ctx.restore(); // Restore Camera Transform

                    // --- Tower Preview Timers ---

                    // Handle scheduled opponent spawn in tower preview

                    if (previewOpponentSpawnCountdown >= 0) {

                        previewOpponentSpawnCountdown--;

                        if (previewOpponentSpawnCountdown === 0 && currentPreviewOpponentId) {

                            const oppCard = allCards[currentPreviewOpponentId];

                            if (oppCard && oppCard.unitClass && oppCard.type !== 'Spell') {

                                try {

                                    const shouldPreviewEvolveOpponent = previewListEvoOnly && evolutionsUnlocked && oppCard.evo;

                                    try {

                                        window.pendingEvoSpawn = shouldPreviewEvolveOpponent ? true : false;

                                        window.currentSpawnCardHasEvo = window.pendingEvoSpawn;

                                    } catch(e) {}

                                    const newUnit = new oppCard.unitClass(spawnX, redSpawnY, 'ai', 10);

                                    try {

                                        window.pendingEvoSpawn = false;

                                        window.currentSpawnCardHasEvo = false;

                                    } catch(e) {}

                                    if (newUnit instanceof GameObject) {

                                        if (shouldPreviewEvolveOpponent && isOpponentKnightPreview) {

                                            newUnit.shieldTimer = 5;

                                        }

                                        previewSimulationObjects.push(newUnit);

                                    }

                                } catch(e) {

                                    console.warn('Opponent spawn error in tower preview', e);

                                }

                            }

                        }

                    }

                    // Handle preview reset countdown for tower previews

                    if (previewResetCountdown >= 0) {

                        previewResetCountdown--;

                        if (previewResetCountdown === 0) {

                            // Restart the preview and exit this loop

                            startPreviewLoop();

                            return;

                        }

                    }

                    // Restart preview if a tower dies

                    for (const obj of previewSimulationObjects) {

                        if (obj instanceof Tower && obj.health <= 0) {

                            startPreviewLoop();

                            return;

                        }

                    }

                    // We deliberately do not restore the main context here. The preview loop draws

                    // exclusively to the preview canvas until stopPreviewLoop() is called.

                    previewAnimationId = requestAnimationFrame(loop);

                }

                loop(performance.now()); // Call loop for the first time with current timestamp

            }

                        function stopPreviewLoop(options = {}) {

                            window.previewHeroInstance = null;

                            if (previewAnimationId) cancelAnimationFrame(previewAnimationId);

                previewAnimationId = null;

                isPreviewActive = false;

                previewSimulationObjects = [];

                if (!options.preserveOpponent) {

                    currentPreviewOpponentId = null;

                }

                // Restore the drawing context back to the main game canvas

                if (typeof mainCtx !== 'undefined') {

                    ctx = mainCtx;

                }

                previewCameraY = 0;

                previewCameraX = 0;

                if (typeof window !== 'undefined') {

                    window.onStarlineLaneSwitch = null;

                    window.onStarlinePhaseStart = null;

                    window.onStarlinePhaseUpdate = null;

                    window.onStarlinePhaseComplete = null;

                }

                previewLaneShiftValue = 0;

                previewCameraStartLeft = 0;

                previewCameraStartRight = 0;

                resetPreviewStarlinePhaseState();

            }

            

                        function refreshPreviewAnimation() {

            

                            console.log('Refreshing preview animation.');

            

                            stopPreviewLoop({ preserveOpponent: true });

            

                            startPreviewLoop();

            

                        }

                        if (previewRefreshButton) {

                            previewRefreshButton.onclick = () => {

                                refreshPreviewAnimation();

                            };

                        }

            

            function closeModal() {

                stopPreviewLoop();

                cardInfoModal.style.display = 'none';

            }

            

            async function addToDeck(cardId) {

                const currentDeck = getDeckForMode();

                const card = allCards[cardId];

                if (card && card.isSuperhero) {

                    if (!superheroesUnlocked) {

                        alert('Superhero slot unlocks after opening the second Quarter Star box.');

                        return;

                    }

                    const heroSlotId = getHeroSlotForMode();

                    if (heroSlotId && heroSlotId !== cardId) {

                        alert('No superhero slot available. Remove the current hero before assigning another.');

                        return;

                    }

                    const cardData = cardCollection[cardId];

                    if (!cardData || !cardData.unlocked) {

                        alert('Unlock this superhero with a shard before assigning it.');

                        return;

                    }

                    if (heroSlotId === cardId) {

                        return;

                    }

                    if (currentDeck.length >= 8) {

                        alert('Deck is full (8 cards). Remove a troop before assigning a superhero.');

                        return;

                    }

                    setHeroSlotForMode(cardId);

                    renderDeckScreen();

                    updateBattleButtonState();

                    openCardModal(cardId);

                    await saveUserData();

                    return;

                }

                if (gameMode === 'emojiDash' && isEmojiDashRestrictedCard(card)) {

                    alert('Emoji Dash currently restricts swarm and building cards.');

                    return;

                }

                const heroAssigned = Boolean(getHeroSlotForMode());

                const maxCards = 8 - (heroAssigned ? 1 : 0);



                if (currentDeck.length < maxCards) {

                    currentDeck.push(cardId);

                    renderDeckScreen();

                    updateBattleButtonState();

                    openCardModal(cardId);

                    await saveUserData();

                }

            }

            async function removeFromDeck(cardId) {

                const currentDeck = getDeckForMode();

                const index = currentDeck.indexOf(cardId);

                if (index > -1) {

                    currentDeck.splice(index, 1);

                    renderDeckScreen();

                    updateBattleButtonState();

                    openCardModal(cardId);

                    await saveUserData();

                }

            }

            async function removeHeroFromSlot(cardId) {

                const heroSlotId = getHeroSlotForMode();

                if (heroSlotId !== cardId) return;

                clearHeroSlotForMode();

                renderDeckScreen();

                updateBattleButtonState();

                openCardModal(cardId);

                await saveUserData();

            }

            async function upgradeCard(cardId) {

                const cardData = cardCollection[cardId];

                const costs = upgradeCosts[cardData.level];

                if (costs && cardData.count >= costs.cards && gold >= costs.gold) {

                    cardData.count -= costs.cards;

                    gold -= costs.gold;

                    cardData.level++;

                    goldDisplay.textContent = `ðŸ’° ${gold}`;

                    renderDeckScreen();

                    openCardModal(cardId);

                    await saveUserData();

                }

            }

            function shuffleDeck(deck) {

                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;

            }

function getMatchModeKey(mode = gameMode) {

    if (mode === '2v2') return '2v2';

    if (mode === 'party1v1') return 'party1v1';

    if (mode === 'chaos') return 'chaos';

    if (mode === 'emojiDash') return 'emojiDash';

    return 'single';

}

function getDeckForMode(mode = gameMode) {

    if (mode === '2v2') return playerDeck2v2;

    if (mode === 'party1v1') return playerDeckParty;

    if (mode === 'chaos') return playerDeckChaos;

    if (mode === 'emojiDash') return playerDeckEmojiDash;

    return playerDeck;

}

            function getHeroSlotForMode(mode = gameMode) {

    if (mode === '2v2') return playerHeroSlot2v2;

    if (mode === 'party1v1') return playerHeroSlotParty;

    if (mode === 'chaos') return playerHeroSlotChaos;

    if (mode === 'emojiDash') return playerHeroSlotEmojiDash;

    return playerHeroSlot;

}

            function setHeroSlotForMode(cardId, mode = gameMode) {

    if (mode === '2v2') playerHeroSlot2v2 = cardId;

    else if (mode === 'party1v1') playerHeroSlotParty = cardId;

    else if (mode === 'chaos') playerHeroSlotChaos = cardId;

    else if (mode === 'emojiDash') playerHeroSlotEmojiDash = cardId;

    else playerHeroSlot = cardId;

}

            function clearHeroSlotForMode(mode = gameMode) {

    if (mode === '2v2') playerHeroSlot2v2 = null;

    else if (mode === 'party1v1') playerHeroSlotParty = null;

    else if (mode === 'chaos') playerHeroSlotChaos = null;

    else if (mode === 'emojiDash') playerHeroSlotEmojiDash = null;

    else playerHeroSlot = null;

}

            function spawnPlayerHero() {

    playerHeroUnit = null;

    const overrideActive = gameMode === 'new_year_new_me' && heroOverrideForEvent;

    const heroId = overrideActive ? heroOverrideForEvent : getHeroSlotForMode();

    if (!heroId) return;

    const card = allCards[heroId];

    const cardData = cardCollection[heroId];

    if (!card || !card.isSuperhero) return;

    if (!overrideActive && (!cardData || !cardData.unlocked)) return;

    const level = isMaxLevelMatch() ? 15 : (cardData?.level || 1);

    const spawnX = WIDTH / 2;

    const spawnY = HEIGHT - 130;

    try {

        const hero = new card.unitClass(spawnX, spawnY, 'player', level);

        if (hero instanceof GameObject) {

            gameObjects.push(hero);

            playerHeroUnit = hero;

        }

    } catch (err) {

        console.warn('Failed to spawn superhero', err);

    }

}

            function updateHeroAbilityPanel() {

    if (!heroAbilityPanel || !heroAbilityButton || !heroAbilityName || !heroAbilityUses) return;

    if (!playerHeroUnit || playerHeroUnit.health <= 0 || !playerHeroUnit.heroAbilityData) {

        heroAbilityPanel.classList.add('hidden');

        return;

    }

    const ability = playerHeroUnit.heroAbilityData;

    heroAbilityPanel.classList.remove('hidden');

    heroAbilityName.textContent = ability.name || 'Ability';

    const abilityLabel = [ability.emoji, ability.cost != null ? ability.cost : null].filter(Boolean).join(' ').trim() || ability.name || 'Ability';

    heroAbilityButton.textContent = abilityLabel;

    const usesLeft = typeof playerHeroUnit.heroAbilityUses === 'number' ? playerHeroUnit.heroAbilityUses : null;

    const totalUses = ability.uses;

    const usesLabel = totalUses == null ? 'âˆž' : `${Math.max(0, usesLeft ?? totalUses)}/${totalUses}`;

    if (playerHeroUnit.heroAbilityTimer > 0) {

        const cooldown = (playerHeroUnit.heroAbilityTimer / 60).toFixed(1);

        const status = totalUses == null ? 'Uses: âˆž' : `Uses: ${usesLabel}`;

        heroAbilityUses.textContent = `${status} â€¢ Cooldown ${cooldown}s`;

    } else {

        heroAbilityUses.textContent = totalUses == null ? 'Uses: âˆž' : `Uses: ${usesLabel}`;

    }

    const canUseAbility = playerHeroUnit.canUseHeroAbility();
    heroAbilityButton.disabled = !canUseAbility;
    heroAbilityButton.classList.toggle('hero-ability-btn--inactive', !canUseAbility);
    const costHint = typeof ability.cost === 'number' ? `Cost: ${ability.cost} elixir` : '';
    heroAbilityButton.title = canUseAbility ? (ability.description || costHint) : (costHint || 'Ability not ready yet.');

}

            function selectMatchEvoSlots(deck, options = {}) {

    if (!deck || !deck.length) return [];

    const desiredCount = Math.min(2, deck.length);

    if (options.preferEvoCards) {

        const slots = [];

        const usedIndices = new Set();

        for (let i = 0; i < deck.length && slots.length < desiredCount; i++) {

            const cardId = deck[i];

            const cardDef = allCards[cardId];

            if (cardDef && cardDef.evo && evoUnlockedCards && evoUnlockedCards[cardId]) {

                slots.push(cardId);

                usedIndices.add(i);

            }

        }

        for (let i = 0; i < deck.length && slots.length < desiredCount; i++) {

            if (usedIndices.has(i)) continue;

            slots.push(deck[i]);

        }

        return slots;

    }

    return deck.slice(0, desiredCount);

}

            function ensureMatchEvoSlotsForMode(modeKey) {

    if (!modeKey) return;

    let deckToUse = playerDeck;

    if (modeKey === '2v2') deckToUse = playerDeck2v2;

    else if (modeKey === 'party1v1') deckToUse = playerDeckParty;

    else if (modeKey === 'chaos') deckToUse = playerDeckChaos;

    else if (modeKey === 'emojiDash') deckToUse = playerDeckEmojiDash;

    if (!deckToUse || deckToUse.length === 0) return;

    const slotOptions = {

        preferEvoCards: modeKey === 'chaos'

    };

    matchEvoSlots[modeKey] = selectMatchEvoSlots(deckToUse, slotOptions);

}

                        

            

            function aiPlayCard(cardId) {

                if (!allCards[cardId]) return; // Safety check

                aiElixir -= allCards[cardId].cost;

                aiDiscardPile.push(cardId);

                const handIndex = aiHand.indexOf(cardId);

                if (handIndex > -1) { aiHand.splice(handIndex, 1); }

                aiHand.push(aiNextCard);

                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }

                aiNextCard = aiDeck.pop() || null;

            }

            function renderHand() {

                cardHandEl.innerHTML = '';

                hand.forEach((cardId, index) => {

                    const cardEl = createCardDOM(cardId, false, true);

                    if (!cardEl) return;

                    cardEl.dataset.handIndex = index;

                    applyCardEvoDots(cardEl, cardId);

                    // Handle touch/mouse down for card selection

                    cardEl.addEventListener('mousedown', (e) => selectCard(e, cardEl, cardId));

                    cardEl.addEventListener('touchstart', (e) => selectCard(e, cardEl, cardId), { passive: false });

                    cardHandEl.appendChild(cardEl);

                });

                nextCardSlotEl.innerHTML = '';

                if (nextCard) {

                    const nextCardEl = createCardDOM(nextCard, true, true);

                    if (nextCardEl) {

                        applyCardEvoDots(nextCardEl, nextCard);

                        nextCardSlotEl.appendChild(nextCardEl);

                    }

                }

                updateCardUI();

                refreshCardEvoIndicators();

            }

            function selectCard(e, cardEl, cardId) {

                e.preventDefault(); // Prevent scrolling/other actions

                if (!gameRunning) return;

                const card = allCards[cardId];

                const isMirror = cardId === 'mirror';

                const mirrorCost = isMirror ? getMirrorRequiredCost() : null;

                let requiredCost = card.cost;

                if (isMirror) {

                    if (mirrorCost === null) {

                        console.log('Mirror cannot replay spells or there is no previous card.');

                        return;

                    }

                    requiredCost = mirrorCost;

                }

                if (requiredCost > playerElixir) {

                    console.log(isMirror ? 'Not enough elixir for Mirror replay.' : 'Not enough elixir!');

                    return;

                }

                if (selectedSpawningUnit && selectedSpawningUnit.cardCostEl) {

                    resetMirrorCostDisplay(selectedSpawningUnit);

                }

                

                // Deselect if already selected

                if (selectedSpawningUnit && selectedSpawningUnit.id === cardId) {

                    cancelPlacement();

                    return;

                }

                // NEW: Click-to-select logic

                isDragging = false;

                let initialPos = (e.touches && e.touches[0]) ? e.touches[0] : e;

                dragStartX = initialPos.clientX;

                dragStartY = initialPos.clientY;

                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));

                placementIndicator.style.display = 'block'; // FIX: Show immediately

                const isTroopSpellPlacement = !!card.troopSpellPlacement;
                if (card.type === 'Spell' && !isTroopSpellPlacement) {

                    placementOverlay.style.display = 'none';

                } else {

                    placementOverlay.style.display = 'block'; // Show red overlay

                }

                placementIndicator.innerHTML = '';

                

                selectedSpawningUnit = {

                    id: cardId, cost: card.cost, type: card.type, radius: card.radius || 0, placementRadius: card.placementRadius,

                    emoji: card.emoji, isFlying: card.isFlying, handIndex: cardEl.dataset.handIndex

                };

                

                const treatAsSpell = card.type === 'Spell' && !isTroopSpellPlacement;

                if (treatAsSpell) {

                    isSpawningSpell = true;

                    spellRadius = card.radius;

                    placementIndicator.className = 'spell';

                    const indicatorDiameter = Math.max(70, (card.radius || 32) * 2);

                    placementIndicator.style.width = `${indicatorDiameter}px`;

                    placementIndicator.style.height = `${indicatorDiameter}px`;

                    placementIndicator.innerHTML = '';

                    placementIndicator.classList.remove('mirror-preview');

                    selectedSpawningUnit.mirrorCost = undefined;

                    selectedSpawningUnit.cardCostEl = undefined;

                    selectedSpawningUnit.originalCostText = undefined;

                    if (cardId === 'mirror') {

                        selectedSpawningUnit.cost = mirrorCost;

                        selectedSpawningUnit.mirrorCost = mirrorCost;

                        selectedSpawningUnit.cardCostEl = cardEl.querySelector('.card-ui-cost');

                        selectedSpawningUnit.originalCostText = selectedSpawningUnit.cardCostEl ? selectedSpawningUnit.cardCostEl.textContent : null;

                        if (selectedSpawningUnit.cardCostEl) {

                            selectedSpawningUnit.cardCostEl.textContent = mirrorCost;

                        }

                        placementIndicator.classList.add('mirror-preview');

                        const previousCard = lastPlayedCardByTeam.player ? allCards[lastPlayedCardByTeam.player.cardId] : null;

                        const mirrorEmoji = (previousCard && previousCard.emoji) ? previousCard.emoji : '??';

                        placementIndicator.innerHTML = `<span class="mirror-preview-emoji">${mirrorEmoji}</span>`;

                    }

                    if (cardId === 'poison') { // NEW: Poison color

                        placementIndicator.style.background = 'rgba(234, 179, 8, 0.2)';

                        placementIndicator.style.borderColor = '#eab308';

                    } else if (cardId === 'anger') { // NEW: Anger color

                        placementIndicator.style.background = 'rgba(147, 51, 234, 0.1)';

                        placementIndicator.style.borderColor = '#9333ea';

                    }

                    selectedSpawningUnit.isTroopSpell = false;

                } else {

                    isSpawningSpell = false;

                    placementRadius = card.placementRadius;

                    placementIndicator.className = '';

                    placementIndicator.style.width = `${placementRadius * 2}px`;

                    placementIndicator.style.height = `${placementRadius * 2}px`;

                    placementIndicator.innerHTML = card.emoji;

                    selectedSpawningUnit.isTroopSpell = isTroopSpellPlacement;

                }

                cardEl.classList.add('selected');

                

                // Update placement overlay based on destroyed towers

                updatePlacementOverlay();

                

                // Move indicator to initial touch/mouse position

                movePlacementIndicator(initialPos);

            }

            

            function resetMirrorCostDisplay(unit) {

                if (!unit || !unit.cardCostEl) return;

                const baseCost = allCards[unit.id]?.cost ?? unit.cost ?? '1';

                unit.cardCostEl.textContent = unit.originalCostText ?? baseCost;

                unit.cardCostEl = null;

                unit.originalCostText = null;

                unit.mirrorCost = undefined;

            }

            function cancelPlacement() {

                isSpawningSpell = false;

                placementIndicator.style.display = 'none';

                placementIndicator.style.background = 'rgba(255, 255, 255, 0.2)'; // NEW: Reset poison/anger color

                placementIndicator.style.borderColor = 'white';

                placementOverlay.style.display = 'none'; // Hide red overlay

                resetMirrorCostDisplay(selectedSpawningUnit);

                selectedSpawningUnit = null;

                isDragging = false; // NEW

                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));

                updateCardUI();

            }

            function playCard(cardId, handIndex, costOverride) {

                const costToUse = typeof costOverride === 'number' ? costOverride : allCards[cardId].cost;

                playerElixir -= costToUse;

                discardPile.push(cardId);

                hand.splice(handIndex, 1);

                hand.push(nextCard);

                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }

                nextCard = gameDeck.pop();

                renderHand();

            }

            // --- NEW: Demo Mode AI for "Player" ---

            function demoRunPlayerAI() {

                if (playerElixir < 5) return; // Don't spam

                let affordableCards = hand.filter(id => allCards[id] && allCards[id].cost <= playerElixir && allCards[id].type !== 'Spell');

                if (affordableCards.length > 0) {

                    const cardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];

                    const card = allCards[cardId];

                    const handIndex = hand.indexOf(cardId);

                    

                    // Find a valid spawn pos

                    const x = LANE_LEFT_X + Math.random() * (LANE_RIGHT_X - LANE_LEFT_X);

                    const y = RIVER_Y + 20 + Math.random() * 100; // Player's side

                    if (checkPlacement(x, y, card.placementRadius, card.type)) {

                        const level = isMaxLevelMatch() ? 15 : 5; // Demo level, force 15 in 2v2

                        // Safety check: ensure unitClass exists

                        if (!card.unitClass || typeof card.unitClass !== 'function') {

                            console.error('Invalid unitClass for card:', cardId, card);

                            return;

                        }

                        const newUnit = new card.unitClass(x, y, 'player', level);

                        if (newUnit instanceof GameObject) {

                            gameObjects.push(newUnit);

                        }

                        playCard(cardId, handIndex);

                    }

                }

            }

            // ==============================================

            // GAME OBJECTS (CLASSES)

            // ==============================================

                        class GameObject {

                constructor(x, y, radius, team, health) { 

                    this.x = x; this.y = y; this.radius = radius; this.team = team; this.health = health; this.maxHealth = health; this.id = Math.random(); 

                    // Visual Effects

                    this.spawnTimer = 0;

                    this.spawnMax = 12;

                    this.prevHealth = health;

                    this.hitFlashTimer = 0;

                }

                                drawHealthBar(level) {

                    const barWidth = this.radius * 2; 

                    const barHeight = 5; 

                    const barX = this.x - this.radius; 

                    // Adjusted barY to make space for health text

                    const barY = this.y - this.radius - (this instanceof Tower ? (this.isKing ? 15 : 10) : 12); 

                    

                    // Simple Shadow for bar

                    ctx.fillStyle = 'rgba(0,0,0,0.5)';

                    ctx.fillRect(barX + 1, barY + 1, barWidth, barHeight);

                    if (this.health < this.maxHealth) {

                        ctx.fillStyle = '#7f1d1d'; // Dark Red bg

                        ctx.fillRect(barX, barY, barWidth, barHeight); 

                        ctx.fillStyle = '#22c55e'; 

                        ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); 

                    } else {

                        ctx.fillStyle = '#22c55e'; 

                        ctx.fillRect(barX, barY, barWidth, barHeight); 

                    }

                    // Black outline

                    ctx.strokeStyle = 'black';

                    ctx.lineWidth = 1;

                    ctx.strokeRect(barX, barY, barWidth, barHeight);

                    

                    let levelTextY = null;

                    if (level) {

                        ctx.font = 'bold 11px Inter';

                        ctx.textAlign = 'center';

                        ctx.textBaseline = 'bottom';

                        ctx.lineWidth = 3;

                        ctx.strokeStyle = 'black';

                        ctx.fillStyle = this.team === 'player' ? '#fff' : '#fcd34d'; 

                        let textX = this.x;

                        levelTextY = barY - 2; // Position level text slightly above the bar

                        if (this.isCombinedDoubleKing) levelTextY = this.y - this.height/2 - 14;

                        ctx.strokeText(`Lvl ${level}`, textX, levelTextY);

                        ctx.fillText(`Lvl ${level}`, textX, levelTextY);

                    }

                    // NEW: Draw health text ONLY for towers

                    if (this instanceof Tower) {

                        ctx.font = 'bold 10px Inter'; // Slightly smaller font for health

                        ctx.textAlign = 'center';

                        ctx.textBaseline = 'top'; // Align to top of text, so Y is the top edge

                        ctx.fillStyle = 'white';

                        ctx.strokeStyle = 'black';

                        ctx.lineWidth = 2;

                        const healthText = `${Math.round(this.health)}`; // Show current health only

                        let healthTextY;

                        if (this.isCombinedDoubleKing) {

                            // The combined king tower is drawn with height `this.radius * 1.6` centered at `this.y`.

                            // So its bottom edge is `this.y + (this.radius * 1.6 / 2)`.

                            healthTextY = this.y + (this.radius * 1.6 / 2) + 5; // 5px below the bottom of the drawn rect

                        } else {

                            // Standard towers are drawn with height `this.radius * 2` centered at `this.y`.

                            // So its bottom edge is `this.y + this.radius`.

                            healthTextY = this.y + this.radius + 5; // 5px below the bottom of the drawn rect

                        }

                        

                        ctx.strokeText(healthText, this.x, healthTextY);

                        ctx.fillText(healthText, this.x, healthTextY);

                    }

                }

                draw(color, emoji, level) { 

                    // Spawn Animation Logic

                    let scale = 1;

                    if (this.spawnTimer < this.spawnMax) {

                        this.spawnTimer++;

                        const t = this.spawnTimer / this.spawnMax;

                        // Elastic pop effect

                        scale = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                        if (scale > 1.2) scale = 1.2;

                        if (t >= 1) scale = 1;

                    }

                    ctx.save();

                    ctx.translate(this.x, this.y);

                    ctx.scale(scale, scale);

                    

                    // Check Damage for Flash

                    if (this.health < this.prevHealth) {

                        this.hitFlashTimer = 5;

                        this.prevHealth = this.health;

                    }

                    // Shadow

                    ctx.beginPath();

                    ctx.ellipse(0, this.radius * 0.4, this.radius, this.radius * 0.4, 0, 0, Math.PI*2);

                    ctx.fillStyle = 'rgba(0,0,0,0.3)';

                    ctx.fill();

                    // Unit Body

                    ctx.beginPath(); 

                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2); 

                    ctx.fillStyle = color; 

                    

                    // Hit Flash Override

                    if (this.hitFlashTimer > 0) {

                        ctx.fillStyle = '#ffffff';

                        this.hitFlashTimer--;

                    }

                    ctx.fill(); 

                    ctx.strokeStyle = 'black'; 

                    ctx.lineWidth = 2; 

                    ctx.stroke(); 

                    

                    if (emoji) { 

                        ctx.font = `${this.radius * 1.5}px Arial`; 

                        ctx.textAlign = 'center'; 

                        ctx.textBaseline = 'middle'; 

                        // No shadow for text inside to keep clean

                        ctx.fillText(emoji, 0, 0); 

                    }

                    ctx.restore(); // Restore scale/translate

                    this.drawHealthBar(level); 

            }

            update() {}

        }

        class CloneSpell extends GameObject {

            constructor(x, y, team, radius) {

                super(x, y, radius, team, 1);

                this.duration = 45;

                this.lifetime = this.duration;

                this.spawned = false;

            }

            spawnClones() {

                for (const obj of gameObjects) {

                    if (obj === this) continue;

                    if (!(obj instanceof Unit)) continue;

                    if (obj.team !== this.team) continue;

                    if (obj.health <= 0) continue;

                    if (obj.isSpellClone) continue;

                    if (getDistance(this, obj) > this.radius + (obj.radius || 0)) continue;

                    try {

                        const clone = new obj.constructor(obj.x + (Math.random() - 0.5) * 10, obj.y + (Math.random() - 0.5) * 10, this.team, obj.level);

                        if (clone instanceof GameObject) {

                            clone.isSpellClone = true;

                            clone.maxHealth = 1;

                            clone.health = 1;

                            clone._cloneOrigin = obj.constructor.name;

                            gameObjects.push(clone);

                        }

                    } catch (err) {

                        console.warn('Clone spawn failed', err);

                    }

                }

            }

            update() {

                if (!this.spawned) {

                    this.spawned = true;

                    this.spawnClones();

                }

                this.lifetime -= deltaTime * 60;

                if (this.lifetime <= 0) {

                    this.health = 0;

                }

            }

            draw() {

                const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.4;

                ctx.save();

                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);

                gradient.addColorStop(0, `rgba(14, 165, 233, ${alpha})`);

                gradient.addColorStop(1, 'rgba(14, 165, 233, 0)');

                ctx.fillStyle = gradient;

                ctx.beginPath();

                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                ctx.fill();

                ctx.strokeStyle = `rgba(236, 72, 153, ${alpha})`;

                ctx.lineWidth = 3;

                ctx.beginPath();

                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                ctx.stroke();

                ctx.restore();

            }

        }

        class GoblinHexEffect extends GameObject {

            constructor(x, y, team, radius, duration, damagePerSecond) {

                super(x, y, radius, team, 1);

                this.duration = (duration || 6) * 60;

                this.lifetime = this.duration;

                this.damagePerSecond = damagePerSecond || 30;

                this.tickInterval = 15;

                this.tickTimer = this.tickInterval;

                this.trackedTargets = new Set();

            }

            update() {

                const frameDelta = Math.max(1, deltaTime * 60);

                this.lifetime -= frameDelta;

                if (this.lifetime <= 0) {

                    this.cleanup();

                    this.health = 0;

                    return;

                }

                this.tickTimer -= frameDelta;

                if (this.tickTimer <= 0) {

                    this.tickTimer = this.tickInterval;

                    const tickDamage = Math.max(1, Math.round(this.damagePerSecond * (this.tickInterval / 60)));

                    for (const obj of gameObjects) {

                        if (!obj || obj.team === this.team) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Building) && !(obj instanceof Tower)) continue;

                        const dist = getDistance(this, obj);

                        const threshold = this.radius + (obj.radius || 0);

                        if (dist <= threshold) {

                            applyDamage(obj, tickDamage);

                            obj._goblinHexSource = this;

                            obj._goblinHexInside = true;

                            obj._goblinHexSpawned = obj._goblinHexSpawned || false;

                            this.trackedTargets.add(obj);

                        } else if (obj._goblinHexSource === this) {

                            obj._goblinHexInside = false;

                            obj._goblinHexSource = null;

                            obj._goblinHexSpawned = false;

                            this.trackedTargets.delete(obj);

                        }

                    }

                }

            }

            spawnGoblinFrom(target) {

                if (!target) return;

                this.trackedTargets.delete(target);

                target._goblinHexSource = null;

                target._goblinHexInside = false;

                target._goblinHexSpawned = true;

                const x = target.x;

                const y = target.y;

                const level = Math.min(15, Math.max(1, (target.level || 1)));

                const spawnPerUnit = 1;

                for (let i = 0; i < spawnPerUnit; i++) {

                    const offsetX = (Math.random() - 0.5) * 18;

                    const offsetY = (Math.random() - 0.5) * 18;

                    const goblin = new Goblin(x + offsetX, y + offsetY, this.team, level);

                    if (goblin instanceof GameObject) {

                        gameObjects.push(goblin);

                    }

                }

            }

            cleanup() {

                this.trackedTargets.forEach(obj => {

                    if (obj) {

                        obj._goblinHexInside = false;

                        if (obj._goblinHexSource === this) obj._goblinHexSource = null;

                    }

                });

                this.trackedTargets.clear();

            }

            draw() {

                const progress = Math.max(0, Math.min(1, this.lifetime / this.duration));

                const alpha = Math.sin(progress * Math.PI) * 0.35;

                ctx.save();

                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);

                gradient.addColorStop(0, `rgba(16, 185, 129, ${alpha * 0.8})`);

                gradient.addColorStop(1, 'rgba(5, 150, 105, 0)');

                ctx.fillStyle = gradient;

                ctx.beginPath();

                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                ctx.fill();

                ctx.strokeStyle = `rgba(5, 150, 105, ${alpha})`;

                ctx.lineWidth = 2;

                ctx.beginPath();

                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                ctx.stroke();

                ctx.restore();

            }

        }

        class DeathEffect extends GameObject {

                constructor(x, y, emoji) {

                    super(x, y, 0, 'neutral', 1);

                    this.emoji = emoji;

                    this.timer = 20;

                    this.rise = 0;

                }

                update() {

                    this.timer--;

                    this.rise += 1;

                    if (this.timer <= 0) this.health = 0;

                }

                draw() { 

                    ctx.save(); 

                    ctx.globalAlpha = this.timer / 20;

                    ctx.font = '24px Arial';

                    ctx.textAlign = 'center';

                    ctx.fillStyle = 'black'; // Shadow

                    ctx.fillText(this.emoji || 'ðŸ’€', this.x, this.y - this.rise);

                    ctx.restore();

                }

            }

            class ParticleExplosion extends GameObject {

                constructor(x, y, color) {

                    super(x, y, 0, 'neutral', 1);

                    this.particles = [];

                    // Bigger and more particles

                    for(let i=0; i<12; i++) {

                        const angle = (Math.PI * 2 * i) / 12;

                        this.particles.push({ 

                            x: 0, y: 0, 

                            vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,

                            life: 20,

                            size: 4 + Math.random() * 4

                        });

                    }

                    this.color = color || '#ffc107';

                }

                update() {

                    let active = false;

                    this.particles.forEach(p => {

                        p.x += p.vx;

                        p.y += p.vy;

                        p.life--;

                        if (p.life > 0) active = true;

                    });

                    if (!active) this.health = 0;

                }

                draw() {

                    ctx.save();

                    ctx.translate(this.x, this.y);

                    ctx.fillStyle = this.color;

                    this.particles.forEach(p => {

                        if (p.life > 0) {

                            ctx.globalAlpha = p.life / 20;

                            ctx.beginPath();

                            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);

                            ctx.fill();

                        }

                    });

                    ctx.restore();

                }

            }

            class DamageText extends GameObject {

                constructor(x, y, damage) {

                    super(x, y, 0, 'neutral', 1);

                    this.damage = Math.floor(damage);

                    this.life = 40;

                    this.maxLife = 40;

                    this.vY = -1.5;

                    this.vX = (Math.random() - 0.5) * 1;

                }

                update() {

                    this.life--;

                    this.x += this.vX;

                    this.y += this.vY;

                    if (this.life <= 0) this.health = 0;

                }

                draw() {

                    ctx.save();

                    const alpha = Math.max(0, this.life / 20);

                    ctx.globalAlpha = alpha;

                    ctx.font = 'bold 16px Inter';

                    ctx.fillStyle = '#ef4444';

                    ctx.strokeStyle = 'white';

                    ctx.lineWidth = 2;

                    ctx.textAlign = 'center';

                    ctx.strokeText(`-${this.damage}`, this.x, this.y);

                    ctx.fillText(`-${this.damage}`, this.x, this.y);

                    ctx.restore();

                }

            }

            const goblinGangGhostPending = {};

            let goblinGangGroupIdCounter = 1;

            function applyDamage(target, amount, options = {}) {

                if (target && target.health > 0) {

                if (typeof DiddyMiner !== 'undefined' && target instanceof DiddyMiner && !target.hasSurfaced) {

                    return;

                }

                if (target.isSpellImmune && !options.ignoreSpellImmunity) {

                    return;

                }

                if (target.isBarricade) {

                    return;

                }

                    // If the target has shield hits remaining (e.g., evolved Barbarians), consume

                    // one shield and ignore the damage for this hit.  We still show damage

                    // numbers so the hit is visible.

                    if (target.shieldHitsRemaining && target.shieldHitsRemaining > 0) {

                        target.shieldHitsRemaining--;

                        if (amount > 0) {

                            gameObjects.push(new DamageText(target.x, target.y - (target.radius || 10), amount));

                        }

                        return;

                    }

                    // If the target has an active shield (e.g., evolved Knight) then

                    // ignore the damage entirely. Do not subtract health while the

                    // shield timer is above zero. This prevents the target from

                    // losing health during the shield duration. We still show

                    // damage text so the user sees the hit but it does no harm.

                    if (target.shieldTimer && target.shieldTimer > 0) {

                        // Show small reflected damage text at the target to indicate the hit was blocked

                        if (amount > 0) {

                            gameObjects.push(new DamageText(target.x, target.y - (target.radius || 10), amount));

                        }

                        return;

                    }

                    const sourceType = options.sourceType;

                    if (target instanceof Zombie) {

                        if (sourceType === 'tower' && target.requiresTwoTowerHits) {

                            target._towerHitsTaken = (target._towerHitsTaken || 0) + 1;

                            if (target._towerHitsTaken < 2) {

                                return;

                            }

                            target._towerHitsTaken = 0;

                        } else if (sourceType !== 'tower' && target._towerHitsTaken) {

                            target._towerHitsTaken = 0;

                        }

                    }

                    target.health -= amount;

                    if (amount > 0) {

                        gameObjects.push(new DamageText(target.x, target.y - (target.radius || 10), amount));

                    }

                    if (target.health <= 0) {

                        const groupId = target.goblinGangGroupId;

                        if (groupId && target.isEvolved) {

                            spawnGoblinGangGhost(target);

                        }

                        const hexSource = target._goblinHexSource;

                        if (hexSource && target._goblinHexInside && !target._goblinHexSpawned) {

                            hexSource.spawnGoblinFrom(target);

                        }

                    }

                }

            }

            function spawnZapTrail(source, chain, color = '#7dd3fc', duration = 25) {

                if (!source || !chain || chain.length === 0) return;

                const points = [{ x: source.x, y: source.y }];

                chain.forEach(node => {

                    points.push({ x: node.x, y: node.y });

                });

                gameObjects.push(new ZapTrailEffect(points, color, duration));

            }

            function applyZapFreeze(target, durationSeconds = 0.9) {

                if (!target || target.health <= 0) return;

                const frames = Math.max(1, Math.round(durationSeconds * 60));

                target.zapFreezeTimer = Math.max(target.zapFreezeTimer || 0, frames);

                if (target.speed !== undefined) {

                    if (target._zapOriginalSpeed === undefined) {

                        target._zapOriginalSpeed = target.speed;

                    }

                    target.speed = 0;

                }

                if (target.cooldownTimer !== undefined) {

                    if (target._zapOriginalCooldown === undefined) {

                        target._zapOriginalCooldown = target.cooldownTimer;

                    }

                    target.cooldownTimer = frames;

                }

                target.frozen = true;

                if (target.target) {

                    target.target = null;

                }

                if (typeof target.rampLevel === 'number') {

                    target.rampLevel = 0;

                }

            }

            function applyTemporarySlow(target, factor = 0.6, durationSeconds = 0.5) {

                if (!target || target.health <= 0) return;

                if (target.speed !== undefined && target.speed > 0) {

                    gameObjects.push(new TemporarySlowEffect(target, factor, durationSeconds));

                }

                if (target.cooldownTimer !== undefined) {

                    target.cooldownTimer = Math.max(target.cooldownTimer, Math.round(durationSeconds * 60));

                }

            }

            class WaffleProjectile extends GameObject {

                constructor(x, y, target) {

                    super(x, y, 6, 'neutral', 1);

                    this.target = target;

                    this.speed = 4;

                }

                update() {

                    if (!this.target || this.target.health <= 0) { this.health = 0; return; }

                    const dist = getDistance(this, this.target);

                    if (dist < this.speed) {

                        // Level up logic

                        if (this.target instanceof Unit) {

                             this.target.level = (this.target.level || 1) + 1;

                             gameObjects.push(new DamageText(this.target.x, this.target.y - 30, "UP!"));

                             // Recalculate stats based on new level if possible, or just heal full

                             this.target.health = this.target.maxHealth; // Simple bonus: full heal

                        }

                        this.health = 0;

                        return;

                    }

                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                    this.x += Math.cos(angle) * this.speed * (deltaTime * 60);

                    this.y += Math.sin(angle) * this.speed * (deltaTime * 60);

                }

                draw() {

                    ctx.font = '20px Arial';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.fillText('ðŸ§‡', this.x, this.y);

                }

            }

            class Tower extends GameObject {

                constructor(x, y, team, isKing = false, level = 1, isCombinedDoubleKing = false, type = 'princess') {

                    const base = towerStats[level] || towerStats[1];

                    const def = towerDefs[type] || towerDefs['princess'];

                    

                    // Apply mods only to non-king towers (except for ability inheritance)

                    const hMod = isKing ? 1 : def.healthMod;

                    const dMod = isKing ? 1 : def.dmgMod;

                    const sMod = isKing ? 1 : def.speedMod;

                    const width = isCombinedDoubleKing ? 40 : (isKing ? 25 : 20);

                    const height = isCombinedDoubleKing ? 35 : (isKing ? 25 : 20);

                    super(x, y, width, team, (isKing ? base.kingHealth : base.princessHealth) * hMod);

                    

                    this.machineGunTimer = 0;

                    this.type = type;

                    this.def = def;

                    this.isKing = isKing;

                    this.isCombinedDoubleKing = isCombinedDoubleKing;

                    this.height = height;

                    this.level = level;

                    this.attackRange = 150;

                    this.attackDamage = base.damage * dMod;

                    this.baseAttackCooldown = (base.hitSpeed * sMod) * 60;

                    this.attackCooldown = this.baseAttackCooldown;

                    this.cooldownTimer = 0;

                    this.target = null;

                    this.isActive = isKing ? false : true;

                    this.activationAnimation = 0;

                    this.dyingAnimationTimer = 0;

                    

                    // Special timers

                    this.waffleTimer = 25 * 60;

                    // Machine Gun State

                    this.mgState = 'ready'; // 'ready' (bursting) or 'recharging'

                    this.mgTimer = 180; // 3s burst capacity initially

                }

                

update() {
    if (this.health <= 0) return;

    if (this.zapFreezeTimer > 0) {
        this.zapFreezeTimer -= deltaTime * 60;
        if (this.zapFreezeTimer > 0) return;

        this.zapFreezeTimer = 0;
        if (this._zapOriginalCooldown !== undefined) {
            this.cooldownTimer = this._zapOriginalCooldown;
            delete this._zapOriginalCooldown;
        }
        this.frozen = false;
    }

    if (this.cooldownTimer > 0) {
        this.cooldownTimer -= deltaTime * 60;
    }

    // Waffle Ability (King Only)
    if (this.isKing && this.def.special === 'waffle') {
        if (this.waffleTimer > 0) this.waffleTimer -= deltaTime * 60;

        if (this.waffleTimer <= 0) {
            const friend = gameObjects.find(o => o.team === this.team && o instanceof Unit);
            if (friend) {
                gameObjects.push(new WaffleProjectile(this.x, this.y, friend));
                this.waffleTimer = 25 * 60;
            }
        }
    }



                    // Machine Gun Logic (Non-King)

                    if (!this.isKing && this.def.special === 'burst') {

                        if (this.mgState === 'ready') {

                            this.attackCooldown = 15; // 0.25s Fast Fire

                            if (this.target) {

                                this.mgTimer -= deltaTime * 60;

                                if (this.mgTimer <= 0) {

                                    this.mgState = 'recharging';

                                    this.mgTimer = 600; // 10s recharge

                                    this.cooldownTimer = 90; // Force immediate slow delay

                                }

                            }

                        } else {

                            this.attackCooldown = 90; // 1.5s Slow Fire

                            this.mgTimer -= deltaTime * 60;

                            if (this.mgTimer <= 0) {

                                this.mgState = 'ready';

                                this.mgTimer = 180; // Reset to 3s burst

                            }

                        }

                    }

                    let kingNeedsToActivate = false;

                    if (this.isKing) {

                        const princessTowersDown = gameObjects.filter(t => t.team === this.team && !t.isKing && t.health > 0).length === 0;

                        if (princessTowersDown || this.health < this.maxHealth) {

                            if (!this.isActive) { 

                                this.isActive = true; 

                                this.activationAnimation = 30; 

                            }

                            kingNeedsToActivate = true;

                        }

                        if (!kingNeedsToActivate) return;

                    }

                    if (this.isActive) {

                        this.findTarget();

                        if (this.target && this.cooldownTimer <= 0) { this.attack(); }

                    }

                }

                findTarget() { 

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) { return; } 

                    this.target = null; 

                    let closestDist = this.attackRange; 

                    for (const obj of gameObjects) { 

                        if (obj.team !== this.team && (obj instanceof Unit)) {

                            if (obj.isTargetable === false) continue;

                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                            const dist = getDistance(this, obj); 

                            if (dist < closestDist) { 

                                closestDist = dist; 

                                this.target = obj; 

                            } 

                        } 

                    } 

                }

                attack() { 

                    if (this.target) { 

                        if (this.isCombinedDoubleKing) {

                            const offset = 8;

                            gameObjects.push(new Projectile(this.x - offset, this.y, this.target, this.team, this.attackDamage, 0, 'tower')); 

                            gameObjects.push(new Projectile(this.x + offset, this.y, this.target, this.team, this.attackDamage, 0, 'tower')); 

                        } else {

                            // Visuals for different towers

                            if (this.def.special === 'rocket') {

                                 // Rocket logic: Create projectile with Rocket emoji

                                 const p = new Projectile(this.x, this.y, this.target, this.team, this.attackDamage, 0, 'tower');

                                 p.radius = 8; // Bigger

                                 p.speed = 3; // Slower

                                 gameObjects.push(p);

                                 // We don't have emoji support in Projectile class yet, relies on draw color. 

                                 // Let's leave as standard projectile for stability but high dmg.

                            } else {

                                  gameObjects.push(new Projectile(this.x, this.y, this.target, this.team, this.attackDamage, 0, 'tower')); 

                            }

                        }

                        this.cooldownTimer = this.attackCooldown; 

                    } 

                }

                draw() { 

                    ctx.save(); 

                    // Enhanced Tower Visuals

                    const baseColor = this.team === 'player' ? '#1e3a8a' : '#7f1d1d'; // Darker base

                    const mainColor = this.team === 'player' ? '#3b82f6' : '#ef4444'; // Main color

                    const highlight = this.team === 'player' ? '#60a5fa' : '#f87171'; // Highlight

                    

                    // Shake effect if dying

                    if (this.dyingAnimationTimer > 0) { 

                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 

                        const shakeX = (Math.random() - 0.5) * 4; 

                        const shakeY = (Math.random() - 0.5) * 4; 

                        ctx.translate(shakeX, shakeY);

                    }

                    if (this.isCombinedDoubleKing) {

                        // Double King Tower logic (simplified for now but using new colors)

                        const w = this.radius * 2.5;

                        const h = this.radius * 1.6;

                        ctx.fillStyle = baseColor;

                        ctx.fillRect(this.x - w/2, this.y - h/2 + 5, w, h); // Shadow/Base

                        ctx.fillStyle = mainColor;

                        ctx.fillRect(this.x - w/2, this.y - h/2, w, h);

                        ctx.strokeStyle = '#000';

                        ctx.lineWidth = 2;

                        ctx.strokeRect(this.x - w/2, this.y - h/2, w, h);

                        

                        // Battlements

                        const batW = w / 5;

                        ctx.fillStyle = mainColor;

                        for(let i=0; i<5; i+=2) {

                             ctx.fillRect(this.x - w/2 + i*batW, this.y - h/2 - 6, batW, 6);

                             ctx.strokeRect(this.x - w/2 + i*batW, this.y - h/2 - 6, batW, 6);

                        }

                        const emojiSpacing = this.radius * 0.8;

                        ctx.font = `${this.radius * 0.8}px Arial`;

                        ctx.textAlign = 'center'; 

                        ctx.textBaseline = 'middle';

                        ctx.fillText('ðŸ‘‘', this.x - emojiSpacing/2, this.y);

                        ctx.fillText('ðŸ‘‘', this.x + emojiSpacing/2, this.y);

                    } else {

                        // Standard Tower Visuals (Castle Style)

                        const w = this.radius * 2;

                        const h = this.radius * 2;

                        

                        // REMOVED Darker Base Shadow as requested

                        // Main Body

                        ctx.fillStyle = mainColor;

                        ctx.fillRect(this.x - this.radius, this.y - this.radius, w, h);

                        

                        // 3D Highlight (Left side)

                        ctx.fillStyle = highlight;

                        ctx.fillRect(this.x - this.radius, this.y - this.radius, 4, h);

                        // Stone Texture (Horizontal Lines)

                        ctx.fillStyle = 'rgba(0,0,0,0.2)';

                        ctx.fillRect(this.x - this.radius, this.y - this.radius + h/3, w, 2);

                        ctx.fillRect(this.x - this.radius, this.y - this.radius + 2*h/3, w, 2);

                        // Battlements (Top)

                        const batW = w / 3;

                        const batH = 8;

                        ctx.fillStyle = mainColor;

                        // Left Battlement

                        ctx.fillRect(this.x - this.radius, this.y - this.radius - batH, batW/2, batH);

                        ctx.strokeRect(this.x - this.radius, this.y - this.radius - batH, batW/2, batH);

                        // Middle Battlement

                        ctx.fillRect(this.x - batW/4, this.y - this.radius - batH, batW/2, batH);

                        ctx.strokeRect(this.x - batW/4, this.y - this.radius - batH, batW/2, batH);

                        // Right Battlement

                        ctx.fillRect(this.x + this.radius - batW/2, this.y - this.radius - batH, batW/2, batH);

                        ctx.strokeRect(this.x + this.radius - batW/2, this.y - this.radius - batH, batW/2, batH);

                        // Border

                        ctx.strokeStyle = '#000';

                        ctx.lineWidth = 2;

                        ctx.strokeRect(this.x - this.radius, this.y - this.radius, w, h);

                        

                        // Door (for King Tower) or Window

                        if (this.isKing) {

                             ctx.fillStyle = '#4b2e2e'; // Dark wood

                             ctx.beginPath();

                             ctx.arc(this.x, this.y + this.radius, this.radius/2.5, Math.PI, 0);

                             ctx.fill();

                        }

                        // Emoji

                        const emoji = this.isKing ? 'ðŸ‘‘' : (this.def.emoji || 'ðŸ‘¸');

                        ctx.font = `${this.radius * 1.3}px Arial`;

                        ctx.textAlign = 'center'; 

                        ctx.textBaseline = 'middle';

                        ctx.fillText(emoji, this.x, this.y - 2);

                    }

                    

                    // Draw activation animation

                    if (this.activationAnimation > 0) { 

                        this.activationAnimation--; 

                        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 * (this.activationAnimation / 30)})`; 

                        ctx.beginPath(); 

                        ctx.arc(this.x, this.y, this.radius + 15, 0, Math.PI * 2); 

                        ctx.fill(); 

                    }

                    // Draw Machine Gun Bar

                    if (!this.isKing && this.def.special === 'burst') {

                        ctx.fillStyle = '#4b5563'; ctx.fillRect(this.x - 15, this.y - 40, 30, 4);

                        if (this.mgState === 'ready') {

                            // Bursting: Green bar draining

                            const p = Math.max(0, this.mgTimer / 180);

                            ctx.fillStyle = '#22c55e'; ctx.fillRect(this.x - 15, this.y - 40, 30 * p, 4);

                        } else {

                            // Recharging: Orange bar filling up

                            const p = Math.max(0, (600 - this.mgTimer) / 600);

                            ctx.fillStyle = '#f97316'; ctx.fillRect(this.x - 15, this.y - 40, 30 * p, 4);

                        }

                        // Border

                        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(this.x - 15, this.y - 40, 30, 4);

                    }

                    // Draw Waffle Bar

                    if (this.isKing && this.def.special === 'waffle') {

                        const p = Math.max(0, this.waffleTimer / (25 * 60));

                        ctx.fillStyle = '#4b5563'; ctx.fillRect(this.x - 20, this.y - 50, 40, 6);

                        ctx.fillStyle = '#f59e0b'; ctx.fillRect(this.x - 20, this.y - 50, 40 * (1-p), 6);

                    }

                    

                    this.drawHealthBar(this.level);

                    ctx.restore(); 

                }

        }

            class Building extends GameObject {

                constructor(x, y, team, level = 1, cardId) {

                    const s = allCards[cardId].stats[level];

                    super(x, y, 20, team, s.health);

                    this.level = level; // Store level

                    this.maxLifetime = parseFloat(s.lifetime) * 60;

                    this.lifetime = this.maxLifetime;

                    this.dyingAnimationTimer = 0;

                    this.spawnTimer = 0;

                    this.spawnRate = parseFloat(s.spawn_speed) * 60;

                    this.spawnLevel = level;

                    this.cardId = cardId;

                    this.emoji = allCards[cardId].emoji;

                }

                update() { 

                    if (this.health <= 0) return; 

                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */ 

                    

                    // --- BUILDING HEALTH DECAY FIX ---

                    // Calculate health decay per frame and subtract it

                    const decayPerFrame = this.maxHealth / this.maxLifetime;

                    this.health -= decayPerFrame * (deltaTime * 60);

                    // --- END FIX ---

                    

                    if (this.lifetime <= 0 || this.health <= 0) { // Check both

                        this.health = 0; 

                        return; 

                    } 

                    

                    this.spawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */

                    if (this.spawnTimer <= 0) {

                        let unitToSpawn = null;

                        if (this.cardId === 'hut') unitToSpawn = Goblin;

                        if (this.cardId === 'barbarianHut') unitToSpawn = Barbarian;

                        

                        if (unitToSpawn) {

                            gameObjects.push(new unitToSpawn(this.x + (Math.random()*10-5), this.y + (Math.random()*10-5), this.team, this.spawnLevel));

                        }

                        this.spawnTimer = this.spawnRate; 

                    } 

                }

                draw() { 

                    ctx.save(); 

                    if (this.dyingAnimationTimer > 0) { 

                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 

                        const shakeX = (Math.random() - 0.5) * 4; 

                        const shakeY = (Math.random() - 0.5) * 4; 

                        ctx.translate(shakeX, shakeY); 

                    } 

                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 

                    ctx.fillStyle = color; 

                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 

                    ctx.strokeStyle = 'black'; 

                    ctx.lineWidth = 2; 

                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 

                    ctx.font = `${this.radius * 1.5}px Arial`; 

                    ctx.textAlign = 'center'; 

                    ctx.textBaseline = 'middle'; 

                    ctx.fillText(this.emoji, this.x, this.y); 

                    this.drawHealthBar(this.level); // Pass level

                    ctx.restore(); 

                }

            }

            class GoblinHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'hut'); } }

            class BarbarianHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'barbarianHut'); } }

            class Coral extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'coral');

                    const baseStats = allCards['coral'].stats[level];

                    const spawnSpeed = baseStats ? parseFloat(baseStats.spawn_speed) || 3 : 3;

                    this.waveSpawnRate = Math.max(1, spawnSpeed) * 60;

                    this.waveSpawnTimer = this.waveSpawnRate;

                }

                update() {

                    if (this.health <= 0) return;

                    super.update();

                    this.waveSpawnTimer -= deltaTime * 60;

                    if (this.waveSpawnTimer <= 0 && this.health > 0) {

                        const waveRadius = allCards['waveSpirit']?.stats?.[this.spawnLevel]?.radius || 8;

                        const coralRadius = this.radius || (allCards['coral']?.stats?.[this.spawnLevel]?.radius || 18);

                        const minSeparation = coralRadius + waveRadius + 8;

                        const angle = Math.random() * Math.PI * 2;

                        const distance = minSeparation + Math.random() * 12;

                        const spawnX = this.x + Math.cos(angle) * distance;

                        const spawnY = this.y + Math.sin(angle) * distance;

                        gameObjects.push(new WaveSpirit(spawnX, spawnY, this.team, this.spawnLevel));

                        this.waveSpawnTimer += this.waveSpawnRate;

                    }

                }

            }

            /* Diddyâ€™s Brigade classes are relocated to after all unit definitions. */

            class Unit extends GameObject {

                constructor(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, isFlying = false, targetsAir = false, level = 1, aggroRange = 100) {

                    super(x, y, radius, team, health);

                    this.level = level; // Store level

                    this.speed = speed * (typeof UNIT_SPEED_MULTIPLIER !== 'undefined' ? UNIT_SPEED_MULTIPLIER : 1);

                    this.attackRangeBase = attackRange;

                    this.isMeleeUnit = !isFlying && attackRange <= (radius + 20);

                    const meleeAttackBuffer = 10;

                    this.attackRange = this.attackRangeBase + (this.isMeleeUnit ? meleeAttackBuffer : 0);

                    this.attackDamage = attackDamage;

                    this.attackCooldown = attackCooldown * 60;

                    this.cooldownTimer = 0;

                    this.target = null;

                    this.isTargetable = true;

                    this.emoji = emoji;

                    this.isFlying = isFlying;

                    this.targetsAir = targetsAir;

                    this.aggroRange = aggroRange; // NEW

                    // NEW: Shield timer for evolved units (e.g., Knight). When greater than 0,

                    // the unit will ignore incoming damage. Measured in seconds and decremented

                    // each update cycle. Set elsewhere when spawning evolved units.

                    this.shieldTimer = 0;

                    // NEW: Shield hit counter for evolved Barbarians. When above 0, each

                    // incoming hit will consume one shield before damaging health. This

                    // property is set to 2 on evolved Barbarians when they first update.

                    this.shieldHitsRemaining = 0;

                    // NEW: Flag to mark whether this unit is evolved. Set to false by

                    // default. The preview system or card placement logic may set

                    // `window.pendingEvoSpawn` and `window.currentSpawnCardHasEvo` just

                    // before instantiating this unit. If those flags are set and the

                    // originating card actually has an evolution defined, mark this unit

                    // as evolved automatically here.  This ensures that groups like

                    // Skeletons, Goblins and Barbarians properly receive the evolved

                    // state for all their members.

                    this.isEvolved = false;

                    try {

                        if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                            this.isEvolved = true;

                        }

                    } catch (e) {

                        // In some contexts `window` may not be defined (e.g. server-side),

                        // so silently ignore the error.

                    }

                    this.recentlyThrownTarget = null;

                    this.recentThrowTimer = 0;

                }

                findTarget(forceFindTower = false) { // Add parameter

                    // --- NEW AGGRO AI (FIX) ---

                    let closestDist = this.aggroRange;

                    let bestTarget = null;

                    

                    // 1. Find closest troop, building, OR TOWER in aggro range

                    for (const obj of gameObjects) {

                        // --- THIS IS THE FIX ---

                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                            if (this.recentThrowTimer > 0 && obj === this.recentlyThrownTarget) continue;

                            if (obj.isTargetable === false) continue;

                            // Skip invisible Phantom Knights

                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                            // --- END FIX ---

                            if (!this.targetsAir && obj.isFlying) continue; 

                            

                            const dist = getDistance(this, obj);

                            if (dist < closestDist) {

                                closestDist = dist;

                                bestTarget = obj;

                            }

                        }

                    }

                    

                    // 2. If we found a distraction, return it.

                    if (bestTarget) {

                        return bestTarget;

                    }

        

                    // 3. If no troop/building in range, AND we are forced to (e.g., target died)

                    if (forceFindTower) {

                        let closestTowerDist = Infinity;

                        let towerTarget = null;

                        // Find closest Princess Tower in its lane

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {

                                if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {

                                    const dist = getDistance(this, obj);

                                    if (dist < closestTowerDist) { 

                                        closestTowerDist = dist; 

                                        towerTarget = obj; 

                                    }

                                }

                            }

                        }

                        // If no lane tower, find King

                        if (!towerTarget) {

                            for (const obj of gameObjects) {

                                if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {

                                    const dist = getDistance(this, obj);

                                    if (dist < closestTowerDist) { 

                                        closestTowerDist = dist; 

                                        towerTarget = obj; 

                                    }

                                }

                            }

                        }

                        return towerTarget; // Return the tower

                    }

                    

                    // 4. If no distraction and not forced, return null (keep current target)

                    return null;

                    // --- END AI FIX ---

                }

                move() {

                    if (!this.target || this.frozen) return; // NEW: Don't move if frozen

                    const dist = getDistance(this, this.target);

                    if (dist <= this.attackRange) { return; }

                    let targetX = this.target.x;

                    let targetY = this.target.y;

                    if (!this.isFlying) {

                        const needsToCross = (this.team === 'player' && this.y > RIVER_Y && this.target.y < RIVER_Y) || (this.team === 'ai' && this.y < RIVER_Y && this.target.y > RIVER_Y);

                        if (needsToCross) {

                            

                            let bridgeX = (this.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;

                            // FIX: This was the bug. It was pathing to the target's bridge, not its own.

                            // if(this.target.x < WIDTH / 2) bridgeX = LANE_LEFT_X;

                            // else bridgeX = LANE_RIGHT_X;

                            

                            if ( (this.team === 'player' && this.y > (RIVER_Y + 10)) || (this.team === 'ai' && this.y < (RIVER_Y - 10)) ) {

                                targetX = bridgeX;

                                targetY = BRIDGE_Y;

                            }

                        }

                    }

                let angle = Math.atan2(targetY - this.y, targetX - this.x);

                this.x += Math.cos(angle) * this.speed * (deltaTime * 60); /* Scale movement by delta time */

                this.y += Math.sin(angle) * this.speed * (deltaTime * 60);

                if (!this.isFlying) {
                    for (const obj of gameObjects) {
                        if (!obj || obj === this || obj.health <= 0) continue;
                        if (!obj.isBarricade) continue;
                        const minDist = this.radius + (obj.radius || 0) + 1;
                        const distToBarricade = getDistance(this, obj);
                        if (distToBarricade < minDist) {
                            const overlap = minDist - distToBarricade;
                            if (overlap > 0) {
                                const pushDir = Math.atan2(this.y - obj.y, this.x - obj.x) || 0;
                                this.x += Math.cos(pushDir) * overlap;
                                this.y += Math.sin(pushDir) * overlap;
                            }
                        }
                    }
                }

                // Keep units within the arena bounds.
                const radiusLimit = Math.max(0, this.radius || 0);
                const minX = radiusLimit;
                const maxX = Math.max(minX, WIDTH - radiusLimit);
                const minY = radiusLimit;
                const maxY = Math.max(minY, HEIGHT - radiusLimit);
                this.x = Math.max(minX, Math.min(this.x, maxX));
                this.y = Math.max(minY, Math.min(this.y, maxY));

            }

                findClosestEnemyInRange(range = 200) {

                    let best = null;

                    let shortest = range;

                    for (const obj of gameObjects) {

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Tower) && !(obj instanceof Building)) continue;

                        const dist = getDistance(this, obj);

                        if (dist > range) continue;

                        if (dist < shortest) {

                            shortest = dist;

                            best = obj;

                        }

                    }

                    return best;

                }

                attack() { 

                    // Only attack when cooldown is ready and a valid target exists

                    if (this.target && this.cooldownTimer <= 0) { 

                        // Cannot hit invisible Phantom Knights

                        if (this.target instanceof PhantomKnight && this.target.isInvisible) {

                            return;

                        }

                        // Determine base damage and whether this is a melee or ranged attack

                        let damage = this.attackDamage;

                        let splash = 0;

                        const isMelee = this.isMeleeUnit || (this.attackRange <= this.radius + this.target.radius + 5);

                        // Apply evolution effects on damage or splash

                        if (this.isEvolved) {

                            // Goblin: increase damage by 25% per hit

                            if (this instanceof Goblin) {

                                if (!this.damageMultiplier) this.damageMultiplier = 1;

                                damage = this.attackDamage * this.damageMultiplier;

                                this.damageMultiplier *= 1.25;

                            }

                            // Archer: arrows deal splash damage

                            if (this instanceof Archer) {

                                splash = 20; // small splash radius for evolved archer

                            }

                        }

                        if (isMelee) {

                            // If the target is an evolved Knight with an active shield, reflect

                            // damage back to the attacker instead of damaging the Knight.

                            if (this.target instanceof Knight && this.target.isEvolved && this.target.shieldTimer > 0) {

                                applyDamage(this, damage);

                            } else {

                                applyDamage(this.target, damage);

                            }

                            // Skeleton evolution: clone on hit up to 10 skeletons total per team

                            if (this.isEvolved && this instanceof Skeleton) {

                                const groupId = this.skeletonGroupId;

                                const trackingGroup = groupId !== undefined && groupId !== null;

                                // Count skeletons on this team (limit per group when available)

                                let count = 0;

                                for (const obj of gameObjects) {

                                    if (obj instanceof Skeleton && obj.team === this.team) {

                                        if (!trackingGroup || obj.skeletonGroupId === groupId) {

                                            count++;

                                        }

                                    }

                                }

                                if (count < 10) {

                                    // Spawn a new skeleton near the attacker

                                    try {

                                        const newSkel = new Skeleton(this.x + (Math.random() * 10 - 5), this.y + (Math.random() * 10 - 5), this.team, this.level);

                                        if (trackingGroup) newSkel.skeletonGroupId = groupId;

                                        newSkel.isEvolved = true;

                                        newSkel.shieldTimer = 0;

                                        gameObjects.push(newSkel);

                                    } catch(e) {

                                        console.warn('Evolved skeleton clone error', e);

                                    }

                                }

                            }

                            // Barbarian evolution: shields absorb first two hits. Handle in applyDamage via shieldHitsRemaining property

                        } else {

                            // Ranged attack: if target has an evolved Knight shield, reflect damage to attacker instead

                            if (this.target instanceof Knight && this.target.isEvolved && this.target.shieldTimer > 0) {

                                applyDamage(this, damage);

                            } else {

                                // Normal ranged attack: use projectile

                                let projectileType = Projectile;

                                // Fire Dragon uses FireballProjectile and inherent splash

                                if (this.emoji === 'ðŸ²') {

                                    projectileType = FireballProjectile;

                                    splash = allCards['fireDragon'].stats[this.level].splashRadius;

                                }

                                // Other units: splash radius set above if evolved Archer

                                gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash)); 

                            }

                        } 

                        this.cooldownTimer = this.attackCooldown; 

                    } 

                } 

                update() {

                if (this.health <= 0) return;

                if (this.isCarriedByBone) {

                    this.x = this.isCarriedByBone.x;

                    this.y = this.isCarriedByBone.y;

                    return;

                }

                if (this.handleZapFreeze()) return;

                if (this._fisherSlowTimer && this._fisherSlowTimer > 0) {

                    this._fisherSlowTimer -= deltaTime * 60;

                    if (this._fisherSlowTimer <= 0) {

                        this._fisherSlowTimer = 0;

                        if (this._fisherOriginalSpeed !== undefined) {

                            this.speed = this._fisherOriginalSpeed;

                            delete this._fisherOriginalSpeed;

                        }

                        if (this._fisherOriginalAttackCooldown !== undefined) {

                            this.attackCooldown = this._fisherOriginalAttackCooldown;

                            delete this._fisherOriginalAttackCooldown;

                        }

                    }

                }

                // Decrement shield timer if active

                    if (this.shieldTimer && this.shieldTimer > 0) {

                        this.shieldTimer -= deltaTime;

                        if (this.shieldTimer < 0) this.shieldTimer = 0;

                    }

                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */

                    // NEW: Don't update if frozen

                    if (this.frozen) return;

                    // --- AGGRO FIX ---

                    // 1. If we have a target and are in attack range, just attack. DO NOT look for new targets.

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {

                        this.attack();

                        return; // <-- This is the key. Stop update here.

                    }

                    

                    // 2. We are not in attack range. Check for new distractions.

                    let distraction = this.findTarget(false); // 'false' means only scan aggro range

                    

                    // 3. If a distraction exists...

                    if (distraction) {

                        // ...and we don't have a target OR the distraction is closer than our current target

                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {

                            this.target = distraction;

                        }

                    } else {

                        // 4. No distraction. Check if our long-distance target is dead/gone

                        if (!this.target || this.target.health <= 0) {

                            this.target = this.findTarget(true); // Find a new tower

                        }

                        // 5. We have a valid long-distance target (troop, building, or tower), just keep it.

                    }

                    // --- END AI FIX ---

                    if (this.target && this.target.health > 0) {

                        const distToTarget = getDistance(this, this.target);

                        if (distToTarget <= this.attackRange) {

                            resolveUnitCollision(this);

                            this.attack();

                        } else {

                            this.move();

                            resolveUnitCollision(this);

                        }

                    }

                }

                handleZapFreeze() {

                    if (this.zapFreezeTimer > 0) {

                        this.zapFreezeTimer -= deltaTime * 60;

                        if (this.zapFreezeTimer <= 0) {

                            this.zapFreezeTimer = 0;

                            this.frozen = false;

                            if (this._zapOriginalSpeed !== undefined) {

                                this.speed = this._zapOriginalSpeed;

                                delete this._zapOriginalSpeed;

                            }

                            if (this._zapOriginalCooldown !== undefined) {

                                this.cooldownTimer = this._zapOriginalCooldown;

                                delete this._zapOriginalCooldown;

                            }

                            return false;

                        }

                        return true;

                    }

                    return false;

                }

                draw() { 

                    const color = this.team === 'player' ? '#60a5fa' : '#f87171'; 

                    super.draw(color, this.emoji, this.level);

                    // NEW: Draw purple effect for angered units

                    if (this.isAngered) {

                        ctx.save();

                        ctx.strokeStyle = '#9333ea'; // purple-600

                        ctx.lineWidth = 3;

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);

                        ctx.stroke();

                        ctx.restore();

                    }

                    // NEW: Draw rainbow outline for evolved units

                    if (this.isEvolved) {

                        ctx.save();

                        const gradient = ctx.createLinearGradient(this.x - this.radius - 4, this.y - this.radius - 4, this.x + this.radius + 4, this.y + this.radius + 4);

                        gradient.addColorStop(0, '#c084fc'); // purple

                        gradient.addColorStop(0.25, '#ec4899'); // pink

                        gradient.addColorStop(0.5, '#facc15'); // yellow

                        gradient.addColorStop(0.75, '#4ade80'); // green

                        gradient.addColorStop(1, '#38bdf8'); // blue

                        ctx.strokeStyle = gradient;

                        ctx.lineWidth = 4;

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);

                        ctx.stroke();

                        ctx.restore();

                    }

                    // NEW: Draw shield aura for units with an active timed shield (e.g., evolved Knight)

                    if (this.shieldTimer && this.shieldTimer > 0) {

                        ctx.save();

                        ctx.strokeStyle = 'rgba(125, 211, 252, 0.8)'; // light blue

                        ctx.lineWidth = 3;

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, this.radius + 8, 0, Math.PI * 2);

                        ctx.stroke();

                        ctx.restore();

                    }

                    // NEW: Draw shield aura for units with shield hits remaining (e.g., evolved Barbarians)

                    if (this.shieldHitsRemaining && this.shieldHitsRemaining > 0) {

                        ctx.save();

                        ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)'; // gold-yellow

                        ctx.lineWidth = 3;

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);

                        ctx.stroke();

                        ctx.restore();

                    }

                    if (this._zombieMark) {

                        ctx.save();

                        const auraColor = this._zombieMark.type === 'necromancer' ? 'rgba(16, 185, 129, 0.85)' : 'rgba(34, 197, 94, 0.7)';

                    ctx.strokeStyle = auraColor;

                    ctx.lineWidth = 3;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius + 8, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

                if (this.isSpellClone) {

                    ctx.save();

                    ctx.strokeStyle = 'rgba(56, 189, 248, 0.8)';

                    ctx.lineWidth = 3;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            }

            function tryRiverJump(unit, jumpDelay = 1, jumpDuration = 20, jumpHeight = 45) {

                if (!unit || unit.isFlying || !unit.target) return false;

                if (!unit._riverJumpState) {

                    unit._riverJumpState = {

                        isPreparing: false,

                        isJumping: false,

                        prepTimer: 0,

                        jumpProgress: 0,

                        jumpDuration: jumpDuration,

                        jumpHeight: jumpHeight,

                        jumpStartX: 0,

                        jumpStartY: 0,

                        jumpTargetX: 0,

                        jumpTargetY: 0

                    };

                }

                const state = unit._riverJumpState;

                const needsToCross = (unit.team === 'player' && unit.y > RIVER_Y && unit.target.y < RIVER_Y)

                    || (unit.team === 'ai' && unit.y < RIVER_Y && unit.target.y > RIVER_Y);

                if (!needsToCross) {

                    state.isPreparing = false;

                    state.isJumping = false;

                    return false;

                }

                const bridgeX = (unit.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;

                const bridgeY = BRIDGE_Y;

                const nearBridgeLane = Math.abs(unit.x - bridgeX) < 35 && Math.abs(unit.y - bridgeY) < 45;

                if (nearBridgeLane) {

                    state.isPreparing = false;

                    state.isJumping = false;

                    return false;

                }

                const nearRiver = Math.abs(unit.y - RIVER_Y) < 40;

                if (state.isJumping) {

                    state.jumpProgress += (deltaTime * 60) / state.jumpDuration;

                    if (state.jumpProgress >= 1) {

                        state.isJumping = false;

                        unit.x = state.jumpTargetX;

                        unit.y = state.jumpTargetY;

                    } else {

                        const arc = state.jumpHeight * 4 * state.jumpProgress * (1 - state.jumpProgress);

                        unit.x = state.jumpStartX + (state.jumpTargetX - state.jumpStartX) * state.jumpProgress;

                        unit.y = state.jumpStartY + (state.jumpTargetY - state.jumpStartY) * state.jumpProgress - arc;

                    }

                    return true;

                }

                if (state.isPreparing) {

                    state.prepTimer -= deltaTime * 60;

                    if (state.prepTimer <= 0) {

                        state.isPreparing = false;

                        state.isJumping = true;

                        state.jumpProgress = 0;

                        state.jumpDuration = jumpDuration;

                        state.jumpHeight = jumpHeight;

                    }

                    return true;

                }

                if (nearRiver) {

                    state.isPreparing = true;

                    state.prepTimer = jumpDelay * 60;

                    state.jumpStartX = unit.x;

                    state.jumpStartY = unit.y;

                    state.jumpTargetX = bridgeX;

                    state.jumpTargetY = unit.team === 'player' ? RIVER_Y - 25 : RIVER_Y + 25;

                    return true;

                }

                return false;

            }

            function resolveUnitCollision(unit) {

                if (!unit || unit.isFlying) return;

                const pushFactor = 0.6;

                for (const other of gameObjects) {

                    if (other === unit || !(other instanceof Unit)) continue;

                    if (other.isFlying) continue;

                    if (unit.ignoresTroops && other instanceof Unit) continue;

                    if (other.ignoresTroops && unit instanceof Unit) continue;

                    const dx = unit.x - other.x;

                    const dy = unit.y - other.y;

                    const dist = Math.hypot(dx, dy);

                    const minDist = unit.radius + other.radius + 2;

                    if (dist > 0 && dist < minDist) {

                        const overlap = minDist - dist;

                        const normX = dx / dist;

                        const normY = dy / dist;

                        const ratio = other.radius / (unit.radius + other.radius || 1);

                        const push = overlap * pushFactor;

                        const unitIsGiant = (unit instanceof Giant) || (unit instanceof ElixirGiant);

                        const otherIsGiant = (other instanceof Giant) || (other instanceof ElixirGiant);

                        if (unitIsGiant && !otherIsGiant) {

                            const giantPush = push * 1.5;

                            other.x -= normX * giantPush;

                            other.y -= normY * giantPush;

                            continue;

                        }

                        if (!unitIsGiant && otherIsGiant) {

                            const giantPush = push * 1.5;

                            unit.x += normX * giantPush;

                            unit.y += normY * giantPush;

                            continue;

                        }

                        const unitPushMultiplier = unitIsGiant ? (1 + ratio) : (0.5 + ratio);

                        unit.x += normX * push * unitPushMultiplier;

                        unit.y += normY * push * unitPushMultiplier;

                        if (other.radius > unit.radius && !otherIsGiant) {

                            const backPush = push * Math.max(0.1, 0.25 - Math.min(0.2, ratio));

                            other.x -= normX * backPush;

                            other.y -= normY * backPush;

                        }

                    }

                }

            }

            function spawnPoisonCloud(x, y, team, durationSeconds = 3, damagePerSecond = null, radius = 52, troopsOnly = true) {

                if (isPreviewActive || isPreviewSimulationActive) return;

                const poisonStats = allCards['poison']?.stats?.[1] || {};

                const dps = damagePerSecond !== null ? damagePerSecond : (poisonStats.damagePerSecond || 40);

                const cloudRadius = radius || 52;

                gameObjects.push(new PoisonSpell(x, y, team, dps, cloudRadius, durationSeconds, troopsOnly));

            }

            function markUnitAsZombie(target, sourceTeam, markType = 'necromancer', options = {}) {

                if (!target || target.health <= 0 || !(target instanceof Unit)) return;

                if (target.team === sourceTeam) return;

                if (target instanceof Tower || target instanceof Building) return;

                target._zombieMark = {

                    team: sourceTeam,

                    type: markType,

                    level: options.level || target.level || 1,

                    nerf: !!options.nerf,

                    count: options.count || 1,

                    templateCard: options.templateCard,

                    variant: options.variant || markType

                };

            }

            function spawnMarkedZombie(deadUnit) {

                if (!deadUnit || !deadUnit._zombieMark) return;

                const mark = deadUnit._zombieMark;

                const spawnTeam = mark.team || deadUnit.team;

                const spawnLevel = Math.max(1, Math.min(15, mark.level || 1));

                const variantCard = mark.templateCard || (mark.variant === 'necromancer' ? 'necromancerZombie' : 'deathSpiritZombie');

                const spawnOptions = {

                    nerf: !!mark.nerf,

                    templateCard: variantCard,

                    variant: mark.variant

                };

                for (let i = 0; i < (mark.count || 1); i++) {

                    const offsetX = (Math.random() * 16 - 8);

                    const offsetY = (Math.random() * 16 - 8);

                    gameObjects.push(new Zombie(deadUnit.x + offsetX, deadUnit.y + offsetY, spawnTeam, spawnLevel, spawnOptions));

                }

                delete deadUnit._zombieMark;

            }

            class Knight extends Unit { constructor(x, y, team, level = 1) { const s = allCards['knight'].stats[level]; super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'âš”ï¸', false, false, level, allCards['knight'].aggroRange); } }

            class Archer extends Unit { constructor(x, y, team, level = 1) { const s = allCards['archer'].stats[level]; super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'ðŸ¹', false, true, level, allCards['archer'].aggroRange); } }

            

            class Giant extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['giant'].stats[level];

                    super(x, y, 18, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'ðŸ’ª', false, false, level, allCards['giant'].aggroRange);

                    this.targetLocked = false;

                }

                findTarget() {

                    // --- BUILDING-TARGETING AI FIX ---

        

                    // 1. Find the default tower target (closest tower in lane, or king)

                    let closestTowerDist = Infinity;

                    let towerTarget = null;

        

                    // Find closest Princess Tower in its lane

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {

                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) { 

                                    closestTowerDist = dist; 

                                    towerTarget = obj; 

                                }

                            }

                        }

                    }

                    // If no lane tower, find King

                    if (!towerTarget) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) { 

                                    closestTowerDist = dist; 

                                    towerTarget = obj; 

                                }

                            }

                        }

                    }

        

                    // 2. Find the closest building (as a potential distraction)

                    let closestBuildingDist = Infinity;

                    let buildingTarget = null;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Building)) {

                            const dist = getDistance(this, obj);

                            if (dist < closestBuildingDist) { 

                                closestBuildingDist = dist; 

                                buildingTarget = obj; 

                            }

                        }

                    }

        

                    // 3. Decide: Is the building a valid, closer distraction?

                    // Use Infinity if no tower target exists

                    const towerDist = towerTarget ? closestTowerDist : Infinity;

                    

                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {

                        // Attack the building

                        this.target = buildingTarget;

                    } else {

                        // No valid distraction, attack the tower

                        this.target = towerTarget;

                    }

                    

                    this.targetLocked = (this.target != null);

                    // --- END AI FIX ---

                }

                // FIX: Add custom update to ONLY use building-find logic

                update() {

                    if (this.health <= 0) return;

                    if (this.handleZapFreeze()) return;

                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */

                    

                    // --- TARGET LOCK-ON FIX (FOR REAL) ---

                    // 1. If we have a target and are in attack range, just attack.

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {

                        this.attack();

                        return; // Lock in combat

                    }

    

                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)

                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {

                         this.findTarget(); // This will find a tower OR a closer building

                    }

                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.

                    // --- END AI FIX ---

    

                    if (this.target && this.target.health > 0) {

                        // (This check is redundant, but safe)

                        if (getDistance(this, this.target) <= this.attackRange) {

                            this.attack();

                        } else {

                            this.move();

                        }

                    }

                }

            }

            class Goblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; super(x, y, 8, team, s.health, 1.2, 20, s.damage, s.hitSpeed, 'ðŸ‘º', false, false, level, allCards['goblins'].aggroRange); this.damageMultiplier = 1; } } // Speed 1.5 -> 1.2

            class Skeleton extends Unit { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; super(x, y, 7, team, s.health, 1.4, 20, s.damage, s.hitSpeed, 'ðŸ’€', false, false, level, allCards['skeletons'].aggroRange); } } // Speed 1.6 -> 1.4

            class TinyBot extends Unit { constructor(x, y, team, level = 1) { const s = allCards['tinyBot'].stats[level]; super(x, y, 10, team, s.health, 1.0, 25, s.damage, s.hitSpeed, 'ðŸ¤–', false, false, level, allCards['tinyBot'].aggroRange); } } // Speed 1.2 -> 1.0

            let nextSkeletonGroupId = 1;

            class Goblins { constructor(x, y, team, level = 1) {

                const s = allCards['goblins'].stats[level];

                for (let i = 0; i < s.count; i++) {

                    const g = new Goblin(x + Math.random()*10 - 5, y + Math.random()*10 - 5, team, level);

                    // Propagate evolution state to each goblin if pendingEvoSpawn is set

                    try {

                        if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                            g.isEvolved = true;

                        }

                    } catch(e) {}

                    gameObjects.push(g);

                }

            } }

            class Skeletons { constructor(x, y, team, level = 1) {

                const s = allCards['skeletons'].stats[level];

                const groupId = nextSkeletonGroupId++;

                for (let i = 0; i < s.count; i++) {

                    const sk = new Skeleton(x + Math.random()*10 - 5, y + Math.random()*10 - 5, team, level);

                    sk.skeletonGroupId = groupId;

                    try {

                        if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                            sk.isEvolved = true;

                            sk.shieldTimer = 0;

                        }

                    } catch(e) {}

                    gameObjects.push(sk);

                }

            } }

            

            // --- NEW CARD CLASSES ---

            class SpearGoblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; super(x, y, 8, team, s.spear_health, 1.2, 100, s.spear_damage, s.spear_hitSpeed, 'ðŸŽ¯', false, true, level, allCards['goblinGang'].aggroRange); } } // Speed 1.5 -> 1.2

            class GoblinGang {

                constructor(x, y, team, level = 1) {

                    const s = allCards['goblinGang'].stats[level];

                    const groupId = goblinGangGroupIdCounter++;

                    // Dagger goblins

                    for (let i = 0; i < s.count; i++) {

                        const g = new Goblin(x + Math.random() * 15 - 7, y + Math.random() * 15 - 7, team, level);

                        g.goblinGangGroupId = groupId;

                        g.goblinGangRespawnType = 'dagger';

                        try {

                            if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                                g.isEvolved = true;

                            }

                        } catch(e) {}

                        gameObjects.push(g);

                    }

                    // Spear goblins

                    for (let i = 0; i < s.spear_count; i++) {

                        const sg = new SpearGoblin(x + Math.random() * 15 - 7, y + Math.random() * 15 - 7, team, level);

                        sg.goblinGangGroupId = groupId;

                        sg.goblinGangRespawnType = 'spear';

                        try {

                            if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                                sg.isEvolved = true;

                            }

                        } catch(e) {}

                        gameObjects.push(sg);

                    }

                }

            }

            class GoblinGangGhost extends GameObject {

                constructor(x, y, team, groupId, respawnType = 'dagger', level = 1) {

                    super(x, y, 8, team, 1);

                    this.groupId = groupId;

                    this.respawnType = respawnType;

                    this.spawnLevel = Math.max(1, level);

                    const ghostSeconds = (allCards['goblinGang']?.evo?.stats?.ghostDuration) || 3;

                    this.respawnTimer = Math.max(1, Math.round(ghostSeconds * 60));

                    this.isTargetable = false;

                }

                update() {

                    if (this.health <= 0) return;

                    const anchor = findGoblinGangAnchor(this.groupId);

                    if (anchor) {

                        const followSpeed = Math.max(0.05, 0.1 * (deltaTime * 60));

                        this.x += (anchor.x - this.x) * followSpeed;

                        this.y += (anchor.y - this.y) * followSpeed;

                    }

                    this.respawnTimer -= deltaTime * 60;

                    if (this.respawnTimer <= 0) {

                        if (!hasAliveGoblinGangMember(this.groupId)) {

                            this.cleanup();

                        } else {

                            this.respawn();

                        }

                    }

                }

                respawn() {

                    const spawnClass = this.respawnType === 'spear' ? SpearGoblin : Goblin;

                    const spawnX = this.x + (Math.random() - 0.5) * 12;

                    const spawnY = this.y + (Math.random() - 0.5) * 12;

                    try {

                        const newUnit = new spawnClass(spawnX, spawnY, this.team, this.spawnLevel);

                        newUnit.goblinGangGroupId = this.groupId;

                        newUnit.goblinGangRespawnType = this.respawnType;

                        newUnit.isEvolved = true;

                        gameObjects.push(newUnit);

                    } catch (err) {

                        console.warn('Goblin gang respawn failed', err);

                    }

                    this.cleanup();

                }

                cleanup() {

                    goblinGangGhostPending[this.groupId] = false;

                    this.health = 0;

                }

                draw() {

                    ctx.save();

                    ctx.globalAlpha = 0.5;

                    ctx.fillStyle = this.team === 'player' ? '#a8fff7' : '#ffc9e0';

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.strokeStyle = '#ffffff';

                    ctx.lineWidth = 1.5;

                    ctx.stroke();

                    ctx.font = '20px Arial';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.fillStyle = '#1f2937';

                    ctx.fillText('ðŸ‘»', this.x, this.y);

                    ctx.restore();

                }

            }

            function hasAliveGoblinGangMember(groupId, exclude = null) {

                return gameObjects.some(obj => obj !== exclude && obj.goblinGangGroupId === groupId && obj.health > 0);

            }

            function findGoblinGangAnchor(groupId) {

                return gameObjects.find(obj => obj.goblinGangGroupId === groupId && obj.health > 0);

            }

            function spawnGoblinGangGhost(deadGoblin) {

                if (!deadGoblin) return;

                const groupId = deadGoblin.goblinGangGroupId;

                if (!groupId || goblinGangGhostPending[groupId]) return;

                if (!hasAliveGoblinGangMember(groupId, deadGoblin)) return;

                const respawnType = deadGoblin.goblinGangRespawnType || (deadGoblin instanceof SpearGoblin ? 'spear' : 'dagger');

                const ghost = new GoblinGangGhost(deadGoblin.x, deadGoblin.y, deadGoblin.team, groupId, respawnType, deadGoblin.level || 1);

                goblinGangGhostPending[groupId] = true;

                gameObjects.push(ghost);

            }

            class SkeletonArmy {

                constructor(x, y, team, level = 1) {

                    const s = allCards['skeletonArmy'].stats[level];

                    for (let i = 0; i < s.count; i++) {

                        const sk = new Skeleton(x + Math.random() * 30 - 15, y + Math.random() * 30 - 15, team, level);

                        try {

                            if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                                sk.isEvolved = true;

                                sk.shieldTimer = 0;

                            }

                        } catch(e) {}

                        gameObjects.push(sk);

                    }

                }

            }

            class Barbarian extends Unit { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; super(x, y, 11, team, s.health, 0.9, 25, s.damage, s.hitSpeed, 'ðŸ§”', false, false, level, allCards['barbarians'].aggroRange); } } // Speed 1.1 -> 0.9

            class Barbarians {

                constructor(x, y, team, level = 1) {

                    const s = allCards['barbarians'].stats[level];

                    for (let i = 0; i < s.count; i++) {

                        const barb = new Barbarian(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5, team, level);

                        try {

                            if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                                barb.isEvolved = true;

                                // Barbarians get a shield that absorbs two hits

                                barb.shieldHitsRemaining = 2;

                            }

                        } catch(e) {}

                        gameObjects.push(barb);

                    }

                }

            }

		            class FireDragon extends Unit {

	                constructor(x, y, team, level = 1) {

	                    const s = allCards['fireDragon'].stats[level];

	                    super(x, y, 14, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'ðŸ²', true, true, level, allCards['fireDragon'].aggroRange);

		                }

	                attack() {
	                	if (!this.target || this.cooldownTimer > 0) return;
	                	const baseStats = allCards['fireDragon']?.stats[this.level] || {};
	                	const evoStats = allCards['fireDragon']?.evo?.stats || {};
	                	const aimTarget = (this.target && this.target.health > 0) ? this.target : null;
	                	const aimX = aimTarget ? aimTarget.x : this.x;
	                	const aimY = aimTarget ? aimTarget.y : this.y - 1;
	                	const dx = aimX - this.x;
	                	const dy = aimY - this.y;
	                	const dist = Math.hypot(dx, dy) || 1;
	                	const dirX = dx / dist;
	                	const dirY = dy / dist;

	                	if (this.isEvolved) {
	                		if (aimTarget) {
	                			applyDamage(aimTarget, this.attackDamage, { sourceType: 'fireDragon' });
	                		}

                		const waveDamage = evoStats.waveDamage || Math.max(1, Math.round(this.attackDamage * 0.4));
                		const waveLength = evoStats.waveLength || 48;
                		const waveWidth = evoStats.waveWidth || 24;
                		const waveSplash = evoStats.waveSplash || 14;
	                		gameObjects.push(new FireDragonFlameWave(this.x, this.y, dirX, dirY, this.team, waveDamage, waveLength, waveWidth, waveSplash));
	                	} else {
	                		const splashRadius = baseStats.splashRadius || 0;
	                		gameObjects.push(new FireballProjectile(this.x, this.y, this.target, this.team, this.attackDamage, splashRadius, 'fireDragon'));
	                	}

	                	this.cooldownTimer = this.attackCooldown;
	                }


	            } // Speed 1.2 -> 1.0

            class EarthDragon extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['earthDragon'].stats[level];

                    super(x, y, s.radius || 14, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, s.emoji || 'ðŸ‰', true, true, level, allCards['earthDragon'].aggroRange);

                    this.slowFactor = s.slowFactor || 0.6;

                    this.slowDuration = s.slowDuration || 0.5;

                }

                attack() {

                    if (this.target && this.cooldownTimer <= 0) {

                        const rock = new EarthRockProjectile(this.x, this.y, this.target, this.team, this.attackDamage, this.slowFactor, this.slowDuration);

                        gameObjects.push(rock);

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

            }

            class BattleRam extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['battleRam'].stats[level];

                    super(x, y, 15, team, s.health, 1.0, 25, s.damage, 1, 'ðŸŒ²', false, false, level, allCards['battleRam'].aggroRange); // Speed 1.2 -> 1.0

                    this.barbLevel = s.barbLevel;

                    this.chargeTimer = 3 * 60;

                    this.isCharging = false;

                    this.didHit = false; // Flag to prevent double spawns

                    this.targetLocked = false;

                }

                

                findTarget() {

                    // --- BUILDING-TARGETING AI FIX ---

        

                    // 1. Find the default tower target (closest tower in lane, or king)

                    let closestTowerDist = Infinity;

                    let towerTarget = null;

        

                    // Find closest Princess Tower in its lane

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {

                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) { 

                                    closestTowerDist = dist; 

                                    towerTarget = obj; 

                                }

                            }

                        }

                    }

                    // If no lane tower, find King

                    if (!towerTarget) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) { 

                                    closestTowerDist = dist; 

                                    towerTarget = obj; 

                                }

                            }

                        }

                    }

        

                    // 2. Find the closest building (as a potential distraction)

                    let closestBuildingDist = Infinity;

                    let buildingTarget = null;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Building)) {

                            const dist = getDistance(this, obj);

                            if (dist < closestBuildingDist) { 

                                closestBuildingDist = dist; 

                                buildingTarget = obj; 

                            }

                        }

                    }

        

                    // 3. Decide: Is the building a valid, closer distraction?

                    // Use Infinity if no tower target exists

                    const towerDist = towerTarget ? closestTowerDist : Infinity;

                    

                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {

                        // Attack the building

                        this.target = buildingTarget;

                    } else {

                        // No valid distraction, attack the tower

                        this.target = towerTarget;

                    }

                    

                    this.targetLocked = (this.target != null);

                    // --- END AI FIX ---

                }

                

                spawnBarbs() {

                    if (this.didHit) return; // Don't spawn twice

                    this.didHit = true;

                    gameObjects.push(new Barbarian(this.x + 5, this.y, this.team, this.barbLevel));

                    gameObjects.push(new Barbarian(this.x - 5, this.y, this.team, this.barbLevel));

                    this.health = 0; // Ram is destroyed

                }

                update() {

                    if (this.health <= 0 && !this.didHit) {

                        this.spawnBarbs(); // Spawn if killed by damage

                        return;

                    }

                    if (this.didHit) return; // Already spawned, do nothing

                    if (this.handleZapFreeze()) return;

                    

                    if (this.chargeTimer > 0) { this.chargeTimer -= deltaTime * 60; if(this.chargeTimer <= 0) this.isCharging = true; } /* Scale charge timer by delta time */

                    if (this.isCharging) this.speed = 2.0; else this.speed = 1.0;

                    

                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */

    

                    // --- TARGET LOCK-ON FIX (FOR REAL) ---

                    // 1. If we have a target and are in attack range, just attack.

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {

                        this.attack(); // This will call spawnBarbs()

                        return; // Lock in combat

                    }

    

                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)

                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {

                         this.findTarget(); // This will find a tower OR a closer building

                    }

                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.

                    // --- END AI FIX ---

                    

                    if (this.target && this.target.health > 0) {

                        if (getDistance(this, this.target) <= this.attackRange) {

                            this.attack();

                        } else {

                            this.move();

                            if (this.isEvolved) {

                                this.applyIronSnoutPush();

                            }

                        }

                    }

                }

                attack() { // Ram only attacks when it hits

                    if (this.target && this.cooldownTimer <= 0) {

                        if (this.target instanceof PhantomKnight && this.target.isInvisible) {

                            return;

                        }

                        applyDamage(this.target, this.attackDamage);

                        this.spawnBarbs(); // Spawn on hit

                    } 

                }

            }

            

            class AxeSwinger extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['axeSwinger'].stats[level];

                    super(x, y, 12, team, s.health, 1.0, 0, s.damage, s.hitSpeed, 'ðŸª“', false, false, level, allCards['axeSwinger'].aggroRange); // Speed 1.2 -> 1.0

                    this.splashRadius = s.splashRadius;

                    this.attackAnimationTimer = 0; // NEW

                }

                attack() { 

                    if (this.cooldownTimer <= 0) { 

                        this.attackAnimationTimer = 20; // NEW: Start animation

                        for (const obj of gameObjects) {

                            // Hit all non-flying enemies in range

                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                // Skip invisible Phantom Knights

                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                if (getDistance(this, obj) < this.splashRadius) {

                                    applyDamage(obj, this.attackDamage);

                                }

                            }

                        }

                        this.cooldownTimer = this.attackCooldown; 

                    } 

                }

                // FIX: Custom update to allow attacking at splash range

                update() {

                    if (this.health <= 0) return;

                    if (this.handleZapFreeze()) return;

                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */

                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; } // NEW

                    // --- AGGRO FIX (Copy from Unit) ---

                    // 1. If we have a target and are in attack range, just attack. DO NOT look for new targets.

                    let inSplashRange = false;

                    if (this.target && this.target.health > 0) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                // Skip invisible Phantom Knights

                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                if (getDistance(this, obj) < this.splashRadius) {

                                    inSplashRange = true;

                                    break;

                                }

                            }

                        }

                    }

                    if (inSplashRange) {

                        this.attack();

                        return; // <-- This is the key. Stop update here.

                    }

                    

                    // 2. We are not in attack range. Check for new distractions.

                    let distraction = this.findTarget(false); // 'false' means only scan aggro range

                    

                    // 3. If a distraction exists...

                    if (distraction) {

                        // ...and we don't have a target OR the distraction is closer than our current target

                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {

                            this.target = distraction;

                        }

                    } else {

                        // 4. No distraction. Check if our long-distance target is dead/gone

                        if (!this.target || this.target.health <= 0) {

                            this.target = this.findTarget(true); // Find a new tower

                        }

                        // 5. We have a valid long-distance target (troop, building, or tower), just keep it.

                    }

                    // --- END AI FIX ---

                    if (this.target && this.target.health > 0) {

                        if (inSplashRange) { // Re-check

                            this.attack();

                        } else {

                            this.move();

                        }

                    }

                }

                // NEW: Draw attack animation

                draw() {

                    super.draw(); // Draw the unit first

                    if (this.attackAnimationTimer > 0) {

                        const progress = this.attackAnimationTimer / 20;

                        ctx.save();

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, this.splashRadius, 0, Math.PI * 2);

                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`; // Fade out

                        ctx.fill();

                        ctx.restore(); // <-- ADDED THIS MISSING LINE

                    }

                }

            } // <-- ADDED THIS MISSING CLOSING BRACE

            // --- FARMER (NEW) ---

            class Farmer extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['farmer'].stats[level];

                    super(x, y, 12, team, s.health, 1.0, 25, s.damage, s.hitSpeed, 'ðŸ‘¨â€ðŸŒ¾', false, false, level, allCards['farmer'].aggroRange); // Speed 1.2 -> 1.0

                    this.attackWidth = s.attackWidth;

                    this.attackHeight = s.attackHeight;

                    this.attackAnimationTimer = 0;

                    this.attackAngle = 0;

                    this._plantCooldown = 0;

                }

                attack() {

                    if (this.cooldownTimer <= 0) {

                        if (this.isEvolved) this.pullEnemyIntoRange();

                        this.attackAnimationTimer = 20; // Start animation

                        this.attackAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                        // Check for hits in a rectangle

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                // Skip invisible Phantom Knights

                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                if (isInside(obj, this.x, this.y, this.attackWidth, this.attackHeight, this.attackAngle)) {

                                    applyDamage(obj, this.attackDamage);

                                }

                            }

                        }

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

                pullEnemyIntoRange() {

                    const evoStats = allCards['farmer']?.evo?.stats || {};

                    if (this._plantCooldown > 0) return;

                    const lifetime = Math.max(0.5, evoStats.plantLifetime || 1.5);

                    const plant = new FarmerPlant(this.x, this.y, null, this, evoStats.plantPull || 18, lifetime, evoStats.plantRange || 90);

                    gameObjects.push(plant);

                    this._plantCooldown = Math.round(lifetime * 60);

                }

                findFarmerPlantCandidate(range) {

                    let best = null;

                    let bestDist = Infinity;

                    for (const obj of gameObjects) {

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit)) continue;

                        if (obj.isFlying) continue;

                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                        const angle = Math.atan2(obj.y - this.y, obj.x - this.x);

                        if (isInside(obj, this.x, this.y, this.attackWidth, this.attackHeight, angle)) continue;

                        const dist = getDistance(this, obj);

                        if (dist > (range || 90)) continue;

                        if (dist < bestDist) {

                            bestDist = dist;

                            best = obj;

                        }

                    }

                    return best;

                }

                update() {

                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; }

                    // Standard unit update logic (copied from Unit)

                    if (this.health <= 0) return;

                    if (this.handleZapFreeze()) return;

                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }

                    if (this._plantCooldown > 0) {

                        this._plantCooldown -= deltaTime * 60;

                        if (this._plantCooldown < 0) this._plantCooldown = 0;

                    }

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {

                        this.attack();

                        return;

                    }

                    let distraction = this.findTarget(false);

                    if (distraction) {

                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {

                            this.target = distraction;

                        }

                    } else {

                        if (!this.target || this.target.health <= 0) {

                            this.target = this.findTarget(true); 

                        }

                    }

                if (this.target && this.target.health > 0) {

                    if (getDistance(this, this.target) <= this.attackRange) {

                        this.attack();

                    } else {

                        this.move();

                    }

                }

            }

            draw() {

                super.draw(); // Draw the unit

                if (this.attackAnimationTimer > 0) {

                        const progress = this.attackAnimationTimer / 20;

                        ctx.save();

                        ctx.translate(this.x, this.y);

                        ctx.rotate(this.attackAngle);

                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`;

                        // Draw rectangle in front of the unit

                        ctx.fillRect(this.radius, -this.attackWidth / 2, this.attackHeight, this.attackWidth);

                        ctx.restore();

                    }

                }

            }

            class FarmerPlant extends GameObject {

                constructor(x, y, target, owner, pullAmount = 12, lifetimeSeconds = 1.5, range = 90) {

                    super(x, y, 6, owner.team, 1);

                    this.target = target;

                    this.owner = owner;

                    this.pullAmount = pullAmount;

                    this.lifetime = Math.max(0.5, lifetimeSeconds) * 60;

                    this.radius = 8;

                    this.range = range;

                }

                update() {

                    if (!this.target) {

                        this.x = this.owner.x + this.owner.radius + 6;

                        this.y = this.owner.y;

                        this.target = this.owner.findFarmerPlantCandidate(this.range);

                        if (!this.target) return;

                    }

                    if (this.lifetime <= 0) { this.health = 0; return; }

                    if (!this.target || this.target.health <= 0) { this.health = 0; return; }

                    const dx = this.owner.x - this.target.x;

                    const dy = this.owner.y - this.target.y;

                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= 0) { this.health = 0; return; }

                    this.lifetime -= deltaTime * 60;

                    const maxStep = Math.max(0, dist - 8);

                    const pullStep = this.pullAmount * (deltaTime * 60 / 60);

                    const step = Math.min(maxStep, pullStep);

                    if (step <= 0) { this.health = 0; return; }

                    const nx = dx / dist;

                    const ny = dy / dist;

                    this.target.x += nx * step;

                    this.target.y += ny * step;

                    this.x = this.target.x;

                    this.y = this.target.y - 6;

                    const angle = Math.atan2(this.target.y - this.owner.y, this.target.x - this.owner.x);

                    if (isInside(this.target, this.owner.x, this.owner.y, this.owner.attackWidth, this.owner.attackHeight, angle)) {

                        this.health = 0;

                    }

                }

                draw() {

                    if (!ctx) return;

                    ctx.save();

                    ctx.font = '18px Arial';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.fillStyle = '#4ade80';

                    ctx.fillText('ðŸŒ¿', this.x, this.y);

                    ctx.restore();

                }

            }

            // --- PIG (NEW) ---

            class Pig extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['pigs'].stats[level];

                    super(x, y, 10, team, s.health, 1.4, 25, s.damage, s.hitSpeed, 'ðŸ·', false, false, level, allCards['pigs'].aggroRange); // Speed 1.8 -> 1.4

                    this.targetLocked = false;

                }

                // Use building-only targeting

                findTarget() {

                    // --- BUILDING-TARGETING AI FIX ---

        

                    // 1. Find the default tower target (closest tower in lane, or king)

                    let closestTowerDist = Infinity;

                    let towerTarget = null;

        

                    // Find closest Princess Tower in its lane

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {

                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) { 

                                    closestTowerDist = dist; 

                                    towerTarget = obj; 

                                }

                            }

                        }

                    }

                    // If no lane tower, find King

                    if (!towerTarget) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) { 

                                    closestTowerDist = dist; 

                                    towerTarget = obj; 

                                }

                            }

                        }

                    }

        

                    // 2. Find the closest building (as a potential distraction)

                    let closestBuildingDist = Infinity;

                    let buildingTarget = null;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Building)) {

                            const dist = getDistance(this, obj);

                            if (dist < closestBuildingDist) { 

                                closestBuildingDist = dist; 

                                buildingTarget = obj; 

                            }

                        }

                    }

        

                    // 3. Decide: Is the building a valid, closer distraction?

                    // Use Infinity if no tower target exists

                    const towerDist = towerTarget ? closestTowerDist : Infinity;

                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {

                        // Attack the building

                        this.target = buildingTarget;

                    } else {

                        // No valid distraction, attack the tower

                        this.target = towerTarget;

                    }

                    

                    this.targetLocked = (this.target != null);

                    // --- END AI FIX ---

                }

                update() { // Custom update to use building-only AI

                    if (this.health <= 0) return;

                    if (this.handleZapFreeze()) return;

                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */

                    

                    // --- TARGET LOCK-ON FIX (FOR REAL) ---

                    // 1. If we have a target and are in attack range, just attack.

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {

                        this.attack();

                        return; // Lock in combat

                    }

    

                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)

                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {

                         this.findTarget(); // This will find a tower OR a closer building

                    }

                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.

                    // --- END AI FIX ---

    

                    if (this.target && this.target.health > 0) {

                        if (getDistance(this, this.target) <= this.attackRange) {

                            this.attack();

                        } else {

                            this.move();

                            if (this.isEvolved) {

                                this.applyIronSnoutPush();

                            }

                        }

                    }

                }

                attack() {

                    const originalDamage = this.attackDamage;

                    const evoStats = allCards['pigs']?.evo?.stats || {};

                    const bonus = (this.isEvolved && this.target instanceof Tower) ? (evoStats.towerBonusDamage || 20) : 0;

                    this.attackDamage = originalDamage + bonus;

                    super.attack();

                    this.attackDamage = originalDamage;

                }

	                applyIronSnoutPush() {

	                    const evoStats = allCards['pigs']?.evo?.stats || {};

	                    const pushRadius = evoStats.pushRadius || 60;

	                    const pushForce = evoStats.pushForce || 60;

	                    const pushCooldownFrames = evoStats.pushCooldownFrames || 12;

	                    if (pushRadius <= 0 || pushForce <= 0) return;

	                    if (!this._ironSnoutCooldowns) this._ironSnoutCooldowns = new Map();

                        for (const obj of gameObjects) {

                            if (obj === this || obj.team === this.team || !(obj instanceof Unit) || obj.health <= 0) continue;

                            if (obj instanceof Tower || obj instanceof Building) continue;

                            if (obj.isFlying) continue;

                            if (obj.isTargetable === false) continue;

	                        const dist = getDistance(this, obj);

	                        if (dist <= 0 || dist >= pushRadius) continue;

	                        const cooldownKey = obj.id;

	                        const existingCd = this._ironSnoutCooldowns.get(cooldownKey) || 0;

	                        const nextCd = existingCd - (deltaTime * 60);

	                        if (nextCd > 0) {

	                            this._ironSnoutCooldowns.set(cooldownKey, nextCd);

	                            continue;

	                        } else if (existingCd > 0) {

	                            this._ironSnoutCooldowns.delete(cooldownKey);

	                        }

	                        const contactDist = (this.radius || 0) + (obj.radius || 0) + 6;

	                        if (dist > contactDist) continue;

	                        const dx = (obj.x - this.x) / dist;

                        const dy = (obj.y - this.y) / dist;

                        obj.x += dx * pushForce;

                        obj.y += dy * pushForce;

                        const skeletonHealth = allCards['skeletons']?.stats?.[1]?.health || 100;
                        const pushDamage = Math.max(1, skeletonHealth + 10);
                        applyDamage(obj, pushDamage, { sourceType: 'pigs' });

                        this._ironSnoutCooldowns.set(cooldownKey, pushCooldownFrames);

                    }

                }

            }

            class Pigs { constructor(x, y, team, level = 1) { const s = allCards['pigs'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Pig(x + Math.random()*20-10, y + Math.random()*20-10, team, level)); } } }

            

            // --- HORSE RIDER (NEW ARENA 12) ---

            class HorseRider extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['horseRider'].stats[level];

                    super(x, y, 13, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'ðŸŽâš”ï¸', false, false, level, allCards['horseRider'].aggroRange);

                    this.baseSpeed = s.speed;

                    this.baseDamage = s.damage;

                    this.chargeSpeed = s.chargeSpeed;

                    this.chargeDamage = s.chargeDamage;

                    this.chargePrep = s.chargePrep;

                    this.chargeTimer = this.chargePrep;

                    this.isCharging = false;

                    this.riverJumpDelay = s.riverJumpDelay || 1;

                    this.riverJumpDuration = s.riverJumpDuration || 20;

                    this.riverJumpHeight = s.riverJumpHeight || 45;

                }

                update() {

                    if (!this.isCharging) {

                        this.chargeTimer -= deltaTime;

                        if (this.chargeTimer <= 0) {

                            this.isCharging = true;

                            this.speed = this.chargeSpeed;

                            this.chargeTimer = this.chargePrep;

                        }

                    }

                    super.update();

                    if (this.isCharging && (!this.target || this.target.health <= 0)) {

                        this.isCharging = false;

                        this.speed = this.baseSpeed;

                        this.chargeTimer = this.chargePrep;

                    }

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    const originalDamage = this.attackDamage;

                    if (this.isCharging) {

                        this.attackDamage = this.chargeDamage;

                    }

                    super.attack();

                    this.attackDamage = originalDamage;

                    this.isCharging = false;

                    this.speed = this.baseSpeed;

                    this.chargeTimer = this.chargePrep;

                }

                move() {

                    if (tryRiverJump(this, this.riverJumpDelay, this.riverJumpDuration, this.riverJumpHeight)) return;

                    super.move();

                }

            }

            // --- PIG JOCKEY (ARENA 12 WIN CONDITION) ---

            class PigJockey extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['pigJockey'].stats[level];

                    super(x, y, 12, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'ðŸ·ðŸ‡', false, false, level, allCards['pigJockey'].aggroRange);

                    this.riverJumpDelay = s.riverJumpDelay || 1;

                    this.riverJumpDuration = s.riverJumpDuration || 18;

                    this.riverJumpHeight = s.riverJumpHeight || 40;

                    this.targetLocked = false;

                }

                findTarget() {

                    let closestTowerDist = Infinity;

                    let towerTarget = null;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {

                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) {

                                    closestTowerDist = dist;

                                    towerTarget = obj;

                                }

                            }

                        }

                    }

                    if (!towerTarget) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {

                                const dist = getDistance(this, obj);

                                if (dist < closestTowerDist) {

                                    closestTowerDist = dist;

                                    towerTarget = obj;

                                }

                            }

                        }

                    }

                    let closestBuildingDist = Infinity;

                    let buildingTarget = null;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Building)) {

                            const dist = getDistance(this, obj);

                            if (dist < closestBuildingDist) {

                                closestBuildingDist = dist;

                                buildingTarget = obj;

                            }

                        }

                    }

                    const towerDist = towerTarget ? closestTowerDist : Infinity;

                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {

                        this.target = buildingTarget;

                    } else {

                        this.target = towerTarget;

                    }

                    this.targetLocked = (this.target != null);

                }

                update() {

                    if (this.health <= 0) return;

                    if (this.handleZapFreeze()) return;

                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; }

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {

                        this.attack();

                        return;

                    }

                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {

                        this.findTarget();

                    }

                    if (this.target && this.target.health > 0) {

                        if (getDistance(this, this.target) <= this.attackRange) {

                            this.attack();

                        } else {

                            this.move();

                        }

                    }

                }

                move() {

                    if (tryRiverJump(this, this.riverJumpDelay, this.riverJumpDuration, this.riverJumpHeight)) return;

                    super.move();

                }

            }

            // --- FISH (AQUA ARENA) ---

            class Fish extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['fish'].stats[level];

                    super(x, y, s.radius, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'ðŸŸ', false, false, level, allCards['fish'].aggroRange);

                    this.splashRadius = s.splashRadius || 0;

                    this.hasRevealed = false;

                    this.isTargetable = false;

                }

                reveal() {

                    if (this.hasRevealed) return;

                    this.hasRevealed = true;

                    this.isTargetable = true;

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    applyDamage(this.target, this.attackDamage);

                    if (this.splashRadius > 0) {

                        const splashDamage = Math.max(1, Math.round(this.attackDamage * 0.6));

                        for (const obj of gameObjects) {

                            if (obj === this.target || obj.team === this.team || obj.health <= 0) continue;

                            if (getDistance(this.target, obj) < this.splashRadius) {

                                applyDamage(obj, splashDamage);

                            }

                        }

                    }

                    this.cooldownTimer = this.attackCooldown;

                    this.reveal();

                }

            }

            // --- FLYING FISH (AQUA ARENA WINCON) ---

            class FlyingFish extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['flyingFish'].stats[level];

                    super(x, y, s.radius, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'ðŸ ', true, false, level, allCards['flyingFish'].aggroRange);

                }

                findTarget(forceFindTower = false) {

                    let buildingTarget = null;

                    let buildingDist = Infinity;

                    let airThreat = null;

                    let airDist = Infinity;

                    let groundAntiAir = null;

                    let groundAntiAirDist = Infinity;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && obj.health > 0) {

                            const dist = getDistance(this, obj);

                            if ((obj instanceof Tower || obj instanceof Building) && dist < buildingDist) {

                                buildingDist = dist;

                                buildingTarget = obj;

                            } else if (obj instanceof Unit) {

                                if (!obj.isFlying && obj.targetsAir && dist < groundAntiAirDist) {

                                    groundAntiAirDist = dist;

                                    groundAntiAir = obj;

                                }

                                if (obj.targetsAir && dist < airDist) {

                                    airDist = dist;

                                    airThreat = obj;

                                }

                            }

                        }

                    }

                    if (groundAntiAir) return groundAntiAir;

                    if (buildingTarget && (!airThreat || buildingDist <= airDist)) return buildingTarget;

                    return airThreat;

                }

            }

            // --- FISHERGIRL (AQUA ARENA) ---

            class Fishergirl extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['fishergirl'].stats[level];

                    super(x, y, s.radius, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'ðŸ§œâ€â™€ï¸', false, false, level, allCards['fishergirl'].aggroRange);

                    this.hookRange = s.hookRange || 160;

                    this.pullStrength = s.pullStrength || 0.3;

                    this.hookPullTime = Math.max((s.hookPullTime || 0.35) * 60, 60);

                    this.hookCooldown = 0;

                    this.hookCooldownMax = (s.hookCooldown || 2) * 60;

                    this.hookedTarget = null;

                    this.hookProgress = 0;

                    this.slowDuration = (s.slowDuration || 3) * 60;

                    this.hookedStructure = false;

                }

                update() {

                    if (this.health <= 0) {

                        this.releaseHook();

                        return;

                    }

                    if (this.handleZapFreeze()) return;

                    if (this.hookCooldown > 0) this.hookCooldown -= deltaTime * 60;

                    if (this.hookedTarget) {

                        this.processHook();

                        return;

                    }

                    const hookCandidate = this.findHookCandidate();

                    const hookDist = hookCandidate ? getDistance(this, hookCandidate) : Infinity;

                    if (hookCandidate && hookDist <= this.hookRange && this.hookCooldown <= 0) {

                        this.beginHook(hookCandidate);

                        return;

                    }

                    if (!this.target || this.target.health <= 0 || this.target.team === this.team) {

                        this.target = this.findTarget(true);

                    }

                    if (this.target && this.target.health > 0) {

                        this.move();

                    }

                }

                findHookCandidate() {

                    let bestUnit = null;

                    let bestUnitDist = this.hookRange;

                    let bestBuilding = null;

                    let bestBuildingDist = this.hookRange;

                    for (const obj of gameObjects) {

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (obj instanceof Unit && obj.isFlying) continue;

                        const objDist = getDistance(this, obj);

                        if (objDist > this.hookRange) continue;

                        if (obj instanceof Building || obj instanceof Tower) {

                            if (objDist < bestBuildingDist) {

                                bestBuildingDist = objDist;

                                bestBuilding = obj;

                            }

                        } else if (obj instanceof Unit) {

                            if (objDist < bestUnitDist) {

                                bestUnitDist = objDist;

                                bestUnit = obj;

                            }

                        }

                    }

                    if (bestBuilding && (!bestUnit || bestBuildingDist <= bestUnitDist)) return bestBuilding;

                    return bestUnit;

                }

                processHook() {

                    if (!this.hookedTarget || this.hookedTarget.health <= 0) {

                        this.releaseHook();

                        return;

                    }

                    this.hookProgress += deltaTime * 60;

                    const hookDist = getDistance(this, this.hookedTarget);

                    const desiredDist = this.hookedStructure ? 4 : 1;

                    if (this.hookedStructure) {

                        this.pullSelfToStructure(hookDist, desiredDist);

                    } else {

                        this.pullTarget(hookDist, desiredDist);

                    }

                    const reached = hookDist <= desiredDist;

                    const timedOut = this.hookProgress >= this.hookPullTime;

                    const finishCondition = this.hookedStructure ? (reached || timedOut) : reached;

                    if (finishCondition) {

                        this.finishHook();

                    }

                }

                beginHook(target) {

                    this.hookedTarget = target;

                    this.hookProgress = 0;

                    this.hookedStructure = target instanceof Building || target instanceof Tower;

                    this.hookCooldown = this.hookCooldownMax;

                    if (!this.hookedStructure) {

                        target._hookFrozenByFishergirl = true;

                        target._hookPrevFrozen = !!target.frozen;

                        target.frozen = true;

                        target.hookedByFishergirl = this;

                    }

                }

                pullTarget(currentDist, desiredDist) {

                    if (!this.hookedTarget) return;

                    const dx = this.x - this.hookedTarget.x;

                    const dy = this.y - this.hookedTarget.y;

                    const gap = currentDist > 0 ? currentDist : Math.sqrt(dx * dx + dy * dy);

                    if (gap <= desiredDist) {

                        this.hookedTarget.x = this.x;

                        this.hookedTarget.y = this.y;

                        return;

                    }

                    const baseSpeed = this.speed * 4;

                    const hookSpeed = Math.max(this.pullStrength * 10 * (deltaTime * 60), baseSpeed * (deltaTime * 60));

                    const maxPull = gap - desiredDist;

                    const pullFactor = Math.min(hookSpeed, maxPull);

                    const angle = Math.atan2(dy, dx);

                    this.hookedTarget.x += Math.cos(angle) * pullFactor;

                    this.hookedTarget.y += Math.sin(angle) * pullFactor;

                }

                pullSelfToStructure(currentDist, desiredDist) {

                    if (!this.hookedTarget) return;

                    const dx = this.hookedTarget.x - this.x;

                    const dy = this.hookedTarget.y - this.y;

                    const remain = Math.max(0, currentDist - desiredDist);

                    if (remain <= 0) return;

                    const speedMul = 9;

                    const step = Math.min(this.speed * speedMul * (deltaTime * 60), remain);

                    if (step > 0) {

                        const angle = Math.atan2(dy, dx);

                        this.x += Math.cos(angle) * step;

                        this.y += Math.sin(angle) * step;

                    }

                }

                finishHook() {

                    if (!this.hookedTarget) return;

                    if (this.hookedStructure) {

                        this.x = this.hookedTarget.x;

                        this.y = this.hookedTarget.y;

                        applyDamage(this.hookedTarget, this.attackDamage);

                    } else {

                        applyDamage(this.hookedTarget, this.attackDamage);

                        this.applyFisherSlow(this.hookedTarget);

                    }

                    this.releaseHook();

                    this.cooldownTimer = this.attackCooldown;

                    this.target = null;

                }

                releaseHook() {

                    if (this.hookedTarget && this.hookedTarget.hookedByFishergirl === this) {

                        delete this.hookedTarget.hookedByFishergirl;

                    }

                    if (this.hookedTarget) {

                        if (this.hookedTarget._hookFrozenByFishergirl) {

                            this.hookedTarget.frozen = this.hookedTarget._hookPrevFrozen || false;

                            delete this.hookedTarget._hookFrozenByFishergirl;

                            delete this.hookedTarget._hookPrevFrozen;

                        }

                    }

                    this.hookedTarget = null;

                    this.hookProgress = 0;

                    this.hookedStructure = false;

                }

                applyFisherSlow(target) {

                    if (!target || target.health <= 0) return;

                    const wasSlowed = target._fisherSlowTimer && target._fisherSlowTimer > 0;

                    target._fisherSlowTimer = this.slowDuration;

                    if (wasSlowed) return;

                    if (target.speed !== undefined) {

                        target._fisherOriginalSpeed = target.speed;

                        target.speed = Math.max(0.2, target.speed * 0.5);

                    }

                    if (target.attackCooldown !== undefined) {

                        target._fisherOriginalAttackCooldown = target.attackCooldown;

                        target.attackCooldown = Math.min(target.attackCooldown * 1.4, target.attackCooldown + 40);

                    }

                }

            }

            // --- FLYING SKELETON (NEW) ---

            class FlyingSkeleton extends Unit { 

                constructor(x, y, team, level = 1) { 

                    const s = allCards['flyingSkeletons'].stats[level]; 

                    super(x, y, 9, team, s.health, 1.4, 25, s.damage, s.hitSpeed, 'ðŸ’€ðŸ¦‡', true, true, level, allCards['flyingSkeletons'].aggroRange); 

                } 

                // Removed custom draw() function to use the emoji

            }

            class FlyingSkeletons { constructor(x, y, team, level = 1) { const s = allCards['flyingSkeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new FlyingSkeleton(x + Math.random()*20-10, y + Math.random()*20-10, team, level)); } } }

            

            // --- MEGA FLYING SKELETON (NEW) ---

            class MegaFlyingSkeleton extends Unit { 

                constructor(x, y, team, level = 1) { 

                    const s = allCards['megaFlyingSkeleton'].stats[level]; 

                    super(x, y, 14, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'ðŸ’€ðŸ¦‡', true, true, level, allCards['megaFlyingSkeleton'].aggroRange); 

                } 

                // Removed custom draw() function to use the emoji

            }

            

            // --- FLYING SKELETON GROUP (NEW) ---

            class FlyingSkeletonGroup { constructor(x, y, team, level = 1) { const s = allCards['flyingSkeletonGroup'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new FlyingSkeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }

            // --- WARLOCK (NEW) ---

            class Warlock extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['warlock'].stats[level];

                    super(x, y, 12, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'ðŸ”®', false, true, level, allCards['warlock'].aggroRange);

                    this.splashRadius = s.splashRadius;

                }

                attack() {

                    if (this.target && this.cooldownTimer <= 0) {

                        // Create splash projectile

                        gameObjects.push(new FireballProjectile(this.x, this.y, this.target, this.team, this.attackDamage, this.splashRadius));

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

            }

            // --- MAGE (ARENA 7) ---

            class Mage extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['mage'].stats[level];

                    super(x, y, 12, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'ðŸ§™â€â™€ï¸', false, true, level, allCards['mage'].aggroRange);

                    this.splashRadius = s.splashRadius;

                    this.skeletonSpawnTimer = 0; // Instantly spawn on place

                    this.hasSpawnedInitial = false;

                }

                attack() {

                    if (this.target && this.cooldownTimer <= 0) {

                        // Create splash projectile

                        gameObjects.push(new FireballProjectile(this.x, this.y, this.target, this.team, this.attackDamage, this.splashRadius));

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

                update() {

                    super.update();

                    if (this.health <= 0) return;

                    if (!this.hasSpawnedInitial) {

                        // Instantly spawn 4 skeletons on placement

                        const offset = 18;

                        const positions = [

                            { dx: -offset, dy: -offset }, // top left

                            { dx: -offset, dy: offset },  // bottom left

                            { dx: offset, dy: -offset },  // top right

                            { dx: offset, dy: offset }    // bottom right

                        ];

                        for (const pos of positions) {

                            gameObjects.push(new Skeleton(this.x + pos.dx, this.y + pos.dy, this.team, this.level));

                        }

                        this.skeletonSpawnTimer = 5 * 60;

                        this.hasSpawnedInitial = true;

                    } else {

                        this.skeletonSpawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */

                        if (this.skeletonSpawnTimer <= 0) {

                            const offset = 18;

                            const positions = [

                                { dx: -offset, dy: -offset }, // top left

                                { dx: -offset, dy: offset },  // bottom left

                                { dx: offset, dy: -offset },  // top right

                                { dx: offset, dy: offset }    // bottom right

                            ];

                            for (const pos of positions) {

                                gameObjects.push(new Skeleton(this.x + pos.dx, this.y + pos.dy, this.team, this.level));

                            }

                            this.skeletonSpawnTimer = 5 * 60;

                        }

                    }

                }

            }

            // --- PHANTOM KNIGHT (ARENA 7) ---

            class PhantomKnight extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['phantomKnight'].stats[level];

                    super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'ðŸ‘»âš”ï¸', false, false, level, allCards['phantomKnight'].aggroRange);

                    this.isInvisible = true;

                    this.lastAttackTime = 0;

                    this.invisibilityDelay = 180;

                }

                attack() {

                    if (this.target && this.cooldownTimer <= 0) {

                        this.isInvisible = false;

                        this.lastAttackTime = 0;

                        if (this.attackRange <= this.radius + this.target.radius + 5) {

                            applyDamage(this.target, this.attackDamage);

                        } else {

                            let projectileType = Projectile;

                            let damage = this.attackDamage;

                            let splash = 0;

                            if (this.emoji === 'ðŸ²') {

                                projectileType = FireballProjectile;

                                splash = allCards['fireDragon'].stats[this.level].splashRadius;

                            }

                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash));

                        }

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

                update() {

                    if (this.health <= 0) return;

                    if (this.handleZapFreeze()) return;

                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }

                    

                    if (this.frozen) return;

                    

                    if (!this.isInvisible) {

                        this.lastAttackTime += deltaTime * 60; /* Scale last attack time by delta time */

                        if (this.lastAttackTime >= this.invisibilityDelay) {

                            this.isInvisible = true;

                            this.lastAttackTime = 0;

                        }

                    }

                    

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {

                        this.attack();

                        return;

                    }

                    

                    let distraction = this.findTarget(false);

                    

                    if (distraction) {

                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {

                            this.target = distraction;

                        }

                    } else {

                        if (!this.target || this.target.health <= 0) {

                            this.target = this.findTarget(true);

                        }

                    }

                    if (this.target && this.target.health > 0) {

                        if (getDistance(this, this.target) <= this.attackRange) {

                            this.attack();

                        } else {

                            this.move();

                        }

                    }

                }

                draw() {

                    if (this.isInvisible) {

                        ctx.save();

                        ctx.globalAlpha = 0.2;

                        const color = this.team === 'player' ? '#60a5fa' : '#f87171';

                        super.draw(color, this.emoji, this.level);

                        ctx.globalAlpha = 1;

                        ctx.restore();

                    } else {

                        const color = this.team === 'player' ? '#60a5fa' : '#f87171';

                        super.draw(color, this.emoji, this.level);

                    }

                }

            }

            // --- SPIRIT LANTERN (ARENA 7) ---

            class SpiritLantern extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'spiritLantern');

                    this.spiritTypes = ['zapSpirit', 'coldSpirit', 'lifeSpirit'];

                    this.spawnTimer = this.spawnRate;

                }

                update() {

                    if (this.health <= 0) return;

                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */

                    if (this.lifetime <= 0) { this.health = 0; return; }

                    // Health decay

                    const decayPerFrame = this.maxHealth / this.maxLifetime;

                    this.health -= decayPerFrame;

                    this.spawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */

                    if (this.spawnTimer <= 0) {

                        // Randomly pick a spirit type

                        const spiritType = this.spiritTypes[Math.floor(Math.random() * this.spiritTypes.length)];

                        gameObjects.push(new allCards[spiritType].unitClass(this.x + (Math.random()-0.5)*10, this.y + (Math.random()-0.5)*10, this.team, this.level));

                        this.spawnTimer = this.spawnRate;

                    }

                }

            }

// --- SPIRIT CLASSES (NEW, FROM SCRATCH) ---

class ColdSpirit extends Unit {

    constructor(x, y, team, level = 1) {

        const s = allCards['coldSpirit'].stats[level];

        super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'â„ï¸', false, false, level, allCards['coldSpirit'].aggroRange);

        this.jumpRadius = s.jumpRadius;

        this.effectRadius = s.effectRadius;

        this.freezeDuration = s.freezeDuration;

        this.hasJumped = false;

    }

    update() {

        if (this.health <= 0 || this.hasJumped) return;

        if (this.handleZapFreeze()) return;

        // Use standard land troop AI to find target in aggro range

        let target = null;

        // Find closest enemy unit (including flying), building, or tower in aggro range

        let closestDist = this.jumpRadius;

        for (const obj of gameObjects) {

            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                // Skip invisible Phantom Knights

                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                const dist = getDistance(this, obj);

                if (dist < closestDist) {

                    closestDist = dist;

                    target = obj;

                }

            }

        }

        if (target) {

            // Jump onto target and trigger freeze

            this.x = target.x;

            this.y = target.y;

            gameObjects.push(new FreezeEffect(this.x, this.y, this.team, this.effectRadius, this.freezeDuration * 60));

            this.hasJumped = true;

            this.health = 0;

        } else {

            // Move like a normal troop

            if (!this.target || this.target.health <= 0) {

                this.target = this.findTarget(true);

            }

            if (this.target && this.target.health > 0) {

                this.move();

            }

        }

    }

}

        class BombSpirit extends Unit {

            constructor(x, y, team, level = 1) {

                const s = allCards['bombSpirit'].stats[level];

                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'ðŸ’£', false, false, level, allCards['bombSpirit'].aggroRange);

                this.jumpRadius = s.jumpRadius;

                this.effectRadius = s.effectRadius;

                this.damage = s.damage;

                this.hasJumped = false;

            }

            update() {

                if (this.health <= 0 || this.hasJumped) return;

                if (this.handleZapFreeze()) return;

                let target = null;

                let closestDist = this.jumpRadius;

                for (const obj of gameObjects) {

                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                        if (obj instanceof Tower && obj.isKing) continue; // Require another object before hitting the king

                        // Skip invisible Phantom Knights

                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                        const dist = getDistance(this, obj);

                        if (dist < closestDist) {

                            closestDist = dist;

                            target = obj;

                        }

                    }

                }

                if (target) {

                    // Jump onto target and trigger explosion

                    this.x = target.x;

                    this.y = target.y;

                    // Damage all enemy things in effect radius

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                            // Don't skip invisible Phantom Knights here - spells/explosions can hit them

                            if (getDistance(this, obj) < this.effectRadius) {

                                applyDamage(obj, this.damage);

                            }

                        }

                    }

                    gameObjects.push(new ExplosionEffect(this.x, this.y, this.effectRadius));

                    this.hasJumped = true;

                    this.health = 0;

                } else {

                    if (!this.target || this.target.health <= 0) {

                        this.target = this.findTarget(true);

                    }

                    if (this.target && this.target.health > 0) {

                        this.move();

                    }

                }

            }

        }

        class PlanarWisp extends Unit {

            constructor(x, y, team, level = 1) {

                const template = allCards['planarWisp'];

                const s = template.stats[level];

                super(x, y, s.radius || 10, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'âœ¨', true, true, level, template.aggroRange || 140);

                this.sparkInterval = 40;

                this.sparkTimer = this.sparkInterval;

            }

            update() {

                super.update();

                if (this.health <= 0) return;

                this.sparkTimer -= deltaTime * 60;

                if (this.sparkTimer <= 0) {

                    this.sparkTimer += this.sparkInterval;

                    const target = this.target && this.target.health > 0 ? this.target : null;

                    if (!target) return;

                    const distanceToTarget = getDistance(this, target);

                    if (distanceToTarget > this.attackRange + 5) return;

                    const angle = Math.atan2(target.y - this.y, target.x - this.x);

                    const shardDamage = Math.max(1, Math.round(this.attackDamage * 0.35));

                    gameObjects.push(new NebulaShard(this.x, this.y, angle, this.team, shardDamage, 3, 0.8));

                }

            }

        }

        class WaveSpirit extends Unit {

            constructor(x, y, team, level = 1) {

                const s = allCards['waveSpirit'].stats[level];

                super(x, y, s.radius, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'ðŸ’§', true, false, level, allCards['waveSpirit'].aggroRange);

                this.pushForce = s.pushForce || 40;

                this.jumpRadius = s.jumpRadius || 60;

                this.hasJumped = false;

                this._idleBaseY = y;

                this._idleFloatTimer = Math.random() * Math.PI * 2;

            }

            update() {

                if (this.health <= 0 || this.hasJumped) return;

                if (this.handleZapFreeze()) return;

                const target = this.findJumpTarget();

                if (target) {

                    this.performJump(target);

                    return;

                }

                if (!this.target || this.target.health <= 0) {

                    this.target = this.findTarget(true);

                }

                if (this.target && this.target.health > 0) {

                    this.move();

                } else {

                    this._idleFloatTimer += deltaTime * 60;

                    const bobOffset = Math.sin(this._idleFloatTimer * 0.08) * 4;

                    this.y = Math.max(30, Math.min(HEIGHT - 30, this._idleBaseY + bobOffset));

                }

            }

            findJumpTarget() {

                let closestDist = this.jumpRadius;

                let candidate = null;

                for (const obj of gameObjects) {

                    if (obj.team === this.team || obj.health <= 0) continue;

                    const isJumpTarget = obj instanceof Unit || obj instanceof Tower || obj instanceof Building;

                    if (!isJumpTarget) continue;

                    if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                    const dist = getDistance(this, obj);

                    const contactDist = this.radius + (obj.radius || 0);

                    if (dist <= contactDist + 1) {

                        return obj;

                    }

                    if (dist < closestDist) {

                        closestDist = dist;

                        candidate = obj;

                    }

                }

                return candidate;

            }

            performJump(target) {

                if (!target || target.health <= 0) return;

                const dx = target.x - this.x;

                const dy = target.y - this.y;

                const angle = Math.atan2(dy, dx);

                this.x = target.x;

                this.y = target.y;

                applyDamage(target, this.attackDamage);

                if (this.pushForce > 0 && target instanceof Unit) {

                    target.x += Math.cos(angle) * this.pushForce;

                    target.y += Math.sin(angle) * this.pushForce;

                }

                this.hasJumped = true;

                this.health = 0;

            }

        }

            const ELIXIR_GIANT_STAGE_CONFIG = {

                mini: {

                    healthMult: 0.45,

                    damageMult: 0.35,

                    hitSpeedMult: 0.95,

                    speedAdd: 0.35,

                    radius: 17,

                    aggroRange: 120,

                    emoji: 'ðŸ§«'

                },

                shard: {

                    healthMult: 0.25,

                    damageMult: 0.25,

                    hitSpeedMult: 0.9,

                    speedAdd: 0.45,

                    radius: 13,

                    aggroRange: 105,

                    emoji: 'ðŸ§¬'

                }

            };

            function buildElixirStageStats(level, stageKey) {

                const config = ELIXIR_GIANT_STAGE_CONFIG[stageKey];

                if (!config || !allCards['elixirGiant']) {

                    return {

                        health: 100,

                        damage: 10,

                        hitSpeed: 1.3,

                        speed: 1.0,

                        radius: 14,

                        aggroRange: 100,

                        emoji: 'ðŸ§«'

                    };

                }

                const cardStats = allCards['elixirGiant'].stats[level] || allCards['elixirGiant'].stats[1];

                const health = Math.max(1, Math.round(cardStats.health * config.healthMult));

                const damage = Math.max(1, Math.round(cardStats.damage * config.damageMult));

                const hitSpeed = Math.max(0.3, cardStats.hitSpeed * config.hitSpeedMult);

                const speed = (typeof cardStats.speed === 'number' ? cardStats.speed : 0.6) + config.speedAdd;

                return {

                    health,

                    damage,

                    hitSpeed,

                    speed,

                    radius: config.radius,

                    aggroRange: config.aggroRange,

                    emoji: config.emoji

                };

            }

                        function findClosestEnemyStructure(source, maxRange = Infinity, excludeTarget = null) {

                            let closest = null;

                            let bestDist = maxRange;

                            for (const obj of gameObjects) {

                                if (obj === excludeTarget) continue; // Exclude this target

                                if (!obj || obj.team === source.team) continue;

                                if (!(obj instanceof Tower) && !(obj instanceof Building)) continue;

                                if (obj.health <= 0) continue;

                                const dist = getDistance(source, obj);

                                if (dist < bestDist) {

                                    bestDist = dist;

                                    closest = obj;

                                }

                            }

                            return closest;

                        }

            class ElixirGiant extends Giant {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level);

                    const s = allCards['elixirGiant'].stats[level];

                    this.radius = 22;

                    this.health = s.health;

                    this.maxHealth = s.health;

                    this.speed = s.speed;

                    this.attackDamage = s.damage;

                    this.aggroRange = allCards['elixirGiant'].aggroRange;

                    this.attackCooldown = s.hitSpeed * 60;

                    this.emoji = 'ðŸ§ª';

                    this.didSpawnMini = false;

                }

                findTarget() {

                    return super.findTarget();

                }

                spawnMinis(targetArray) {

                    if (this.didSpawnMini) return;

                    this.didSpawnMini = true;

                    const offset = 16;

                    targetArray.push(new ElixirGiantMini(this.x - offset, this.y, this.team, this.level));

                    targetArray.push(new ElixirGiantMini(this.x + offset, this.y, this.team, this.level));

                }

            }

            class ElixirGiantMini extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = buildElixirStageStats(level, 'mini');

                    super(x, y, s.radius, team, s.health, s.speed, 26, s.damage, s.hitSpeed, s.emoji, false, false, level, s.aggroRange);

                    this.didSpawnShards = false;

                }

                findTarget() {

                    return findClosestEnemyStructure(this);

                }

                spawnShards(targetArray) {

                    if (this.didSpawnShards) return;

                    this.didSpawnShards = true;

                    const offset = 10;

                    targetArray.push(new ElixirGiantShard(this.x - offset, this.y, this.team, this.level));

                    targetArray.push(new ElixirGiantShard(this.x + offset, this.y, this.team, this.level));

                }

            }

            class ElixirGiantShard extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = buildElixirStageStats(level, 'shard');

                    super(x, y, s.radius, team, s.health, s.speed, 22, s.damage, s.hitSpeed, s.emoji, false, false, level, s.aggroRange);

                }

                findTarget() {

                    return findClosestEnemyStructure(this);

                }

            }

        class ZapSpirit extends Unit {

            constructor(x, y, team, level = 1) {

                const s = allCards['zapSpirit'].stats[level];

                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'âš¡', false, false, level, allCards['zapSpirit'].aggroRange);

                this.jumpRadius = s.jumpRadius;

                this.effectRadius = s.effectRadius;

                this.damage = s.damage;

                this.hasJumped = false;

            }

            update() {

                if (this.health <= 0 || this.hasJumped) return;

                if (this.handleZapFreeze()) return;

                let target = null;

                let closestDist = this.jumpRadius;

                for (const obj of gameObjects) {

                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                        // Skip invisible Phantom Knights

                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                        const dist = getDistance(this, obj);

                        if (dist < closestDist) {

                            closestDist = dist;

                            target = obj;

                        }

                    }

                }

                if (target) {

                    // Jump onto target and trigger zap chain

                    this.x = target.x;

                    this.y = target.y;

                    // Chain to up to 10 enemy things in effect radius

                    let chain = [target];

                    let visited = new Set([target]);

                    let current = target;

                    for (let i = 1; i < 10; i++) {

                        // Find next closest enemy not already zapped

                        let next = null;

                        let minDist = Infinity;

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower) && !visited.has(obj) && getDistance(current, obj) < this.effectRadius) {

                                // Skip invisible Phantom Knights

                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                let d = getDistance(current, obj);

                                if (d < minDist) {

                                    minDist = d;

                                    next = obj;

                                }

                            }

                        }

                        if (next) {

                            chain.push(next);

                            visited.add(next);

                            current = next;

                        } else {

                            break;

                        }

                    }

                    // Deal damage to all in chain

                    spawnZapTrail(this, chain, '#7dd3fc', 22);

                    for (const obj of chain) {

                        applyDamage(obj, this.damage);

                        applyZapFreeze(obj, 0.9);

                        if (obj instanceof Tower && obj.isKing && !obj.isActive) {

                            obj.isActive = true;

                            obj.activationAnimation = 30;

                        }

                    }

                    this.hasJumped = true;

                    this.health = 0;

                } else {

                    if (!this.target || this.target.health <= 0) {

                        this.target = this.findTarget(true);

                    }

                    if (this.target && this.target.health > 0) {

                        this.move();

                    }

                }

            }

        }

        class LifeSpirit extends Unit {

            constructor(x, y, team, level = 1) {

                const s = allCards['lifeSpirit'].stats[level];

                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'ðŸ’š', false, false, level, allCards['lifeSpirit'].aggroRange);

                this.jumpRadius = s.jumpRadius;

                this.effectRadius = s.effectRadius;

                this.healDuration = s.healDuration;

                this.hasJumped = false;

            }

            update() {

                if (this.health <= 0 || this.hasJumped) return;

                if (this.handleZapFreeze()) return;

                let target = null;

                let closestDist = this.jumpRadius;

                for (const obj of gameObjects) {

                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                        // Skip invisible Phantom Knights

                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                        const dist = getDistance(this, obj);

                        if (dist < closestDist) {

                            closestDist = dist;

                            target = obj;

                        }

                    }

                }

                if (target) {

                    // Jump onto target and trigger heal (heal only allies)

                    this.x = target.x;

                    this.y = target.y;

                    gameObjects.push(new HealEffect(this.x, this.y, this.team, this.effectRadius, this.healDuration * 60));

                    this.hasJumped = true;

                    this.health = 0;

                } else {

                    if (!this.target || this.target.health <= 0) {

                        this.target = this.findTarget(true);

                    }

                    if (this.target && this.target.health > 0) {

                        this.move();

                    }

                }

            }

        }

            // --- SPEAR GOBLINS (NEW) ---

            class SpearGoblins { constructor(x, y, team, level = 1) { const s = allCards['spearGoblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }

            // --- MEGA SMASHER (ARENA 10) ---

            class MegaSmasher extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['megaSmasher'].stats[level];

                    super(x, y, 18, team, s.health, s.speed, 25, s.damage, s.hitSpeed, 'ðŸ’¥', false, false, level, allCards['megaSmasher'].aggroRange);

                    this.spawnSplashRadius = s.spawnSplashRadius;

                    this.jumpDamage = s.jumpDamage;

                    this.jumpSplashRadius = s.jumpSplashRadius;

                    this.jumpRange = s.jumpRange;

                    this.jumpCooldown = s.jumpCooldown * 60;

                    

                    this.hasDealtSpawnDamage = false;

                    this.isChargingJump = false;

                    this.chargeTimer = 0;

                    this.isJumping = false;

                    this.jumpProgress = 0;

                    this.jumpStartX = x;

                    this.jumpStartY = y;

                    this.jumpTargetX = x;

                    this.jumpTargetY = y;

                    this.currentJumpCooldown = 0;

                    this.originalEmoji = 'ðŸ’¥';

                    this.greyEmoji = 'ðŸŒ«ï¸';

                    this.attackWidth = s.attackWidth;

                    this.attackHeight = s.attackHeight;

                    this.attackAnimationTimer = 0;

                    this.attackAngle = 0;

                    this.minJumpRange = s.minJumpRange; // Added min jump range

                    this.JUMP_DURATION_FRAMES = 20; // Frames for the actual jump animation

                    this.CHARGE_DURATION_FRAMES = 30; // Frames for pre-jump charge

                }

                

                // Mega Smasher's findTarget should be general, like other melee units

                findTarget(forceFindTower = false) {

                    let closestDist = this.aggroRange;

                    let bestTarget = null;

                    

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                            if (!this.targetsAir && obj.isFlying) continue; 

                            

                            const dist = getDistance(this, obj);

                            if (dist < closestDist) {

                                closestDist = dist;

                                bestTarget = obj;

                            }

                        }

                    }

                    

                    if (bestTarget) {

                        return bestTarget;

                    }

        

                    if (forceFindTower) {

                        let closestTowerDist = Infinity;

                        let towerTarget = null;

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {

                                if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {

                                    const dist = getDistance(this, obj);

                                    if (dist < closestTowerDist) { 

                                        closestTowerDist = dist; 

                                        towerTarget = obj; 

                                    }

                                }

                            }

                        }

                        if (!towerTarget) {

                            for (const obj of gameObjects) {

                                if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {

                                    const dist = getDistance(this, obj);

                                    if (dist < closestTowerDist) { 

                                        closestTowerDist = dist; 

                                        towerTarget = obj; 

                                    }

                                }

                            }

                        }

                        return towerTarget; 

                    }

                    

                    return null;

                }

                initiateJump(target) {

                    if (this.currentJumpCooldown > 0) return false; 

                    if (this.isChargingJump || this.isJumping) return false;

                    this.isChargingJump = true;

                    this.chargeTimer = this.CHARGE_DURATION_FRAMES; 

                    this.jumpTargetX = target.x;

                    this.jumpTargetY = target.y;

                    this.jumpStartX = this.x;

                    this.jumpStartY = this.y;

                    return true;

                }

                attack() {

                    if (this.cooldownTimer <= 0) {

                        this.attackAnimationTimer = 20; 

                        if (this.target) {

                            this.attackAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                        } else {

                            this.attackAngle = this.team === 'player' ? -Math.PI / 2 : Math.PI / 2; 

                        }

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                if (!obj.isFlying && isInside(obj, this.x, this.y, this.attackWidth, this.attackHeight, this.attackAngle)) {

                                    applyDamage(obj, this.attackDamage);

                                }

                            }

                        }

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

                performJump() {

                    this.isChargingJump = false;

                    this.isJumping = true;

                    this.jumpProgress = 0;

                }

                

                endJump() {

                    // Apply splash damage on landing

                    gameObjects.push(new ExplosionEffect(this.x, this.y, this.jumpSplashRadius));

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                            if (getDistance(this, obj) < this.jumpSplashRadius) {

                                applyDamage(obj, this.jumpDamage);

                            }

                        }

                    }

                    this.currentJumpCooldown = this.jumpCooldown;

                    this.isJumping = false; 

                    this.target = null; // Clear target to force new target search after jump

                }

                update() {

                    if (this.health <= 0) return;

                    if (this.handleZapFreeze()) return;

                    // Apply spawn damage once

                    if (!this.hasDealtSpawnDamage) {

                        gameObjects.push(new ExplosionEffect(this.x, this.y, this.spawnSplashRadius));

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                                if (getDistance(this, obj) < this.spawnSplashRadius) {

                                    applyDamage(obj, this.attackDamage); 

                                }

                            }

                        }

                        this.hasDealtSpawnDamage = true;

                    }

                    if (this.currentJumpCooldown > 0) { this.currentJumpCooldown -= deltaTime * 60; } 

                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } 

                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; } 

                    // Handle Charging Jump

                    if (this.isChargingJump) {

                        this.chargeTimer -= deltaTime * 60; 

                        if (this.chargeTimer <= 0) {

                            this.performJump(); 

                        }

                        return; 

                    }

                    // Handle Animated Jump

                    if (this.isJumping) {

                        this.jumpProgress += deltaTime * 60 / this.JUMP_DURATION_FRAMES;

                        if (this.jumpProgress >= 1) {

                            this.endJump(); 

                        } else {

                            const arcHeight = 40; 

                            this.x = this.jumpStartX + (this.jumpTargetX - this.jumpStartX) * this.jumpProgress;

                            this.y = this.jumpStartY + (this.jumpTargetY - this.jumpStartY) * this.jumpProgress - arcHeight * 4 * this.jumpProgress * (1 - this.jumpProgress);

                        }

                        return; 

                    }

                    // Normal AI Behavior (after jump, or if no jump is initiated)

                    // If current target is invalid, or if it's a tower and there's a closer troop/building

                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower && this.findTarget(false) !== null) ) {

                        this.target = this.findTarget(true); 

                    }

                    // Decision Logic if target exists

                    if (this.target && this.target.health > 0) {

                        const dist = getDistance(this, this.target);

                        // Try to jump if conditions met

                        if (dist > this.attackRange && dist <= this.jumpRange && dist >= this.minJumpRange && this.currentJumpCooldown <= 0) {

                            this.initiateJump(this.target);

                            return;

                        }

                        // Melee Attack

                        if (dist <= this.attackRange) {

                            this.attack();

                        } else {

                            // Movement

                            this.move();

                        }

                    }

                }

                draw() {

                    const color = this.team === 'player' ? '#60a5fa' : '#f87171';

                    let emojiToDraw = this.originalEmoji;

                    let chargingAlpha = 1;

                    if (this.isChargingJump) {

                        emojiToDraw = this.greyEmoji;

                        // Fade in effect for grey emoji

                        chargingAlpha = 0.3 + (1 - (this.chargeTimer / this.CHARGE_DURATION_FRAMES)) * 0.7; 

                    } else if (this.isJumping) {

                        emojiToDraw = this.originalEmoji;

                        chargingAlpha = 1; // Full opacity during jump

                    }

                    

                    ctx.save();

                    ctx.globalAlpha = chargingAlpha;

                    super.draw(color, emojiToDraw, this.level);

                    ctx.restore();

                    // Draw attack animation (melee attack)

                    if (this.attackAnimationTimer > 0) {

                        const progress = this.attackAnimationTimer / 20;

                        ctx.save();

                        ctx.translate(this.x, this.y);

                        ctx.rotate(this.attackAngle);

                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`;

                        ctx.fillRect(this.radius, -this.attackWidth / 2, this.attackHeight, this.attackWidth);

                        ctx.restore();

                    }

                }

            }

            // --- ARENA 10 NEW CLASSES ---

            class FlameDragon extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['flameDragon'].stats[level];

                    super(x, y, 12, team, s.health, s.speed, 120, s.damage, s.hitSpeed, 'ðŸ²ðŸ”¥', true, true, level, allCards['flameDragon'].aggroRange);

                    this.rampMultiplier = s.rampMultiplier;

                    this.rampLevel = 0;

                    this.lastTarget = null;

                    this.maxDamage = s.maxDamage;

                }

                update() {

                    super.update();

                    if (!this.target || this.target.health <= 0 || getDistance(this, this.target) > this.attackRange) {

                        this.rampLevel = 0;

                        this.lastTarget = null;

                    }

                }

                attack() {

                    if (this.target && this.cooldownTimer <= 0) {

                        if (this.target !== this.lastTarget) {

                            this.rampLevel = 0;

                            this.lastTarget = this.target;

                        }

                        const rampMult = Math.pow(this.rampMultiplier, Math.min(8, this.rampLevel));

                        let damage = Math.floor(this.attackDamage * rampMult);

                        damage = Math.min(damage, this.maxDamage);

                        applyDamage(this.target, damage);

                        this.rampLevel++;

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

                draw() {

                    super.draw();

                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange + 10) {

                        ctx.save();

                        ctx.strokeStyle = '#f97316';

                        ctx.lineWidth = 2 + Math.min(6, this.rampLevel);

                        ctx.lineCap = 'round';

                        ctx.beginPath();

                        ctx.moveTo(this.x, this.y);

                        ctx.lineTo(this.target.x, this.target.y);

                        ctx.stroke();

                        ctx.strokeStyle = '#fef08a';

                        ctx.lineWidth = (2 + Math.min(6, this.rampLevel)) / 2;

                        ctx.beginPath();

                        ctx.moveTo(this.x, this.y);

                        ctx.lineTo(this.target.x, this.target.y);

                        ctx.stroke();

                        ctx.restore();

                    }

                }

            }

            // --- ZAP DRAGON (ARENA 12) ---

            function buildZapChain(owner, primary) {

                if (!primary) return [];

                const chain = [primary];

                const visited = new Set([primary]);

                let current = primary;

                for (let i = 1; i < (owner.chainLimit || owner.chainRadius ? owner.chainLimit : 10); i++) {

                    let next = null;

                    let minDist = Infinity;

                    for (const obj of gameObjects) {

                        if (obj.team !== owner.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower) && !visited.has(obj)) {

                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                            const dist = getDistance(current, obj);

                            if (dist <= (owner.chainRadius || 90) && dist < minDist) {

                                minDist = dist;

                                next = obj;

                            }

                        }

                    }

                    if (!next) break;

                    chain.push(next);

                    visited.add(next);

                    current = next;

                }

                return chain;

            }

            class ZapDragon extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['zapDragon'].stats[level];

                    super(x, y, 14, team, s.health, s.speed, 110, s.damage, s.hitSpeed, 'âš¡ðŸ‰', true, true, level, allCards['zapDragon'].aggroRange);

                    this.chainRadius = s.chainRadius;

                    this.chainLimit = s.chainLimit;

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    const chain = buildZapChain(this, this.target);

                    spawnZapTrail(this, chain, '#7dd3fc', 25);

                    for (const node of chain) {

                        applyDamage(node, this.attackDamage);

                        applyZapFreeze(node, 0.9);

                        if (node instanceof Tower && node.isKing && !node.isActive) {

                            node.isActive = true;

                            node.activationAnimation = 30;

                        }

                    }

                    this.cooldownTimer = this.attackCooldown;

                }

            }

            class FlameTower extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'flameTower');

                    const s = allCards['flameTower'].stats[level];

                    this.rampMultiplier = s.rampMultiplier;

                    this.attackDamage = s.damage;

                    this.attackRange = 140;

                    this.attackCooldown = s.hitSpeed * 60;

                    this.cooldownTimer = 0;

                    this.rampLevel = 0;

                    this.lastTarget = null;

                    this.target = null;

                    this.maxDamage = s.maxDamage;

                }

                // Custom update to handle targeting like a tower

                update() {

                    super.update();

                    if (this.health <= 0) return;

                    

                    // Find Target

                    if (!this.target || this.target.health <= 0 || getDistance(this, this.target) > this.attackRange) {

                        this.target = null;

                        this.rampLevel = 0;

                        this.lastTarget = null;

                        let closestDist = this.attackRange;

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit)) {

                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                const dist = getDistance(this, obj);

                                if (dist < closestDist) {

                                    closestDist = dist;

                                    this.target = obj;

                                }

                            }

                        }

                    }

                    if (this.cooldownTimer > 0) this.cooldownTimer -= deltaTime * 60;

                    

                    if (this.target && this.cooldownTimer <= 0) {

                        if (this.target !== this.lastTarget) {

                            this.rampLevel = 0;

                            this.lastTarget = this.target;

                        }

                        const rampMult = Math.pow(this.rampMultiplier, Math.min(8, this.rampLevel));

                        const damage = Math.floor(this.attackDamage * rampMult);

                        applyDamage(this.target, damage);

                        this.rampLevel++;

                        this.cooldownTimer = this.attackCooldown;

                    }

                }

                draw() {

                    super.draw();

                    if (this.target && this.target.health > 0) {

                         ctx.save();

                         ctx.strokeStyle = '#ef4444';

                         ctx.lineWidth = 3 + Math.min(6, this.rampLevel);

                         ctx.beginPath();

                         ctx.moveTo(this.x, this.y - 20);

                         ctx.lineTo(this.target.x, this.target.y);

                         ctx.stroke();

                         ctx.strokeStyle = '#fca5a5';

                         ctx.lineWidth = 1;

                         ctx.stroke();

                         ctx.restore();

                    }

                }

            }

            class ZapWizard extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['zapWizard'].stats[level];

                    super(x, y, 14, team, s.health, s.speed, 110, s.damage, s.hitSpeed, 'ðŸ§™âš¡', false, true, level, allCards['zapWizard'].aggroRange);

                    this.chainRadius = s.chainRadius;

                    this.chainLimit = s.chainLimit;

                    this.trailColor = '#7dd3fc';

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    const chain = buildZapChain(this, this.target);

                    spawnZapTrail(this, chain, this.trailColor, 25);

                    for (const node of chain) {

                        applyDamage(node, this.attackDamage);

                        applyZapFreeze(node, 0.9);

                        if (node instanceof Tower && node.isKing && !node.isActive) {

                            node.isActive = true;

                            node.activationAnimation = 30;

                        }

                    }

                    this.cooldownTimer = this.attackCooldown;

                }

            }

            class Bot extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['bot'].stats[level];

                    super(x, y, 16, team, s.health, s.speed, 25, s.damage, s.hitSpeed, 'ðŸ¤–', false, false, level, allCards['bot'].aggroRange);

                }

            }

            // --- ZAP GIANT (ARENA 10) ---

            class ZapGiant extends Giant {

                constructor(x, y, team, level = 1) {

                    const s = allCards['zapGiant'].stats[level];

                    super(x, y, team, level);

                    // Override Giant stats with ZapGiant stats

                    this.radius = 18;

                    this.health = s.health;

                    this.maxHealth = s.health;

                    this.speed = s.speed;

                    this.attackDamage = s.damage;

                    this.attackCooldown = s.hitSpeed * 60;

                    this.emoji = 'âš¡ðŸ’ª';

                    this.zapDamage = s.zapDamage;

                    this.zapRadius = s.zapRadius;

                    this.zapInterval = s.zapInterval * 60;

                    this.zapTimer = 0;

                    this.spawnDamage = s.spawnDamage;

                    this.spawnRadius = s.spawnRadius;

                    this.hasDealtSpawnDamage = false;

                }

                update() {

                    super.update(); // Call Giant's update for movement/attack/targeting buildings

                    if (this.health <= 0) return; // Don't do anything if dead

                    // Apply spawn damage once

                    if (!this.hasDealtSpawnDamage) {

                        gameObjects.push(new ExplosionEffect(this.x, this.y, this.spawnRadius));

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                                if (getDistance(this, obj) < this.spawnRadius) {

                                    applyDamage(obj, this.spawnDamage);

                                }

                            }

                        }

                        this.hasDealtSpawnDamage = true;

                    }

                    // Zap field logic

                    this.zapTimer -= deltaTime * 60; /* Scale zap timer by delta time */

                    if (this.zapTimer <= 0) {

                        this.zapTimer = this.zapInterval; // Reset timer

                        

                        // Find targets for zap chain

                        let mainTarget = null;

                        let closestDist = this.zapRadius;

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                const dist = getDistance(this, obj);

                                if (dist < closestDist) {

                                    closestDist = dist;

                                    mainTarget = obj;

                                }

                            }

                        }

                        if (mainTarget) {

                            let chain = [mainTarget];

                            let visited = new Set([mainTarget]);

                            let current = mainTarget;

                            for (let i = 1; i < 5; i++) { // Chain to up to 5 targets

                                let next = null;

                                let minDist = Infinity;

                                for (const obj of gameObjects) {

                                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower) && !visited.has(obj) && getDistance(current, obj) < this.zapRadius) {

                                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                                        let d = getDistance(current, obj);

                                        if (d < minDist) {

                                            minDist = d;

                                            next = obj;

                                        }

                                    }

                                }

                                if (next) {

                                    chain.push(next);

                                    visited.add(next);

                                    current = next;

                                } else {

                                    break;

                                }

                            }

                            spawnZapTrail(this, chain, '#7dd3fc', 25);

                            for (const obj of chain) {

                                applyDamage(obj, this.zapDamage);

                                applyZapFreeze(obj, 0.9);

                            }

                        }

                    }

                    }

                    draw() {

                        super.draw(); // Draw Giant body and health bar

                    // Draw electric field aura (subtle pulsing)

                    const pulseAlpha = 0.2 + Math.sin(performance.now() * 0.005) * 0.1; // Pulse between 0.1 and 0.3

                    ctx.save();

                    ctx.fillStyle = `rgba(100, 150, 255, ${pulseAlpha})`; // Light blue electric color

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.zapRadius + Math.sin(performance.now() * 0.01) * 5, 0, Math.PI * 2); // Subtle size pulse, based on zapRadius

                    ctx.fill();

                    ctx.restore();

                }

            }

            // --- ARENA 8 CARD CLASSES (NEW) ---

            class ChaosElemental extends Unit { 

                constructor(x, y, team, level = 1) { 

                    const s = allCards['chaosElemental'].stats[level]; 

                    super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'ðŸ‘¹', false, false, level, allCards['chaosElemental'].aggroRange); 

                } 

            }

            class ShadowClone extends Unit { 

                constructor(x, y, team, level = 1) { 

                    const s = allCards['shadowClone'].stats[level]; 

                    super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'ðŸ‘¤', false, true, level, allCards['shadowClone'].aggroRange); 

                } 

            }

            class HugeSkeleton extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['hugeSkeleton'].stats[level];

                    super(x, y, 18, team, s.health, s.speed, 25, s.damage, s.hitSpeed, 'ðŸ’€ðŸ’£', false, false, level, allCards['hugeSkeleton'].aggroRange);

                    this.bombDamage = s.bombDamage;

                    this.droppedBomb = false;

                }

            }

            class GiantBomb extends GameObject {

                constructor(x, y, team, damage, radius = 40) { /* Increased default radius */

                    super(x, y, radius, team, 1);

                    this.damage = damage;

                    this.timer = 180; // 3 seconds

                    this.maxTimer = 180;

                }

                update() {

                    this.timer -= deltaTime * 60; /* Scale timer by delta time */

                    if (this.timer <= 0) {

                        // Explode

                        gameObjects.push(new ParticleExplosion(this.x, this.y, '#ef4444'));

                        // Damage enemies

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                if (getDistance(this, obj) < this.radius) {

                                    applyDamage(obj, this.damage);

                                }

                            }

                        }

                        this.health = 0;

                    }

                }

                draw() {

                    // Pulse animation

                    const scale = 1 + Math.sin(this.timer * 0.2) * 0.1;

                    ctx.save();

                    ctx.translate(this.x, this.y);

                    ctx.scale(scale, scale);

                    ctx.font = '40px Arial'; /* Increased emoji size */

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.fillText('ðŸ’£', 0, 0);

                    // Draw Timer Bar

                    ctx.fillStyle = 'red';

                    ctx.fillRect(-15, -20, 30 * (this.timer / this.maxTimer), 4);

                    ctx.strokeStyle = 'black';

                    ctx.lineWidth = 1;

                    ctx.strokeRect(-15, -20, 30, 4);

                    ctx.restore();

                }

            }

            class Ninja extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['ninja'].stats[level];

                    super(x, y, 10, team, s.health, s.speed, 20, s.damage, s.hitSpeed, 'ðŸ¥·', false, false, level, allCards['ninja'].aggroRange);

                }

            }

class StoneGiant extends Unit {

    constructor(x, y, team, level = 1) {

        const s = allCards['stoneGiant'].stats[level];

        super(

            x,

            y,

            18,

            team,

            s.health,

            s.speed * 0.5,

            30,

            s.damage,

            s.hitSpeed,

            'ðŸ—¿',

            false,

            false,

            level,

            allCards['stoneGiant'].aggroRange

        );

        this.targetLocked = false;

        this.level = level;

        this.didSpawnMinis = false; // prevent doubleâ€‘spawn

    }

    spawnMinis() {

        if (this.didSpawnMinis) return;

        this.didSpawnMinis = true;

        try {

            const card = allCards['miniStoneGiant'];

            if (card && card.stats) {

                const stats =

                    card.stats[this.level] || card.stats[1];

                const leftMini = new MiniStoneGiant(

                    this.x - 15,

                    this.y,

                    this.team,

                    this.level

                );

                const rightMini = new MiniStoneGiant(

                    this.x + 15,

                    this.y,

                    this.team,

                    this.level

                );

                gameObjects.push(leftMini, rightMini);

                console.log(

                    'StoneGiant spawned minis:',

                    leftMini,

                    rightMini

                );

            }

        } catch (e) {

            console.error('Error spawning mini stone giants:', e);

        }

    }

    findTarget() {

        let closestTowerDist = Infinity;

        let towerTarget = null;

        for (const obj of gameObjects) {

            if (

                obj.team !== this.team &&

                obj instanceof Tower &&

                !obj.isKing

            ) {

                if (

                    (this.x < WIDTH / 2 && obj.x < WIDTH / 2) ||

                    (this.x > WIDTH / 2 && obj.x > WIDTH / 2)

                ) {

                    const dist = getDistance(this, obj);

                    if (dist < closestTowerDist) {

                        closestTowerDist = dist;

                        towerTarget = obj;

                    }

                }

            }

        }

        if (!towerTarget) {

            for (const obj of gameObjects) {

                if (

                    obj.team !== this.team &&

                    obj instanceof Tower &&

                    obj.isKing

                ) {

                    const dist = getDistance(this, obj);

                    if (dist < closestTowerDist) {

                        closestTowerDist = dist;

                        towerTarget = obj;

                    }

                }

            }

        }

        this.target = towerTarget;

        this.targetLocked = this.target != null;

    }

    update() {

        // IMPORTANT: no spawning here, only handled in cleanup

        if (this.health <= 0) return;

        if (this.handleZapFreeze()) return;

        if (this.cooldownTimer > 0) {

            this.cooldownTimer--;

        }

        if (

            this.target &&

            this.target.health > 0 &&

            getDistance(this, this.target) <= this.attackRange

        ) {

            this.attack();

            return;

        }

        if (

            !this.target ||

            this.target.health <= 0 ||

            this.target instanceof Tower

        ) {

            this.findTarget();

        }

        if (this.target && this.target.health > 0) {

            if (getDistance(this, this.target) <= this.attackRange) {

                this.attack();

            } else {

                this.move();

            }

        }

    }

}

 class MiniStoneGiant extends Unit {

    constructor(x, y, team, level = 1) {

        const card = allCards['miniStoneGiant'];

        const baseStats =

            card && card.stats

                ? card.stats[level] || card.stats[1]

                : null;

        const s =

            baseStats || {

                health: 200,

                damage: 20,

                hitSpeed: 1.3,

                speed: 0.7

            };

        const emoji = card && card.emoji ? card.emoji : 'ðŸª¨';

        const aggro =

            card && card.aggroRange ? card.aggroRange : 100;

        super(

            x,

            y,

            15,

            team,

            s.health,

            s.speed,

            25,

            s.damage,

            s.hitSpeed,

            emoji,

            false,

            false,

            level,

            aggro

        );

        this.level = level;

    }

    findTarget() {

        let closestTowerDist = Infinity;

        let towerTarget = null;

        for (const obj of gameObjects) {

            if (

                obj.team !== this.team &&

                obj instanceof Tower &&

                !obj.isKing

            ) {

                if (

                    (this.x < WIDTH / 2 && obj.x < WIDTH / 2) ||

                    (this.x > WIDTH / 2 && obj.x > WIDTH / 2)

                ) {

                    const dist = getDistance(this, obj);

                    if (dist < closestTowerDist) {

                        closestTowerDist = dist;

                        towerTarget = obj;

                    }

                }

            }

        }

        if (!towerTarget) {

            for (const obj of gameObjects) {

                if (

                    obj.team !== this.team &&

                    obj instanceof Tower &&

                    obj.isKing

                ) {

                    const dist = getDistance(this, obj);

                    if (dist < closestTowerDist) {

                        closestTowerDist = dist;

                        towerTarget = obj;

                    }

                }

            }

        }

        this.target = towerTarget;

    }

    // let Unit.update / Unit.draw handle behavior

}

class Projectile extends GameObject {
    constructor(x, y, target, team, damage, splashRadius = 0, sourceType = null) {
        super(x, y, 4, team, 1);
        this.target = target;
        this.damage = damage;
        this.speed = 5;
        this.splashRadius = splashRadius;
        this.sourceType = sourceType;
    }

    update() {
        if (!this.target || this.target.health <= 0) {
            this.health = 0;
            return;
        }
        if (this.target instanceof PhantomKnight && this.target.isInvisible) {
            this.health = 0;
            return;
        }
        const dist = getDistance(this, this.target);
        if (dist < this.speed) {
            // Hit target
            applyDamage(this.target, this.damage, {
                sourceType: this.sourceType
            });

            // Handle splash
            if (this.splashRadius > 0) {
                for (const obj of gameObjects) {
                    if (obj.team !== this.team && obj !== this.target && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                        if (getDistance(this.target, obj) < this.splashRadius) {
                            applyDamage(obj, this.damage, {
                                sourceType: this.sourceType
                            }); // Splash does full damage
                        }
                    }
                }
                // Spawn Explosion Visual
                gameObjects.push(new ParticleExplosion(this.x, this.y, '#ff5722'));
            }

            this.health = 0;
            return;
        }
        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
        this.x += Math.cos(angle) * this.speed * (deltaTime * 60); /* Scale movement by delta time */
        this.y += Math.sin(angle) * this.speed * (deltaTime * 60);
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.team === 'player' ? '#a5f3fc' : '#fecaca';
        ctx.fill();
    }
}

            class FireDragonFlameWave extends GameObject {
                constructor(x, y, dirX, dirY, team, damage, length = 180, width = 32, splashRadius = 24, options = {}) {
                    super(x, y, Math.max(length, width) * 0.5, team, 1);
                    const mag = Math.hypot(dirX, dirY) || 1;
                    this.dirX = dirX / mag;
                    this.dirY = dirY / mag;
                    this.length = length;
                    this.width = width;
                    this.damage = damage;
                    this.splashRadius = splashRadius;
                    this.endpointX = x + this.dirX * this.length;
                    this.endpointY = y + this.dirY * this.length;
                    this.baseDuration = options.duration || 12;
                    this.timer = this.baseDuration;
                    this.appliedDamage = false;
                    this.opacity = 1;
                }
                applyWaveDamage() {
                    if (this.appliedDamage) return;
                    this.appliedDamage = true;
                    const halfWidth = this.width / 2;
                    for (const obj of gameObjects) {
                        if (!obj || obj.team === this.team || obj.health <= 0) continue;
                        if (!(obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) continue;
                        const relX = obj.x - this.x;
                        const relY = obj.y - this.y;
                        const forward = relX * this.dirX + relY * this.dirY;
                        if (forward < 0 || forward > this.length) continue;
                        const perp = Math.abs(relX * this.dirY - relY * this.dirX);
                        if (perp > halfWidth) continue;
                        applyDamage(obj, this.damage, { sourceType: 'fireDragon' });
                    }
                    if (this.splashRadius > 0) {
                        for (const obj of gameObjects) {
                            if (!obj || obj.team === this.team || obj.health <= 0) continue;
                            if (!(obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) continue;
                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                            if (getDistance({ x: this.endpointX, y: this.endpointY }, obj) < this.splashRadius) {
                                applyDamage(obj, this.damage, { sourceType: 'fireDragon' });
                            }
                        }
                        gameObjects.push(new ParticleExplosion(this.endpointX, this.endpointY, '#f97316'));
                    }
                }
                update() {
                    this.applyWaveDamage();
                    const deltaFrames = deltaTime * 60;
                    this.timer -= deltaFrames;
                    this.opacity = this.baseDuration > 0 ? Math.max(0, this.timer / this.baseDuration) : 0;
                    if (this.timer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    ctx.save();
                    const perpX = -this.dirY;
                    const perpY = this.dirX;
                    const halfWidth = this.width / 2;
                    const points = [
                        { x: this.x + perpX * halfWidth, y: this.y + perpY * halfWidth },
                        { x: this.x - perpX * halfWidth, y: this.y - perpY * halfWidth },
                        { x: this.endpointX - perpX * halfWidth, y: this.endpointY - perpY * halfWidth },
                        { x: this.endpointX + perpX * halfWidth, y: this.endpointY + perpY * halfWidth }
                    ];
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                    const baseAlpha = 0.35 + (this.opacity * 0.35);
                    ctx.fillStyle = `rgba(251,146,60,${baseAlpha})`;
                    ctx.fill();
                    ctx.restore();
                }
            }

            class NebulaShard extends GameObject {

                constructor(x, y, angle, team, damage, speed = 5, lifetime = 1.2, radius = 5) {

                    super(x, y, radius, team, 1);

                    this.vx = Math.cos(angle) * speed;

                    this.vy = Math.sin(angle) * speed;

                    this.damage = damage;

                    this.lifeTimer = Math.max(0.1, lifetime) * 60;

                    this.sourceType = 'nebulaShard';

                }

                update() {

                    if (this.health <= 0) return;

                    this.lifeTimer -= deltaTime * 60;

                    if (this.lifeTimer <= 0) {

                        this.health = 0;

                        return;

                    }

                    this.x += this.vx * (deltaTime * 60);

                    this.y += this.vy * (deltaTime * 60);

                    for (const obj of gameObjects) {

                        if (!obj || obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Tower) && !(obj instanceof Building)) continue;

                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                        if (getDistance(this, obj) <= this.radius) {

                            applyDamage(obj, this.damage, { sourceType: this.sourceType });

                            this.health = 0;

                            return;

                        }

                    }

                }

                draw() {

                    ctx.save();

                    ctx.fillStyle = 'rgba(132, 204, 255, 0.85)';

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.restore();

                }

            }

            class NebulaBolt extends GameObject {

                constructor(x, y, target, team, damage, shardDamage, shardCount = 7, shardSpread = 1.2, shardSpeed = 5.5, shardLifetime = 1.0, shardRadius = 5) {

                    super(x, y, 6, team, 1);

                    this.target = target;

                    this.damage = damage;

                    this.speed = 6;

                    this.shardDamage = shardDamage;

                    this.spawnedShards = false;

                    this.shardCount = shardCount;

                    this.shardSpread = shardSpread;

                    this.shardSpeed = shardSpeed;

                    this.shardLifetime = shardLifetime;

                    this.shardRadius = shardRadius;

                    this.sourceType = 'nebulaBolt';

                }

                update() {

                    if (!this.target || this.target.health <= 0) {

                        this.health = 0;

                        return;

                    }

                    if (this.target instanceof PhantomKnight && this.target.isInvisible) {

                        this.health = 0;

                        return;

                    }

                    const dist = getDistance(this, this.target);

                    if (dist < this.speed) {

                        applyDamage(this.target, this.damage, { sourceType: this.sourceType });

                        this.spawnShards();

                        this.health = 0;

                        return;

                    }

                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                    this.x += Math.cos(angle) * this.speed * (deltaTime * 60);

                    this.y += Math.sin(angle) * this.speed * (deltaTime * 60);

                }

                spawnShards() {

                    if (this.spawnedShards) return;

                    this.spawnedShards = true;

                    const targetX = this.target ? this.target.x : this.x;

                    const targetY = this.target ? this.target.y : this.y;

                    const direction = Math.atan2(targetY - this.y, targetX - this.x);

                    const forwardOffset = 12;

                    const spawnX = targetX + Math.cos(direction) * forwardOffset;

                    const spawnY = targetY + Math.sin(direction) * forwardOffset;

                    const arc = Math.max(0.2, this.shardSpread);

                    const halfSpread = arc / 2;

                    for (let i = 0; i < this.shardCount; i++) {

                        const progress = this.shardCount === 1 ? 0.5 : i / (this.shardCount - 1);

                        const angle = direction - halfSpread + progress * arc;

                        gameObjects.push(new NebulaShard(spawnX, spawnY, angle, this.team, this.shardDamage, this.shardSpeed, this.shardLifetime, this.shardRadius));

                    }

                }

                draw() {

                    ctx.save();

                    ctx.fillStyle = '#a855f7';

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.restore();

                }

            }

            class FireballProjectile extends Projectile {

                constructor(x, y, target, team, damage, splashRadius = 0, sourceType = null) {

                    super(x, y, target, team, damage, splashRadius, sourceType);

                    this.radius = 6;

                }

                draw() {

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fillStyle = this.team === 'player' ? '#ffc107' : '#ff6f00';

                    ctx.fill();

                }

            }

            class EarthRockProjectile extends Projectile {

                constructor(x, y, target, team, damage, slowFactor, slowDuration) {

                    super(x, y, target, team, damage, 0, 'earthDragon');

                    this.radius = 6;

                    this.slowFactor = slowFactor || 0.6;

                    this.slowDuration = slowDuration || 0.5;

                    this.maxLifetime = 3 * 60;

                    this.lifetime = this.maxLifetime;

                }

                update() {

                    if (!this.target || this.target.health <= 0) {

                        this.health = 0;

                        return;

                    }

                    if (this.target instanceof PhantomKnight && this.target.isInvisible) {

                        this.health = 0;

                        return;

                    }

                    const dist = getDistance(this, this.target);

                    if (dist < this.speed) {

                        applyDamage(this.target, this.damage, { sourceType: this.sourceType });

                        applyTemporarySlow(this.target, this.slowFactor, this.slowDuration);

                        this.health = 0;

                        return;

                    }

                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                    this.x += Math.cos(angle) * this.speed * (deltaTime * 60);

                    this.y += Math.sin(angle) * this.speed * (deltaTime * 60);

                    this.lifetime -= deltaTime * 60;

                    if (this.lifetime <= 0) {

                        this.health = 0;

                    }

                }

                draw() {

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fillStyle = '#7c2d12';

                    ctx.fill();

                }

            }

            class NecromancerOrbProjectile extends Projectile {

                constructor(x, y, target, team, damage, markInfo) {

                    super(x, y, target, team, damage, 0, 'necromancer');

                    this.radius = 5;

                    this.speed = 6.25;

                    this.markInfo = markInfo;

                }

                update() {

                    if (!this.target || this.target.health <= 0) {

                        this.health = 0;

                        return;

                    }

                    if (this.target instanceof PhantomKnight && this.target.isInvisible) {

                        this.health = 0;

                        return;

                    }

                    const dist = getDistance(this, this.target);

                    if (dist < this.speed) {

                        applyDamage(this.target, this.damage, { sourceType: this.sourceType });

                        if (this.markInfo && this.target instanceof Unit) {

                            markUnitAsZombie(this.target, this.team, 'necromancer', this.markInfo);

                        }

                        this.health = 0;

                        return;

                    }

                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                    this.x += Math.cos(angle) * this.speed * (deltaTime * 60);

                    this.y += Math.sin(angle) * this.speed * (deltaTime * 60);

                }

                draw() {

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fillStyle = this.team === 'player' ? '#4ade80' : '#22c55e';

                    ctx.fill();

                }

            }

            // SnowmanKing extends Tower so that Building-targeters (Giants, etc) will target it automatically.

            class SnowmanKing extends Tower {

                constructor(x, y, team) {

                    super(x, y, team, true, 1); // isKing = true

                    this.health = 4000;

                    this.maxHealth = 4000;

                    this.speed = 1.0; 

                    this.radius = 20;

                    this.attackDamage = 0;

                    // Random Movement Props

                    this.targetX = x;

                    this.targetY = y;

                    this.pauseTimer = 0;

                    this.pickNewTarget();

                }

                

                pickNewTarget() {

                    const margin = 40;

                    let minY, maxY;

                    // Use scoped constants WIDTH, HEIGHT, RIVER_Y

                    if (this.team === 'player') {

                        minY = RIVER_Y + margin;

                        maxY = HEIGHT - margin;

                    } else {

                        minY = margin;

                        maxY = RIVER_Y - margin;

                    }

                    const minX = margin;

                    const maxX = WIDTH - margin;

                    

                    this.targetX = minX + Math.random() * (maxX - minX);

                    this.targetY = minY + Math.random() * (maxY - minY);

                }

                update() {

                    if (this.health <= 0) return;

                    if (this.dyingAnimationTimer > 0) this.dyingAnimationTimer--;

                    // Handle Pause

                    if (this.pauseTimer > 0) {

                        this.pauseTimer -= deltaTime * 60; /* Scale pause timer by delta time */

                        return;

                    }

                    // Calculate movement

                    const dx = this.targetX - this.x;

                    const dy = this.targetY - this.y;

                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 5) {

                        // Reached target -> Pause then pick new target

                        this.pauseTimer = 60 + Math.random() * 60; // Pause 1-2s

                        this.pickNewTarget();

                    } else {

                        // Move towards target

                    this.x += (dx / dist) * this.speed * (deltaTime * 60); /* Scale movement by delta time */

                    this.y += (dy / dist) * this.speed * (deltaTime * 60);

                    }

                }

                draw() {

                    ctx.save();

                    ctx.translate(this.x, this.y);

                    ctx.beginPath();

                    ctx.ellipse(0, this.radius * 0.4, this.radius, this.radius * 0.4, 0, 0, Math.PI*2);

                    ctx.fillStyle = 'rgba(0,0,0,0.3)';

                    ctx.fill();

                    ctx.font = '40px Arial';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.shadowColor = 'white';

                    ctx.shadowBlur = 10;

                    ctx.fillText('â˜ƒï¸', 0, 0);

                    ctx.restore();

                    this.drawHealthBar();

                }

            }

            // --- EFFECT CLASSES (NEW) ---

            class FreezeEffect extends GameObject {

                constructor(x, y, team, radius, duration) {

                    super(x, y, radius, team, 1);

                    this.duration = duration;

                    this.lifetime = duration;

                    this.frozenObjects = new Map(); // Store original values

                }

                update() {

                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */

                    if (this.lifetime <= 0) {

                        // Restore frozen objects

                        this.frozenObjects.forEach((originalSpeed, obj) => {

                            if (obj && obj.frozen) {

                                obj.speed = originalSpeed;

                                obj.frozen = false;

                                if (obj.frozenCooldown !== undefined) {

                                    obj.cooldownTimer = obj.frozenCooldown;

                                }

                            }

                        });

                        this.health = 0;

                        return;

                    }

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                            if (getDistance(this, obj) < this.radius) {

                                if (!obj.frozen) {

                                    obj.frozen = true;

                                    this.frozenObjects.set(obj, obj.speed);

                                    obj.speed = 0;

                                    if (obj.cooldownTimer !== undefined) {

                                        obj.frozenCooldown = obj.cooldownTimer;

                                        obj.cooldownTimer = this.lifetime;

                                    }

                                }

                            } else if (obj.frozen && this.frozenObjects.has(obj)) {

                                // Left the area, restore

                                obj.speed = this.frozenObjects.get(obj);

                                obj.frozen = false;

                                if (obj.frozenCooldown !== undefined) {

                                    obj.cooldownTimer = obj.frozenCooldown;

                                }

                                this.frozenObjects.delete(obj);

                            }

                        }

                    }

                }

                draw() {

                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;

                    ctx.fillStyle = `rgba(147, 197, 253, ${alpha})`;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                }

            }

            class ZapTrailEffect extends GameObject {

                constructor(points, color = '#7dd3fc', duration = 25) {

                    super(points[0].x, points[0].y, 4, 'neutral', 1);

                    this.points = points.map(p => ({ x: p.x, y: p.y }));

                    this.color = color;

                    this.duration = duration;

                    this.lifetime = duration;

                }

                update() {

                    this.lifetime -= deltaTime * 60;

                    if (this.lifetime <= 0) {

                        this.health = 0;

                    }

                }

                draw() {

                    if (!this.points || this.points.length < 2) return;

                    const alpha = Math.max(0, this.lifetime / this.duration);

                    ctx.save();

                    ctx.strokeStyle = this.color;

                    ctx.lineWidth = 2;

                    ctx.globalAlpha = alpha;

                    ctx.beginPath();

                    ctx.moveTo(this.points[0].x, this.points[0].y);

                    for (let i = 1; i < this.points.length; i++) {

                        ctx.lineTo(this.points[i].x, this.points[i].y);

                    }

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class HealEffect extends GameObject {

                constructor(x, y, team, radius, duration) {

                    super(x, y, radius, team, 1);

                    this.duration = duration;

                    this.lifetime = duration;

                    this.healTick = 30; // Heal every 0.5 seconds

                    this.tickTimer = this.healTick;

                    this.healAmount = 20;

                }

                update() {

                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */

                    if (this.lifetime <= 0) {

                        this.health = 0;

                        return;

                    }

                    this.tickTimer -= deltaTime * 60; /* Scale tick timer by delta time */

                    if (this.tickTimer <= 0) {

                        this.tickTimer = this.healTick;

                        for (const obj of gameObjects) {

                            if (obj.team === this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                                if (getDistance(this, obj) < this.radius && obj.health < obj.maxHealth) {

                                    obj.health = Math.min(obj.maxHealth, obj.health + this.healAmount);

                                }

                            }

                        }

                    }

                }

                draw() {

                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;

                    ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                }

            }

            class ExplosionEffect extends GameObject {

                constructor(x, y, radius) {

                    super(x, y, radius, 'neutral', 1);

                    this.animationTimer = 20;

                }

                update() {

                    this.animationTimer--;

                    if (this.animationTimer <= 0) {

                        this.health = 0;

                    }

                }

                draw() {

                    const progress = this.animationTimer / 20;

                    ctx.fillStyle = `rgba(239, 68, 68, ${0.8 * (1 - progress)})`;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);

                    ctx.fill();

                }

            }

            class SmokePuff extends GameObject {

                constructor(x, y, team, radius = 26, lifetime = 30) {

                    super(x, y, radius, team, 1);

                    this.lifetime = lifetime;

                    this.maxLifetime = lifetime;

                }



                update() {

                    this.lifetime--;

                    if (this.lifetime <= 0) {

                        this.health = 0;

                    }

                }



                draw() {

                    const progress = Math.max(0, this.lifetime / this.maxLifetime);

                    const puffRadius = this.radius * (1 + (1 - progress) * 0.6);

                    const alpha = 0.5 * Math.max(0, progress);

                    ctx.save();

                    ctx.fillStyle = `rgba(107, 114, 128, ${alpha})`;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, puffRadius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.restore();

                }



            }

            class MagnetFieldEffect extends GameObject {

                constructor(hero, radius) {

                    super(hero.x, hero.y, radius, 'neutral', 1);

                    this.hero = hero;

                    this.baseRadius = radius;

                }



                update() {

                    if (!this.hero || !this.hero.magnetActive) {

                        this.health = 0;

                        return;

                    }

                    this.x = this.hero.x;

                    this.y = this.hero.y;

                    this.radius = Math.max(20, this.hero.heroAbilityRange + 8);

                }



                draw() {

                    const glow = 0.5 + 0.5 * Math.sin(performance.now() / 250);

                    ctx.save();

                    ctx.strokeStyle = `rgba(59, 130, 246, ${0.45 + 0.45 * glow})`;

                    ctx.lineWidth = 4;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius * (0.9 + 0.1 * glow), 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class ShockwavePulse extends GameObject {

                constructor(x, y, radius) {

                    super(x, y, radius, 'neutral', 1);

                    this.animationTimer = 20;

                    this.maxTimer = 20;

                }



                update() {

                    this.animationTimer--;

                    if (this.animationTimer <= 0) {

                        this.health = 0;

                    }

                }



                draw() {

                    const progress = 1 - (this.animationTimer / this.maxTimer);

                    const pulseRadius = this.radius * (0.6 + progress * 0.5);

                    const alpha = Math.max(0, 0.9 * (1 - progress));

                    ctx.save();

                    ctx.strokeStyle = `rgba(251, 146, 60, ${alpha})`;

                    ctx.lineWidth = 3;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class AngerSpell extends GameObject {

                constructor(x, y, team, radius, duration, spawnDamage) {

                    super(x, y, radius, team, 1);

                    this.duration = duration * 60;

                    this.lifetime = this.duration;

                    this.angeredUnits = new Set();

                    this.spawnDamage = spawnDamage || 150; // High range damage on spawn

                    this.hasDealtDamage = false;

                }

                update() {

                    this.lifetime--;

                    // Spawn Damage (One-time)

                    if (!this.hasDealtDamage) {

                        this.hasDealtDamage = true;

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                                if (getDistance(this, obj) < this.radius) {

                                    applyDamage(obj, this.spawnDamage);

                                }

                            }

                        }

                        gameObjects.push(new ExplosionEffect(this.x, this.y, this.radius));

                    }

                    if (this.lifetime <= 0) {

                        // Spell expired: all buffed units/buildings/towers immediately lose Anger.

                        this.angeredUnits.forEach(unit => {

                            if (unit && unit.isAngered) {

                                if (unit.originalDamage !== undefined) {

                                    unit.attackDamage = unit.originalDamage;

                                }

                                if (unit.originalCooldown !== undefined) {

                                    unit.attackCooldown = unit.originalCooldown;

                                }

                                unit.isAngered = false;

                                unit.angeredTimer = null;

                            }

                        });

                        this.angeredUnits.clear();

                        this.health = 0;

                        return;

                    }

                    // Pass 1: apply Anger to units in the pool and start trailing timers when they leave.

                    for (const obj of gameObjects) {

                        if (obj.team === this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                            const inPool = getDistance(this, obj) < this.radius;

                            if (inPool) {

                                if (!obj.isAngered) {

                                    obj.isAngered = true;

                                    if (obj.attackDamage !== undefined) {

                                        obj.originalDamage = obj.attackDamage;

                                        obj.attackDamage = Math.floor(obj.attackDamage * 1.25); // 1.25x Damage

                                    }

                                    if (obj.attackCooldown !== undefined) {

                                        obj.originalCooldown = obj.attackCooldown;

                                        obj.attackCooldown = Math.floor(obj.attackCooldown / 1.5); // 1.5x Speed

                                    }

                                    this.angeredUnits.add(obj);

                                }

                                // While inside the pool, no trailing timer is counting down.

                                obj.angeredTimer = null;

                            } else if (obj.isAngered && this.angeredUnits.has(obj)) {

                                // Left the pool while the spell is still active: start 2s trailing buff.

                                if (obj.angeredTimer === null || obj.angeredTimer <= 0) {

                                    obj.angeredTimer = 2 * 60;

                                }

                            }

                        }

                    }

                    // Pass 2: tick down trailing timers for angered units that have left the pool.

                    this.angeredUnits.forEach(unit => {

                        if (!unit || !unit.isAngered) {

                            return;

                        }

                        if (unit.angeredTimer !== null && unit.angeredTimer > 0) {

                            unit.angeredTimer -= deltaTime * 60; /* Scale angered timer by delta time */

                            if (unit.angeredTimer <= 0) {

                                if (unit.originalDamage !== undefined) {

                                    unit.attackDamage = unit.originalDamage;

                                }

                                if (unit.originalCooldown !== undefined) {

                                    unit.attackCooldown = unit.originalCooldown;

                                }

                                unit.isAngered = false;

                                unit.angeredTimer = null;

                            }

                        }

                    });

                }

                draw() {

                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.4;

                    ctx.fillStyle = `rgba(147, 51, 234, ${alpha})`; // purple-700

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                }

            }

            class VoidTrapEffect extends GameObject {

                constructor(x, y, team, radius, damage) {

                    super(x, y, radius, team, 1);

                    this.damage = damage;

                    this.animationTimer = 30;

                    this.maxAnimationTimer = 30;

                    this.hit = false;

                    this.hitObjects = new Set();

                }

                update() {

                    if (!this.hit) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && !this.hitObjects.has(obj) && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                if (getDistance(this, obj) < this.radius) {

                                    applyDamage(obj, this.damage);

                                    this.hitObjects.add(obj);

                                }

                            }

                        }

                        this.hit = true;

                    }

                    this.animationTimer--;

                    if (this.animationTimer <= 0) {

                        this.health = 0;

                    }

                }

                draw() {

                    const progress = this.animationTimer / this.maxAnimationTimer;

                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;

                    ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.6})`;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius * (1 - progress * 0.3), 0, Math.PI * 2);

                    ctx.fill();

                    ctx.strokeStyle = `rgba(147, 51, 234, ${alpha})`;

                    ctx.lineWidth = 3;

                    ctx.stroke();

                    ctx.font = `${this.radius * 0.8}px Arial`;

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.globalAlpha = alpha;

                    ctx.fillText('âš«', this.x, this.y);

                    ctx.globalAlpha = 1;

                }

            }

            class ChaosOrbEffect extends GameObject {

                constructor(x, y, team, radius, damage) {

                    super(x, y, radius, team, 1);

                    this.damage = damage;

                    this.animationTimer = 30;

                    this.maxAnimationTimer = 30;

                    this.hit = false;

                    this.hitObjects = new Set();

                }

                update() {

                    if (!this.hit) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && !this.hitObjects.has(obj) && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                if (getDistance(this, obj) < this.radius) {

                                    applyDamage(obj, this.damage);

                                    this.hitObjects.add(obj);

                                }

                            }

                        }

                        this.hit = true;

                    }

                    this.animationTimer--;

                    if (this.animationTimer <= 0) {

                        this.health = 0;

                    }

                }

                draw() {

                    const progress = this.animationTimer / this.maxAnimationTimer;

                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;

                    ctx.fillStyle = `rgba(200, 100, 255, ${alpha * 0.5})`;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius * (1 + progress * 0.2), 0, Math.PI * 2);

                    ctx.fill();

                    ctx.font = `${Math.round(this.radius * 1.4)}px Arial`;

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.globalAlpha = alpha;

                    ctx.fillText('ðŸŒ€', this.x, this.y);

                    ctx.globalAlpha = 1;

                }

            }

            

            class SkeletonYard extends GameObject {

                constructor(x, y, team, duration, radius, level) {

                    super(x, y, radius, team, 1);

                    this.duration = duration * 60;

                    this.lifetime = this.duration;

                    this.spawnRate = 30; // 0.5s * 60

                    this.spawnTimer = 0;

                    this.radius = radius;

                    this.level = level;

                }

                update() {

                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */

                    if (this.lifetime <= 0) { this.health = 0; return; }

                    

                    this.spawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */

                    if (this.spawnTimer <= 0) {

                        this.spawnTimer = this.spawnRate;

                        // Spawn Skeleton at random pos within radius

                        const r = this.radius * Math.sqrt(Math.random());

                        const theta = Math.random() * 2 * Math.PI;

                        const sx = this.x + r * Math.cos(theta);

                        const sy = this.y + r * Math.sin(theta);

                        

                        const clampedX = Math.max(10, Math.min(400-10, sx));

                        const clampedY = Math.max(10, Math.min(500-10, sy));

                        

                        gameObjects.push(new Skeleton(clampedX, clampedY, this.team, this.level));

                    }

                }

                draw() {

                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;

                    ctx.fillStyle = `rgba(100, 116, 139, ${alpha})`;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);

                    ctx.fill();

                    if (this.lifetime % 60 < 30) {

                        ctx.fillStyle = `rgba(255,255,255, ${alpha})`;

                        ctx.font = '20px Arial';

                        ctx.textAlign = 'center';

                        ctx.textBaseline = 'middle';

                        ctx.fillText('ðŸ¦´', this.x, this.y);

                    }

                }

            }

            class Spell extends GameObject {

                constructor(x, y, team, damage, radius, emoji, isEvolved = false) {

                    super(x, y, radius, team, 1);

                    this.damage = damage;

                    this.animationTimer = 30;

                    this.maxAnimationTimer = 30;

                    this.hit = false;

                    this.emoji = emoji;

	                    this.isEvolved = isEvolved;

	                    this.flameSpawned = false;

	                    this._evoSecondVolleyTimer = 0;

	                    this._evoSecondVolleyDamage = 0;

	                    try {

	                        const arrowsEmoji = allCards?.arrows?.emoji;

	                        if (this.isEvolved && arrowsEmoji && this.emoji === arrowsEmoji) {

	                            const evoStats = allCards?.arrows?.evo?.stats || {};

	                            const delaySeconds = evoStats.secondVolleyDelaySeconds || 0.35;

	                            const multiplier = (evoStats.secondVolleyDamageMultiplier === 0 || evoStats.secondVolleyDamageMultiplier) ? evoStats.secondVolleyDamageMultiplier : 0.6;

	                            this._evoSecondVolleyTimer = Math.max(1, Math.round(delaySeconds * 60));

	                            this._evoSecondVolleyDamage = Math.max(1, Math.round(this.damage * multiplier));

	                            this.animationTimer = Math.max(this.animationTimer, this._evoSecondVolleyTimer + 30);

	                            this.maxAnimationTimer = Math.max(this.maxAnimationTimer, this.animationTimer);

	                        }

	                    } catch (e) {}

	                }

                update() {

                    if (!this.hit) {

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                if (getDistance(this, obj) < this.radius) {

                                    applyDamage(obj, this.damage);

                                }

                            }

                        }

                        this.hit = true;

                        if (this.emoji === 'ðŸ”¥' && this.isEvolved && !this.flameSpawned) {

                            this.flameSpawned = true;

                            const waveRadius = this.radius * 2.5;

                            const flameDamage = Math.round(this.damage * 0.75);

	                            gameObjects.push(new FlameWave(this.x, this.y, this.team, flameDamage, waveRadius));

	                        }

	                    }

	                    if (this.hit && this._evoSecondVolleyTimer > 0) {

	                        this._evoSecondVolleyTimer -= (deltaTime * 60);

	                        if (this._evoSecondVolleyTimer <= 0 && this._evoSecondVolleyDamage > 0) {

	                            for (const obj of gameObjects) {

	                                if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

	                                    if (getDistance(this, obj) < this.radius) {

	                                        applyDamage(obj, this._evoSecondVolleyDamage);

	                                    }

	                                }

	                            }

	                            this._evoSecondVolleyDamage = 0;

	                        }

	                    }

	                    this.animationTimer--;

                    if (this.animationTimer <= 0) {

                        this.health = 0;

                    }

                }

                draw() {

                    const progress = this.animationTimer / this.maxAnimationTimer;

                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;

                    if (this.emoji === 'ðŸŽ¯') {

                        ctx.fillStyle = `rgba(139, 69, 19, ${alpha * 0.2})`;

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                        ctx.fill();

                        ctx.font = `20px Arial`;

                        ctx.textAlign = 'center';

                        ctx.textBaseline = 'middle';

                        ctx.fillStyle = `rgba(101, 67, 33, ${alpha})`;

                        let yOffset = -this.radius + (this.radius * 2 * (1 - progress));

                        ctx.globalAlpha = alpha;

                        ctx.fillText('â¬‡ï¸', this.x - 20, this.y - 20 + yOffset);

                        ctx.fillText('â¬‡ï¸', this.x + 20, this.y - 10 + yOffset);

                        ctx.fillText('â¬‡ï¸', this.x, this.y + 20 + yOffset);

                        ctx.globalAlpha = 1;

                    } else if (this.emoji === 'ðŸ”¥') {

                        ctx.fillStyle = `rgba(253, 224, 71, ${alpha * 0.8})`;

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);

                        ctx.fill();

                        ctx.font = `${this.radius * 2}px Arial`;

                        ctx.textAlign = 'center';

                        ctx.textBaseline = 'middle';

                        ctx.globalAlpha = alpha;

                        ctx.fillText(this.emoji, this.x, this.y);

                        ctx.globalAlpha = 1;

                    }

                }

            }

            class StarlightCascadeSpell extends GameObject {

                constructor(x, y, team, damage, radius, pulses = 3, pulseDelay = 0.5) {

                    super(x, y, radius, team, 1);

                    this.damage = damage;

                    this.maxRadius = radius || 120;

                    this.pulses = Math.max(1, pulses);

                    this.pulseDelay = Math.max(0.1, pulseDelay);

                    this.pulseTimer = 0;

                    this.pulseCount = 0;

                    this.activeRadius = 0;

                    this.fadeTimer = 0.4;

                }

                update() {

                    this.pulseTimer -= deltaTime;

                    if (this.pulseTimer <= 0 && this.pulseCount < this.pulses) {

                        this.pulseTimer = this.pulseDelay;

                        this.pulseCount++;

                        this.activeRadius = (this.maxRadius / this.pulses) * this.pulseCount;

                        this.applyPulse();

                        if (this.pulseCount >= this.pulses) {

                            this.fadeTimer = 0.4;

                        }

                    }

                    if (this.pulseCount >= this.pulses) {

                        this.fadeTimer -= deltaTime;

                        if (this.fadeTimer <= 0) {

                            this.health = 0;

                        }

                    }

                }

                applyPulse() {

                    for (const obj of gameObjects) {

                        if (!obj || obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Tower) && !(obj instanceof Building)) continue;

                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                        if (getDistance(this, obj) <= this.activeRadius) {

                            applyDamage(obj, this.damage, { sourceType: 'starlightCascade' });

                        }

                    }

                }

                draw() {

                    if (this.pulseCount <= 0) return;

                    ctx.save();

                    const fade = Math.max(0, (this.pulses - this.pulseCount) / this.pulses);

                    ctx.strokeStyle = `rgba(192, 132, 252, ${0.35 + 0.25 * fade})`;

                    ctx.lineWidth = 4;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.activeRadius, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class TornadoSpell extends GameObject {

                constructor(x, y, team, radius, duration, pullStrength, damagePerSecond, emoji = 'ðŸŒªï¸') {

                    super(x, y, radius, team, 1);

                    this.duration = (duration || 4) * 60;

                    this.lifetime = this.duration;

                    this.pullStrength = pullStrength || 6;

                    this.damagePerSecond = damagePerSecond || 30;

                    this.emoji = emoji;

                    this.tickInterval = 15;

                    this.tickTimer = this.tickInterval;

                    this.spin = 0;

                }

                update() {

                    const frameDelta = Math.max(1, deltaTime * 60);

                    this.lifetime -= frameDelta;

                    if (this.lifetime <= 0) {

                        this.health = 0;

                        return;

                    }

                    const pullPerFrame = this.pullStrength * frameDelta;

                    for (const obj of gameObjects) {

                        if (!obj || obj.team === this.team) continue;

                        if (!(obj instanceof Unit)) continue;

                        const dx = this.x - obj.x;

                        const dy = this.y - obj.y;

                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.radius + (obj.radius || 0) && distance > 0.5) {

                            const moveTarget = Math.max(0, distance - 6);

                            const step = Math.min(pullPerFrame, moveTarget);

                            if (step > 0) {

                                obj.x += (dx / distance) * step;

                                obj.y += (dy / distance) * step;

                            }

                        }

                    }

                    this.spin += 0.05 * (frameDelta / 60);

                    this.tickTimer -= frameDelta;

                    if (this.tickTimer <= 0) {

                        this.tickTimer = this.tickInterval;

                        const tickDamage = Math.max(1, Math.round((this.damagePerSecond || 20) * (this.tickInterval / 60)));

                        for (const obj of gameObjects) {

                            if (!obj || obj.team === this.team) continue;

                            if (obj instanceof Unit || obj instanceof Building || obj instanceof Tower) {

                                if (getDistance(this, obj) < this.radius) {

                                    applyDamage(obj, tickDamage);

                                }

                            }

                        }

                    }

                }

                draw() {

                    const progress = Math.max(0, Math.min(1, this.lifetime / this.duration));

                    const glow = 0.25 + 0.15 * Math.sin((1 - progress) * Math.PI * 2);

                    ctx.save();

                    ctx.globalAlpha = glow;

                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);

                    gradient.addColorStop(0, 'rgba(59, 130, 246, 0.8)');

                    gradient.addColorStop(0.5, 'rgba(14, 165, 233, 0.5)');

                    gradient.addColorStop(1, 'rgba(14, 165, 233, 0)');

                    ctx.fillStyle = gradient;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.lineWidth = 3;

                    ctx.strokeStyle = `rgba(99, 102, 241, ${glow})`;

                    for (let i = 0; i < 3; i++) {

                        ctx.beginPath();

                        const arcRadius = this.radius * (0.35 + i * 0.15);

                        ctx.arc(this.x, this.y, arcRadius, this.spin + i, this.spin + i + Math.PI * 1.6);

                        ctx.stroke();

                    }

                    ctx.restore();

                    ctx.save();

                    ctx.font = 'bold 18px Inter';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.fillStyle = '#fff';

                    ctx.fillText(this.emoji || 'ðŸŒªï¸', this.x, this.y);

                    ctx.restore();

                }

            }

            class FlameWave extends GameObject {

                constructor(x, y, team, damage, maxRadius) {

                    super(x, y, maxRadius, team, 1);

                    this.damage = damage;

                    this.duration = 60;

                    this.life = this.duration;

                    this.startRadius = maxRadius * 0.3;

                    this.maxRadius = maxRadius;

                    this.radius = this.startRadius;

                    this.targetsDamaged = new Set();

                }

                update() {

                    this.life -= deltaTime * 60;

                    if (this.life <= 0) {

                        this.health = 0;

                        return;

                    }

                    const progress = 1 - (this.life / this.duration);

                    this.radius = this.startRadius + (this.maxRadius - this.startRadius) * progress;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                            if (this.targetsDamaged.has(obj)) continue;

                            if (getDistance(this, obj) < this.radius) {

                                applyDamage(obj, this.damage);

                                this.targetsDamaged.add(obj);

                            }

                        }

                    }

                }

                draw() {

                    const fade = Math.sin((this.life / this.duration) * Math.PI);

                    ctx.save();

                    ctx.globalAlpha = fade * 0.6;

                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);

                    gradient.addColorStop(0, 'rgba(255, 200, 0, 0.9)');

                    gradient.addColorStop(0.7, 'rgba(255, 112, 0, 0.5)');

                    gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');

                    ctx.fillStyle = gradient;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.restore();

                }

            }

            

            // NEW: Poison Spell Class

            class PoisonSpell extends GameObject {

                constructor(x, y, team, damagePerSecond, radius, duration, targetsTroopsOnly = false) {

                    super(x, y, radius, team, 1);

                    this.damagePerSecond = damagePerSecond;

                    this.duration = duration * 60; // 5 seconds

                    this.lifetime = this.duration;

                    this.damageTick = 60; // Damage every 1 second

                    this.tickTimer = this.damageTick;

                    this.targetsTroopsOnly = targetsTroopsOnly;

                }

                update() {

                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */

                    if (this.lifetime <= 0) {

                        this.health = 0;

                        return;

                    }

                    this.tickTimer -= deltaTime * 60; /* Scale tick timer by delta time */

                    if (this.tickTimer <= 0) {

                        this.tickTimer = this.damageTick;

                for (const obj of gameObjects) {

                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                        if (this.targetsTroopsOnly && !(obj instanceof Unit)) continue;

                        if (getDistance(this, obj) < this.radius) {

                            applyDamage(obj, this.damagePerSecond);

                        }

                    }

                }

                    }

                }

                draw() {

                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3; // Fades in and out

                    ctx.fillStyle = `rgba(234, 179, 8, ${alpha})`; // yellow-500

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                }

            }

            // ==============================================

            // GAME LOGIC (FUNCTIONS)

            // MOVED UP TO FIX DEMO MODE

            // ==============================================

            // --- FIX: Moved initCardSystem to be the FIRST function defined ---

            function initCardSystem() {

                allCards = {

                    // Arena 1

                    'knight': { name: 'Knight', cost: 3, emoji: 'âš”ï¸', type: 'Melee', unitClass: Knight, placementRadius: 12, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 500, damage: 65, hitSpeed: 1.2, speed: 0.9 } },

                                // Evolution: Shielded Knight reflects damage for 5 seconds. Uses same base stats.

                                evo: { cycle: 2, desc: 'Gains a shield for 5 seconds. Damage dealt to the knight is reflected back at the attacker while the shield lasts.', stats: { health: 500, damage: 65, hitSpeed: 1.2, speed: 0.9, shieldDuration: 5, shieldHits: 1, shieldReflect: 100 } } },

                    'archer': { name: 'Archer', cost: 4, emoji: 'ðŸ¹', type: 'Ranged', unitClass: Archer, placementRadius: 10, isFlying: false, arena: 1, targets: 'Air & Ground', aggroRange: 120,

                                stats: { 1: { health: 250, damage: 40, hitSpeed: 1, speed: 0.9 } },

                                // Evolution: Fires splash arrows that deal area damage.

                                evo: { cycle: 2, desc: 'Shoots explosive arrows that deal splash damage around the target.', stats: { health: 250, damage: 50, hitSpeed: 1, speed: 0.9, splashRadius: 20, splashDamage: 20 } } },

                    'giant': { name: 'Giant', cost: 5, emoji: 'ðŸ’ª', type: 'Tank', unitClass: Giant, placementRadius: 18, isFlying: false, arena: 1, targets: 'Buildings', aggroRange: 100,

	                                stats: { 1: { health: 1000, damage: 60, hitSpeed: 1.5, speed: 0.5 } },

	                                stats: { 1: { health: 1000, damage: 60, hitSpeed: 1.5, speed: 0.5 } } },

                    'goblins': { name: 'Goblins', cost: 2, emoji: 'ðŸ‘º', type: 'Swarm', unitClass: Goblins, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, speed: 1.0 } },

                                // Evolution: Damage increases by 25% after each hit until the goblin dies.

                                evo: { cycle: 1, desc: 'Damage increases by 25% after each hit until the goblin dies.', stats: { damageBoostPercent: 25 } } },

                    'skeletons': { name: 'Skeletons', cost: 1, emoji: 'ðŸ’€', type: 'Swarm', unitClass: Skeletons, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { count: 3, health: 14, damage: 11, hitSpeed: 1.2, speed: 1.2 } },

                                // Evolution: Each skeleton clones itself on each attack up to a max of 10 skeletons.

                                evo: { cycle: 1, desc: 'On each attack, clones itself up to a maximum of 10 skeletons at a time.', stats: { count: 4, health: 14, damage: 11, hitSpeed: 1.2, speed: 1.2, cloneLimit: 10 } } },

                    'tinyBot': { name: 'Tiny Bot', cost: 4, emoji: 'ðŸ¤–', type: 'Melee', unitClass: TinyBot, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 630, damage: 220, hitSpeed: 1.9, speed: 0.68 } } },

                    'fireball': { name: 'Fireball', cost: 4, emoji: 'ðŸ”¥', type: 'Spell', radius: 50, placementRadius: 50, arena: 1, targets: 'Air & Ground',

                                stats: { 1: { damage: 250 } },

                                // Evolution: Leaves a lingering fire that deals additional damage in an area.

                                evo: { cycle: 1, desc: 'After the initial explosion, leaves a ring of fire that deals additional damage over time.', stats: { damage: 300 } } },

	                    'arrows': { name: 'Arrows', cost: 3, emoji: 'ðŸŽ¯', type: 'Spell', radius: 80, placementRadius: 80, arena: 1, targets: 'Air & Ground',

	                                stats: { 1: { damage: 140 } },

	                                // Evolution: Fires a second delayed volley at the same location.

	                                evo: { cycle: 1, desc: 'Fires a second delayed volley at the same location for reduced damage.', stats: { secondVolleyDelaySeconds: 0.35, secondVolleyDamageMultiplier: 0.6 } } },

                    // Arena 2

                    'hut': { name: 'Goblin House', cost: 5, emoji: 'ðŸ ', type: 'Building', unitClass: GoblinHut, placementRadius: 20, isFlying: false, arena: 2, targets: '-',

                                stats: { 1: { health: 800, spawn_speed: '5s', lifetime: '30s' } } },

                    'skeletonArmy': { name: 'Skeleton Group', cost: 3, emoji: 'â˜ ï¸', type: 'Swarm', unitClass: SkeletonArmy, placementRadius: 10, isFlying: false, arena: 2, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { count: 20, health: 22, damage: 20, hitSpeed: 1.2, speed: 1.4 } } }, // Speed 1.6 -> 1.4, stats buffed so it can chew through bots

                    'goblinGang': { name: 'Goblin Group', cost: 3, emoji: 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦', type: 'Swarm', unitClass: GoblinGang, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground', aggroRange: 100,

                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, speed: 1.0, spear_count: 3, spear_health: 60, spear_damage: 25, spear_hitSpeed: 1.2, spear_speed: 1.0 } },

                                evo: { cycle: 1, desc: 'When a group member dies while at least one other survives, it becomes a ghost that trails the squad for 3 seconds before respawning once, and only one respawn can queue at a time.', stats: { ghostDuration: 3, respawnLimit: 1 } } },

                    'spearGoblins': { name: 'Spear Goblins', cost: 2, emoji: 'ðŸŽ¯', type: 'Swarm', unitClass: SpearGoblins, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground', aggroRange: 100,

                                stats: { 1: { count: 3, health: 60, damage: 25, hitSpeed: 1.2, speed: 1.0 } } },

                    // Arena 3

	                    'fireDragon': { name: 'Fire Dragon', cost: 4, emoji: 'ðŸ²', type: 'Air', unitClass: FireDragon, placementRadius: 14, isFlying: true, arena: 3, targets: 'Air & Ground', aggroRange: 120,

                                stats: { 1: { health: 800, damage: 100, hitSpeed: 1.0, speed: 0.8, splashRadius: 20 } },

	                                // Evolution: The evolved attack cleaves a sweeping flame wave through the lane after striking.

                                evo: { cycle: 2, desc: 'After the initial hit, a narrow flame wave stretches ahead of the dragon, scorching every ground target it touches.', stats: { waveDamage: 40, waveLength: 48 } } },

                    'barbarians': { name: 'Barbarians', cost: 5, emoji: 'ðŸ§”', type: 'Swarm', unitClass: Barbarians, placementRadius: 10, isFlying: false, arena: 3, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { count: 5, health: 330, damage: 48, hitSpeed: 1.3, speed: 0.85 } },

                                // Evolution: Each barbarian starts with a shield that blocks two hits.

                                evo: { cycle: 2, desc: 'Each barbarian gains a shield that blocks two hits from any attack before breaking.', stats: { count: 5, health: 330, damage: 48, hitSpeed: 1.3, speed: 0.85, shieldHits: 2 } } },

                    'battleRam': { name: 'Battle Ram', cost: 4, emoji: 'ðŸŒ²', type: 'WinCon', unitClass: BattleRam, placementRadius: 10, isFlying: false, arena: 3, targets: 'Buildings', aggroRange: 100,

                                stats: { 1: { health: 250, damage: 200, chargeSpeed: 2.0, barbLevel: 1, speed: 0.8 } } },

                    'barbarianHut': { name: 'Barbarian House', cost: 7, emoji: 'ðŸ˜ï¸', type: 'Building', unitClass: BarbarianHut, placementRadius: 20, isFlying: false, arena: 3, targets: '-',

                                stats: { 1: { health: 1000, spawn_speed: '10s', lifetime: '40s', barbLevel: 1 } } },

                    'axeSwinger': { name: 'Axe Swinger', cost: 4, emoji: 'ðŸª“', type: 'Melee', unitClass: AxeSwinger, placementRadius: 12, isFlying: false, arena: 3, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 700, damage: 100, hitSpeed: 1.5, splashRadius: 32, speed: 0.8 } } },

                    // Arena 4 (NEW CARDS)

                    'pigs': { name: 'Pigs', cost: 4, emoji: 'ðŸ·', type: 'WinCon', unitClass: Pigs, placementRadius: 10, isFlying: false, arena: 4, targets: 'Buildings', aggroRange: 100,

                                stats: { 1: { count: 4, health: 220, damage: 35, hitSpeed: 1.1, speed: 1.2 } },

	                                evo: { cycle: 2, desc: 'Iron snouts shove aside enemy troops while charging and deal bonus damage to towers.', stats: { pushRadius: 60, pushForce: 60, pushCooldownFrames: 12, towerBonusDamage: 20 } } },

                    'farmer': { name: 'Farmer', cost: 3, emoji: 'ðŸ‘¨â€ðŸŒ¾', type: 'Melee', unitClass: Farmer, placementRadius: 12, isFlying: false, arena: 4, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 600, damage: 70, hitSpeed: 1.4, attackWidth: 30, attackHeight: 40, speed: 0.8 } },

                                evo: { cycle: 1, desc: 'Summons viney plants that pull an out-of-rectangle enemy straight into the Farmerâ€™s swipe so the attack never misses.', stats: { plantRange: 90, plantPull: 18, plantLifetime: 1.5 } } },

                    'poison': { name: 'Poison', cost: 4, emoji: 'ðŸ¤¢', type: 'Spell', radius: 60, placementRadius: 60, arena: 4, targets: 'Air & Ground',

                                stats: { 1: { damagePerSecond: 40, duration: 5 } } },

                    // Arena 5 (NEW CARDS)

                    'flyingSkeletons': { name: 'Flying Skeletons', cost: 3, emoji: 'ðŸ’€ðŸ¦‡', type: 'Swarm', unitClass: FlyingSkeletons, placementRadius: 10, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,

                                stats: { 1: { count: 3, health: 40, damage: 40, hitSpeed: 1, speed: 1.2 } } },

                    'megaFlyingSkeleton': { name: 'Mega Flying Skeleton', cost: 4, emoji: 'ðŸ’€ðŸ¦‡', type: 'Air', unitClass: MegaFlyingSkeleton, placementRadius: 12, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,

                                stats: { 1: { health: 600, damage: 100, hitSpeed: 1.3, speed: 1.0 } } },

                    'flyingSkeletonGroup': { name: 'Flying Skeleton Group', cost: 5, emoji: 'ðŸ’€ðŸ¦‡', type: 'Swarm', unitClass: FlyingSkeletonGroup, placementRadius: 10, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,

                                stats: { 1: { count: 6, health: 40, damage: 40, hitSpeed: 1, speed: 1.2 } } },

                    // Arena 6 (NEW CARDS)

                    'warlock': { name: 'Warlock', cost: 5, emoji: 'ðŸ”®', type: 'Ranged', unitClass: Warlock, placementRadius: 12, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 110,

                                stats: { 1: { health: 420, damage: 82, hitSpeed: 1.7, splashRadius: 20, speed: 0.75 } } },

                    // Arena 7 (NEW)

                    'mage': { name: 'Mage', cost: 5, emoji: 'ðŸ§™â€â™€ï¸', type: 'Ranged', unitClass: Mage, placementRadius: 12, isFlying: false, arena: 7, targets: 'Air & Ground', aggroRange: 110,

                        stats: { 1: { health: 350, damage: 120, hitSpeed: 1.5, splashRadius: 30, speed: 1.0 } } },

                    // Arena 7 (NEW CARDS)

                                        'phantomKnight': { name: 'Phantom Knight', cost: 4, emoji: 'ðŸ‘»âš”ï¸', type: 'Melee', unitClass: PhantomKnight, placementRadius: 12, isFlying: false, arena: 7, targets: 'Troops', aggroRange: 110,

                        stats: { 1: { health: 500, damage: 70, hitSpeed: 1.1, speed: 1.2 } } },

                    'spiritLantern': { name: 'Spirit Lantern', cost: 5, emoji: 'ðŸ®', type: 'Building', unitClass: SpiritLantern, placementRadius: 18, isFlying: false, arena: 7, targets: '-',

                        stats: { 1: { health: 900, spawn_speed: '6s', lifetime: '24s' } } },

                    'zapSpirit': { name: 'Zap Spirit', cost: 1, emoji: 'âš¡', type: 'Spirit', unitClass: ZapSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,

                                stats: { 1: { health: 150, jumpRadius: 90, effectRadius: 70, damage: 100, speed: 1.2 } } },

                    'coldSpirit': { name: 'Cold Spirit', cost: 1, emoji: 'â„ï¸', type: 'Spirit', unitClass: ColdSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,

                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 60, freezeDuration: 3, speed: 1.2 } } },

                    'lifeSpirit': { name: 'Life Spirit', cost: 1, emoji: 'ðŸ’š', type: 'Spirit', unitClass: LifeSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: '-', aggroRange: 200,

                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 60, healDuration: 3, speed: 1.2 } } },

                    'bombSpirit': { name: 'Bomb Spirit', cost: 2, emoji: 'ðŸ’£', type: 'Spirit', unitClass: BombSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,

                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 50, damage: 200, speed: 1.2 } } },

                    'anger': { name: 'Anger', cost: 3, emoji: 'ðŸ˜¡', type: 'Spell', radius: 60, placementRadius: 60, arena: 6, targets: 'Air & Ground', 

                                stats: { 1: { duration: 5, damage: 110 } } },

                    // Arena 8 (NEW CARDS)

                    'chaosElemental': { name: 'Chaos Elemental', cost: 5, emoji: 'ðŸ‘¹', type: 'Melee', unitClass: ChaosElemental, placementRadius: 12, isFlying: false, arena: 8, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 750, damage: 110, hitSpeed: 1.1, speed: 0.8 }, 2: { health: 825, damage: 121, hitSpeed: 1.1, speed: 0.8 }, 3: { health: 908, damage: 133, hitSpeed: 1.1, speed: 0.8 }, 4: { health: 998, damage: 146, hitSpeed: 1.1, speed: 0.8 }, 5: { health: 1098, damage: 161, hitSpeed: 1.1, speed: 0.8 }, 6: { health: 1208, damage: 177, hitSpeed: 1.1, speed: 0.8 } } },

                    'shadowClone': { name: 'Shadow Clone', cost: 4, emoji: 'ðŸ‘¤', type: 'Ranged', unitClass: ShadowClone, placementRadius: 10, isFlying: false, arena: 8, targets: 'Air & Ground', aggroRange: 120,

                                stats: { 1: { health: 320, damage: 55, hitSpeed: 1.2, speed: 0.8 }, 2: { health: 352, damage: 61, hitSpeed: 1.2, speed: 0.8 }, 3: { health: 387, damage: 67, hitSpeed: 1.2, speed: 0.8 }, 4: { health: 426, damage: 73, hitSpeed: 1.2, speed: 0.8 }, 5: { health: 469, damage: 81, hitSpeed: 1.2, speed: 0.8 }, 6: { health: 516, damage: 89, hitSpeed: 1.2, speed: 0.8 } } },

                    'voidTrap': { name: 'Void Trap', cost: 4, emoji: 'âš«', type: 'Spell', radius: 70, placementRadius: 70, arena: 8, targets: 'Air & Ground',

                                stats: { 1: { damage: 180 } } },

                    'stoneGiant': { name: 'Stone Giant', cost: 8, emoji: 'ðŸ—¿', type: 'Tank', unitClass: StoneGiant, placementRadius: 18, isFlying: false, arena: 8, targets: 'Towers', aggroRange: 100,

                                stats: { 1: { health: 1750, damage: 104, hitSpeed: 1.3, speed: 0.4 }, 2: { health: 1925, damage: 114, hitSpeed: 1.3, speed: 0.4 }, 3: { health: 2118, damage: 125, hitSpeed: 1.3, speed: 0.4 }, 4: { health: 2329, damage: 138, hitSpeed: 1.3, speed: 0.4 }, 5: { health: 2563, damage: 152, hitSpeed: 1.3, speed: 0.4 }, 6: { health: 2819, damage: 167, hitSpeed: 1.3, speed: 0.4 } } },

                    'miniStoneGiant': { name: 'Mini Stone Giant', cost: 0, emoji: 'ðŸª¨', type: 'Troop', unitClass: MiniStoneGiant, placementRadius: 12, isFlying: false, hidden: true, targets: 'Towers', aggroRange: 80,

                            stats: { 1: { health: 700, damage: 41, hitSpeed: 1.3, speed: 0.5 }, 2: { health: 770, damage: 46, hitSpeed: 1.3, speed: 0.5 }, 3: { health: 848, damage: 51, hitSpeed: 1.3, speed: 0.5 }, 4: { health: 931, damage: 55, hitSpeed: 1.3, speed: 0.5 }, 5: { health: 1025, damage: 61, hitSpeed: 1.3, speed: 0.5 }, 6: { health: 1128, damage: 67, hitSpeed: 1.3, speed: 0.5 } } },

                    'chaosOrb': { name: 'Chaos Orb', cost: 3, emoji: 'ðŸŒ€', type: 'Spell', radius: 50, placementRadius: 50, arena: 8, targets: 'Air & Ground',

                                stats: { 1: { damage: 200 } } },

                    'tornado': { name: 'Tornado', cost: 3, emoji: 'ðŸŒªï¸', type: 'Spell', radius: 90, placementRadius: 90, arena: 9, targets: 'Air & Ground',

                                stats: { 1: { duration: 4.5, damagePerSecond: 36, pullStrength: 5 } } },

                    // Arena 9 (NEW)

                    'skeletonYard': { name: 'Skeleton Yard', cost: 5, emoji: 'ðŸª¦', type: 'Spell', radius: 50, placementRadius: 50, arena: 9, targets: 'Ground',

                                stats: { 1: { duration: 7.5 } } },

                    'hugeSkeleton': { name: 'Huge Skeleton', cost: 6, emoji: 'ðŸ’€ðŸ’£', type: 'Tank', unitClass: HugeSkeleton, placementRadius: 18, isFlying: false, arena: 9, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 2000, damage: 100, hitSpeed: 1.5, speed: 0.6, bombDamage: 900 } } },

                    'ninja': { name: 'Ninja', cost: 4, emoji: 'ðŸ¥·', type: 'Melee', unitClass: Ninja, placementRadius: 12, isFlying: false, arena: 9, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 200, damage: 50, hitSpeed: 0.7, speed: 1.2 } } },

                                        'meteor': { name: 'Meteor', cost: 6, emoji: 'â˜„ï¸', type: 'Spell', radius: 40, placementRadius: 40, arena: 9, targets: 'Air & Ground',

                                stats: { 1: { damage: 250 } } },

                    // Arena 10 (NEW)

                    'megaSmasher': { name: 'Mega Smasher', cost: 7, emoji: 'ðŸ’¥', type: 'Tank', unitClass: MegaSmasher, placementRadius: 18, isFlying: false, arena: 10, targets: 'Ground', aggroRange: 120,

                                stats: { 1: { health: 1250, damage: 100, hitSpeed: 1.8, speed: 0.4, spawnSplashRadius: 70, jumpDamage: 150, jumpSplashRadius: 80, jumpRange: 100, jumpCooldown: 6, minJumpRange: 40, attackWidth: 60, attackHeight: 40 } } },

                    'zapGiant': { name: 'Zap Giant', cost: 7, emoji: 'âš¡ðŸ’ª', type: 'Tank', unitClass: ZapGiant, placementRadius: 18, isFlying: false, arena: 10, targets: 'Buildings', aggroRange: 100,

                                stats: { 1: { health: 1800, damage: 80, hitSpeed: 1.5, speed: 0.3, spawnDamage: 200, spawnRadius: 60, zapDamage: 50, zapRadius: 90, zapInterval: 1.5 } } },

                    'flameDragon': { name: 'Flame Dragon', cost: 4, emoji: 'ðŸ²ðŸ”¥', type: 'Air', unitClass: FlameDragon, placementRadius: 14, isFlying: true, arena: 10, targets: 'Air & Ground', aggroRange: 120,

                                stats: { 1: { health: 600, damage: 16, hitSpeed: 0.4, speed: 0.8, rampMultiplier: 1.05, maxDamage: 150 } } },

                    'flameTower': { name: 'Flame Tower', cost: 5, emoji: 'ðŸ¯ðŸ”¥', type: 'Building', unitClass: FlameTower, placementRadius: 20, isFlying: false, arena: 10, targets: 'Air & Ground',

                                stats: { 1: { health: 1400, damage: 20, hitSpeed: 1.0, lifetime: '40s', spawn_speed: '0s', rampMultiplier: 1.3, maxDamage: 250 } } },

                    'bot': { name: 'Bot', cost: 7, emoji: 'ðŸ¤–', type: 'Melee', unitClass: Bot, placementRadius: 15, isFlying: false, arena: 10, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 1200, damage: 350, hitSpeed: 2.0, speed: 0.3 } } },

                    // === Arena 11: Diddy's Prison ===

                    // New building that spawns a Diddy Goblin when it expires or dies

                    'diddyCage': { name: 'Diddy Cage', cost: 5, emoji: 'ðŸ¦', type: 'Building', unitClass: DiddyCage, placementRadius: 20, isFlying: false, arena: 11, targets: '-',

                        stats: { 1: { health: 900, spawn_speed: '0s', lifetime: '25s' } } },

                    // Deployable miner that can be placed anywhere; treated as a spell to bypass placement restrictions

                    'diddyMiner': { name: 'Diddy Miner', cost: 4, emoji: 'â›ï¸', type: 'Spell', radius: 0, placementRadius: 0, unitClass: DiddyMiner, arena: 11, targets: 'Ground',

                        stats: { 1: { health: 650, damage: 10, hitSpeed: 1.2, speed: 1.0 } } },

                    // Massive ape-like giant with an anger aura

                    'diddyGiant': { name: 'Diddy Giant', cost: 7, emoji: 'ðŸµðŸ’ª', type: 'Tank', unitClass: DiddyGiant, placementRadius: 18, isFlying: false, arena: 11, targets: 'Buildings', aggroRange: 100,

                        stats: { 1: { health: 1800, damage: 70, hitSpeed: 1.5, speed: 0.5 } } },

                    // Arena 12 win condition: Splits into elixir shards that reward opponents on death

                    'elixirGiant': { name: 'Elixir Giant', cost: 8, emoji: 'ðŸ§ª', type: 'WinCon', unitClass: ElixirGiant, placementRadius: 22, isFlying: false, arena: 12, targets: 'Buildings', aggroRange: 130,

                                stats: { 1: { health: 1500, damage: 140, hitSpeed: 1.7, speed: 0.55 } } },

                    'horseRider': { name: 'Horse Rider', cost: 6, emoji: 'ðŸŽâš”ï¸', type: 'Melee', unitClass: HorseRider, placementRadius: 14, isFlying: false, arena: 12, targets: 'Ground', aggroRange: 120,

                                stats: { 1: { health: 1250, damage: 100, hitSpeed: 1.3, speed: 1.0, chargeDamage: 150, chargePrep: 3, chargeSpeed: 2.0, riverJumpDelay: 0.5, riverJumpDuration: 40, riverJumpHeight: 45 } } },

                    'fish': { name: 'Fish', cost: 2, emoji: 'ðŸŸ', type: 'Melee', unitClass: Fish, placementRadius: 9, isFlying: false, arena: 13, targets: 'Ground', aggroRange: 110,

                                stats: { 1: { health: 220, damage: 110, hitSpeed: 1.2, speed: 1.4, radius: 9, attackRange: 18, splashRadius: 40 } } },

                    'flyingFish': { name: 'Flying Fish', cost: 3, emoji: 'ðŸ ', type: 'Air', unitClass: FlyingFish, placementRadius: 12, isFlying: true, arena: 13, targets: 'Buildings', aggroRange: 140,

                                stats: { 1: { health: 520, damage: 160, hitSpeed: 1.2, speed: 1.25, radius: 12, attackRange: 20 } } },

                    'fishergirl': { name: 'Fishergirl', cost: 6, emoji: 'ðŸ§œâ€â™€ï¸', type: 'Ranged', unitClass: Fishergirl, placementRadius: 12, isFlying: false, arena: 13, targets: 'Air & Ground', aggroRange: 140,

                                stats: { 1: { health: 860, damage: 120, hitSpeed: 1.4, speed: 0.8, radius: 12, attackRange: 110, hookRange: 170, pullStrength: 0.25 } } },

                    'stonefish': { name: 'Stonefish', cost: 6, emoji: 'ðŸ¡', type: 'Trap', unitClass: Stonefish, placementRadius: 12, isFlying: false, arena: 13, targets: 'Ground',

                                stats: { 1: { health: 400, damage: 1800, radius: 12, lifetime: '20s', activationRadius: 14 } } },

                    'coral': { name: 'Coral', cost: 5, emoji: 'ðŸª¸', type: 'Building', unitClass: Coral, placementRadius: 18, isFlying: false, arena: 13, targets: '-',

                                stats: { 1: { health: 1200, spawn_speed: '3s', lifetime: '35s' } } },

                    'waveSpirit': { name: 'Wave Spirit', cost: 1, emoji: 'ðŸ’§', type: 'Spirit', unitClass: WaveSpirit, placementRadius: 8, isFlying: true, arena: 13, targets: 'Ground', aggroRange: 110,

                                stats: { 1: { health: 120, damage: 45, hitSpeed: 1.2, speed: 1.4, radius: 8, attackRange: 14, pushForce: 40, jumpRadius: 80 } } },

                    'zombies': { name: 'Zombies', cost: 3, emoji: 'ðŸ§Ÿ', type: 'Swarm', unitClass: Zombies, placementRadius: 10, isFlying: false, arena: 14, targets: 'Ground', aggroRange: 110,

                                stats: { 1: { count: 3, health: 28, damage: 11, hitSpeed: 1.0, speed: 1.0, radius: 7, attackRange: 18 } } },

                    'necromancerZombie': { name: 'Necromancer Zombie', cost: 0, hidden: true, emoji: 'ðŸ§Ÿâ€â™‚ï¸', type: 'Troop', unitClass: Zombie, placementRadius: 0, isFlying: false, arena: 14, targets: 'Ground', aggroRange: 90,

                                stats: { 1: { health: 20, damage: 9, hitSpeed: 1.1, speed: 0.9, radius: 6, attackRange: 16 } } },

                    'deathSpiritZombie': { name: 'Death Spirit Zombie', cost: 0, hidden: true, emoji: 'ðŸ§Ÿâ€â™€ï¸', type: 'Troop', unitClass: Zombie, placementRadius: 0, isFlying: false, arena: 14, targets: 'Ground', aggroRange: 100,

                                stats: { 1: { health: 34, damage: 15, hitSpeed: 1.0, speed: 1.1, radius: 7, attackRange: 18 } } },

                    'lab': { name: 'Lab', cost: 6, emoji: 'ðŸ¦ ', type: 'Building', unitClass: Lab, placementRadius: 18, isFlying: false, arena: 14, targets: '-',

                                stats: { 1: { health: 1500, spawn_speed: '5s', lifetime: '36s' } } },

                    'tombstone': { name: 'Tombstone', cost: 4, emoji: 'âš°ï¸', type: 'Building', unitClass: Tombstone, placementRadius: 16, isFlying: false, arena: 14, targets: '-',

                                stats: { 1: { health: 1400, spawn_speed: '3s', lifetime: '40s' } } },

                    'earthSpirit': { name: 'Earth Spirit', cost: 3, emoji: 'ðŸŒ', type: 'Spirit', unitClass: EarthSpirit, placementRadius: 10, isFlying: false, arena: 15, targets: 'Ground', aggroRange: 120,

                                stats: { 1: { health: 220, damage: 20, hitSpeed: 1.0, speed: 0, radius: 10, attackRange: 16, effectRadius: 60, duration: 5, slowPercent: 0.25 } } },

                    'earthDragon': { name: 'Earth Dragon', cost: 4, emoji: 'ðŸ‰ðŸª¨', type: 'Air', unitClass: EarthDragon, placementRadius: 14, isFlying: true, arena: 15, targets: 'Air & Ground', aggroRange: 150,

                                stats: { 1: { health: 800, damage: 100, hitSpeed: 1.0, speed: 0.8, attackRange: 120, slowFactor: 0.6, slowDuration: 0.5 } } },

                    'barricade': { name: 'Barricade', cost: 5, emoji: 'ðŸª¨', type: 'Building', unitClass: Barricade, placementRadius: 12, isFlying: false, arena: 15, targets: '-',

                                stats: { 1: { health: 1, lifetime: '30s' } } },

                    'necromancer': { name: 'Necromancer', cost: 5, emoji: 'ðŸ§™â€â™‚ï¸', type: 'Ranged', unitClass: Necromancer, placementRadius: 12, isFlying: false, arena: 14, targets: 'Air & Ground', aggroRange: 110,

                                stats: { 1: { health: 450, damage: 48, hitSpeed: 1.1, speed: 0.95, attackRange: 110, markDuration: 3 } } },

                    'deathSpirit': { name: 'Death Spirit', cost: 1, emoji: 'ðŸ§›', type: 'Spirit', unitClass: DeathSpirit, placementRadius: 8, isFlying: false, arena: 14, targets: 'Ground', aggroRange: 120,

                                stats: { 1: { health: 130, damage: 42, hitSpeed: 1.0, speed: 1.4, radius: 8, attackRange: 16, jumpRadius: 95 } } },

                    'rotter': { name: 'Rotter', cost: 7, emoji: 'ðŸ¦´', type: 'WinCon', unitClass: Rotter, placementRadius: 12, isFlying: false, arena: 14, targets: 'Buildings', aggroRange: 150,

                                stats: { 1: { health: 520, damage: 82, hitSpeed: 1.3, speed: 0.62, radius: 16, attackRange: 18 } } },

                    'zapDragon': { name: 'Zap Dragon', cost: 5, emoji: 'âš¡ðŸ‰', type: 'Air', unitClass: ZapDragon, placementRadius: 14, isFlying: true, arena: 12, targets: 'Air & Ground', aggroRange: 160,

                                stats: { 1: { health: 900, damage: 35, hitSpeed: 1.5, speed: 0.8, chainRadius: 90, chainLimit: 10 } } },

                    'zapWizard': { name: 'Zap Wizard', cost: 5, emoji: 'ðŸ§™âš¡', type: 'Melee', unitClass: ZapWizard, placementRadius: 14, isFlying: false, arena: 12, targets: 'Ground', aggroRange: 150,

                                stats: { 1: { health: 950, damage: 40, hitSpeed: 1.5, speed: 0.7, chainRadius: 90, chainLimit: 10 } } },

                    'pigJockey': { name: 'Pig Jockey', cost: 4, emoji: 'ðŸ·ðŸ‡', type: 'WinCon', unitClass: PigJockey, placementRadius: 12, isFlying: false, arena: 12, targets: 'Buildings', aggroRange: 150,

                                stats: { 1: { health: 950, damage: 110, hitSpeed: 1.2, speed: 1.2, riverJumpDelay: 0.5, riverJumpDuration: 34, riverJumpHeight: 38 } } },

                    'clone': { name: 'Clone', cost: 5, emoji: 'ðŸª„', type: 'Spell', radius: 85, placementRadius: 90, arena: 16, targets: 'Ground & Air',

                                stats: { 1: { duration: 1, cloneRadius: 85 } } },

                    'mirror': { name: 'Mirror', cost: 1, emoji: 'ðŸªž', type: 'Spell', radius: 0, placementRadius: 0, arena: 16, targets: '-',

                                stats: { 1: {} } },

                    'goblinHex': { name: 'Goblin Hex', cost: 5, emoji: 'ðŸ§¿', type: 'Spell', radius: 90, placementRadius: 90, arena: 16, targets: 'Air & Ground',

                                stats: { 1: { duration: 6, damagePerSecond: 35 } } },

                    'celestialGuardian': { name: 'Celestial Guardian', cost: 6, emoji: 'ðŸ›¡ï¸', type: 'Tank', unitClass: CelestialGuardian, placementRadius: 16, isFlying: false, arena: 17, targets: 'Ground', aggroRange: 140,

                                stats: { 1: { health: 1700, damage: 110, hitSpeed: 1.6, speed: 0.55, attackRange: 35 } } },

                    'planarWisp': { name: 'Planar Wisp', cost: 3, emoji: 'âœ¨', type: 'Spirit', unitClass: PlanarWisp, placementRadius: 10, isFlying: true, arena: 17, targets: 'Air & Ground', aggroRange: 140,

                                stats: { 1: { health: 420, damage: 95, hitSpeed: 1.2, speed: 1.4, attackRange: 90, radius: 10 } } },

                    'bigStick': { name: 'Big Stick', cost: 4, emoji: 'ðŸªµ', type: 'Spell', radius: 22, placementRadius: 22, arena: 17, targets: 'Ground', troopSpellPlacement: true,

                                stats: { 1: { damage: 160, distance: 280, speed: 2.6, pushDistance: 32, hitRadius: 28 } },

                                desc: 'Rolls straight from the bridge along the ground lane, cleaving troops, towers, and buildings while ignoring flying threats until the log splinters mid-path.' },


                    'zapTesla': { name: 'Zap Tesla', cost: 5, emoji: 'âš¡', type: 'Building', unitClass: ZapTesla, placementRadius: 18, isFlying: false, arena: 18, targets: '-',

                                stats: { 1: { health: 1050, lifetime: '30s', spawn_speed: '0s', zapRange: 140, zapInterval: 0.6, zapDamage: 68, pushDistance: 16 } },

                                desc: 'Burrows underground, shows its range circle, and zaps the first ground troop before hiding again.' },


                    'nebulaSentinel': { name: 'Nebula Sentinel', cost: 5, emoji: 'ðŸŒ ', type: 'Ranged', unitClass: NebulaSentinel, placementRadius: 12, isFlying: false, arena: 18, targets: 'Air & Ground', aggroRange: 150,

                                stats: { 1: { health: 850, damage: 95, hitSpeed: 1.2, speed: 0.95, attackRange: 110, shardDamage: 40 } },

                                shardCount: 7, shardSpread: 1.1, shardSpeed: 4.2, shardLifetime: 0.9, shardRadius: 5 },

                    'starlightCascade': { name: 'Starlight Cascade', cost: 6, emoji: 'ðŸŒŒâœ¨', type: 'Spell', radius: 120, placementRadius: 120, arena: 18, targets: 'Air & Ground',

                                stats: { 1: { damage: 200, pulses: 3, pulseDelay: 0.5, radius: 120 } } },

                    'resonantBeacon': { name: 'Resonant Beacon', cost: 5, emoji: 'ðŸ›°ï¸', type: 'Building', unitClass: ResonantBeacon, placementRadius: 20, isFlying: false, arena: 19, targets: '-',

                                stats: { 1: { health: 1300, spawn_speed: '0s', lifetime: '38s', damage: 95, pulse_interval: 1.6, range: 150, beam_speed: 7, push_distance: 18 } },

                                desc: 'Sends pulsed beams into the lane, knocking aside ground troops.' },


                    'prismLattice': { name: 'Prism Lattice', cost: 4, emoji: 'ðŸ’ ', type: 'Building', unitClass: PrismLattice, placementRadius: 20, isFlying: false, arena: 19, targets: '-',

                                stats: { 1: { health: 1100, lifetime: '32s', spawn_speed: '0s', pulseRadius: 92, pulseInterval: 0.7, pulseDamage: 42, pushDistance: 14 } },

                                desc: 'Anchors a radiant lattice that pulses and nudges ground troops back as it decays.' },


'bulletGoblin': { name: 'Bullet Goblin', cost: 3, emoji: 'ðŸ”«ðŸ‘º', type: 'Ranged', unitClass: BulletGoblin, placementRadius: 10, isFlying: false, arena: 19, targets: 'Air & Ground', aggroRange: 160,

                                stats: { 1: { health: 260, damage: 28, hitSpeed: 0.4, speed: 1.2, attackRange: 110, projectileSpeed: 8 } },

                                desc: 'Sprays low-damage projectiles faster than most goblins, chipping ground mobs before they can close.' },


                    
                    'starSwarm': { name: 'Star Swarm', cost: 3, emoji: 'âœ¨', type: 'Swarm', unitClass: StarSwarm, placementRadius: 14, isFlying: false, arena: 19, targets: 'Ground', aggroRange: 120,

                                stats: { 1: { count: 3, health: 120, damage: 16, hitSpeed: 1.2, speed: 1.05, attackRange: 26 } },

                                desc: 'A hesitant pack of spark sprites that chip at nearby ground units.' },


                    'novaPulse': { name: 'Nova Pulse', cost: 4, emoji: 'ðŸŒŒ', type: 'Spell', radius: 90, placementRadius: 90, arena: 19, targets: 'Ground',

                                stats: { 1: { damage: 130, pulses: 3, pulseInterval: 0.55, radius: 90 } },

                                desc: 'Unleashes radiating pulses that damage and stagger every ground troop caught inside.' },


                    'echoRift': { name: 'Echo Rift', cost: 5, emoji: 'ðŸŒ€', type: 'Building', unitClass: EchoRift, placementRadius: 18, isFlying: false, arena: 19, targets: '-',

                                stats: { 1: { health: 1200, lifetime: '28s', spawn_speed: '0s', pulseDamage: 24, pulseRadius: 92, pulseInterval: 1.4, slowPercent: 0.35, slowDuration: 1.2 } },

                                desc: 'Anchors a shimmering rift that pulses damage and slows ground troops in sync with the lane.' },


                    'prismVanguard': { name: 'Prism Vanguard', cost: 5, emoji: 'ðŸ—¡ï¸âœ¨', type: 'WinCon', unitClass: PrismVanguard, placementRadius: 12, isFlying: false, arena: 20, targets: 'Buildings', aggroRange: 120,

                                stats: { 1: { health: 820, damage: 104, hitSpeed: 1.45, speed: 0.92, attackRange: 18, splitCount: 3, splitDamage: 38, splitRange: 34 } },

                                splitCooldown: 150,

                                desc: 'A calibrated breach runner that charges towers, letting off modest ground shards as it hits while ignoring everything else.' },


                    'nebulaDrift': { name: 'Nebula Drift', cost: 5, emoji: 'ðŸŒŠðŸš€', type: 'WinCon', unitClass: NebulaDrift, placementRadius: 12, isFlying: false, arena: 20, targets: 'Buildings', aggroRange: 120,

                                stats: { 1: { health: 820, damage: 118, hitSpeed: 1.6, speed: 0.98, attackRange: 22, splitCount: 3, splitDamage: 84, splitSpeed: 1.6, splitRange: 52, splitThreshold: 0.75, splitSplashRange: 54, splitSplashDamage: 44 } },

                                desc: 'The hull fierces toward towers, then ruptures near buildings and fires nebula darts that slam the primary structure while splashing distant towers.' },


                    'starlineCorsair': { name: 'Starline Corsair', cost: 4, emoji: 'ðŸŒŸâš¡', type: 'WinCon', unitClass: StarlineCorsair, placementRadius: 12, isFlying: false, arena: 20, targets: 'Buildings', aggroRange: 140,

                                stats: { 1: { health: 640, damage: 95, hitSpeed: 1.35, speed: 0.98, attackRange: 108, bonusSpeed: 1.4 } },

                                chainCooldown: 140,

                                laneSwitchThreshold: 2,

                                laneSwitchRange: 70,

                                desc: 'A twin-sailed prow that only fires at towers, rerouting once to the quieter lane when enemy troops pile up and firing focused chains toward the new structure.' },


                    'astralBastion': { name: 'Astral Bastion', cost: 6, emoji: 'ðŸŒŒðŸ§­', type: 'WinCon', unitClass: AstralBastion, placementRadius: 14, isFlying: false, arena: 20, targets: 'Buildings', aggroRange: 160,

                                stats: { 1: { health: 700, damage: 90, hitSpeed: 1.5, speed: 0.82, attackRange: 96, pulseDamage: 42, pulseInterval: 3.0, buffRadius: 70 } },

                                desc: 'A cascading prow that pulses burning light while trudging toward towers and buffs nearby ground allies.' },


                    'superSkeleton': { name: 'Super Skeleton', cost: 6, emoji: 'ðŸ’€ðŸ¦´', type: 'Hero', unitClass: SuperSkeleton, placementRadius: 16, isFlying: false, arena: 21, targets: 'Ground', aggroRange: 150,

                                stats: { 1: { health: 1500, damage: 150, hitSpeed: 1.25, speed: 0.85, attackRange: 18 } },

                                isSuperhero: true,

                                ability: { name: 'Bone Toss', emoji: 'ðŸ¦´', cost: 3, uses: null, range: 160, description: 'Grab the closest troop and fling it into the enemy lane, damaging anything it collides with along the path.' },

                                desc: 'A grizzled hero who hurls skeletons as wrecking balls.' },


                    'superGoblin': { name: 'Super Goblin', cost: 4, emoji: 'ðŸ‘ŠðŸ”¥', type: 'Hero', unitClass: SuperGoblin, placementRadius: 14, isFlying: false, arena: 21, targets: 'Ground', aggroRange: 140,

                                stats: { 1: { health: 780, damage: 110, hitSpeed: 1.0, speed: 1.5, attackRange: 15 } },

                                isSuperhero: true,

                                ability: { name: 'Teleport Bomb', emoji: 'ðŸŽ¯', cost: 3, uses: 1, range: 240, description: 'Launch a teleport bomb toward the nearest tower, then blink there and slam it.' },

                                desc: 'Zip, toss, and vanish â€“ this goblin hits towers before the opponent can blink.' },


                    'superMagician': { name: 'Super Magician', cost: 5, emoji: 'ðŸ§™âœ¨', type: 'Hero', unitClass: SuperMagician, placementRadius: 14, isFlying: false, arena: 21, targets: 'Air & Ground', aggroRange: 140,

                                stats: { 1: { health: 920, damage: 95, hitSpeed: 1.3, speed: 0.9, attackRange: 14 } },

                                isSuperhero: true,

                                ability: { name: 'Magnetic Rift', emoji: 'âœ¨', cost: 3, uses: 3, range: 130, description: 'Pull troops into a stunned ring and release them outward after 3 seconds.' },

                                desc: 'Orbiting orbs stun enemies before blasting them away.' },


'tower': { name: 'Tower Upgrade', emoji: 'ðŸ‘‘' }

                };

                

                // --- NEW: Auto-calculate stats for levels 2-15 ---

                for (const cardId in allCards) {

                    if (cardId === 'tower') continue; // Allow miniStoneGiant to auto-scale like other cards

                    const card = allCards[cardId];

                    if (card && card.hidden) continue;

                    for (let level = 2; level <= 15; level++) { // Cap at 15

                        if (!card.stats[level]) {

                            const prevStats = card.stats[level - 1];

                            const newStats = { ...prevStats };

                            // Increase health and damage by ~10% per level

                            if (newStats.health) newStats.health = Math.round(newStats.health * 1.1);

                            if (newStats.damage) newStats.damage = Math.round(newStats.damage * 1.1);

                            if (newStats.chargeDamage) newStats.chargeDamage = Math.round(newStats.chargeDamage * 1.1);

                            if (newStats.damagePerSecond) newStats.damagePerSecond = Math.round(newStats.damagePerSecond * 1.1); // For Poison

                            if (newStats.shardDamage) newStats.shardDamage = Math.round(newStats.shardDamage * 1.1);

                            // Handle sub-unit stats

                            if (newStats.spear_health) newStats.spear_health = Math.round(newStats.spear_health * 1.1);

                            if (newStats.spear_damage) newStats.spear_damage = Math.round(newStats.spear_damage * 1.1);

                            // Handle spirit stats

                            if (newStats.jumpRadius) newStats.jumpRadius = Math.round(newStats.jumpRadius * 1.05);

                            if (newStats.effectRadius) newStats.effectRadius = Math.round(newStats.effectRadius * 1.05);

                            // Prevent splashRadius upgrade for AxeSwinger

            // Removed the line that upgrades splashRadius for all cards.

            // Update levels for spawner cards

            if (cardId === 'battleRam' || cardId === 'barbarianHut') newStats.barbLevel = level;

            

            // --- ADDED: Max Damage Scaling --- 

            if (newStats.maxDamage) newStats.maxDamage = Math.round(newStats.maxDamage * 1.1);

                            card.stats[level] = newStats;

                        }

                    }

                }

            }

            /*

             * --- Diddyâ€™s Brigade ---

             *

             * These classes implement the new Diddy cards and units introduced for

             * Arena 11. DiddyGoblin is a fast melee unit spawned by the Diddy Cage

             * building. The Diddy Cage is a simple building that decays over time

             * like other huts but, upon destruction or expiry, releases a single

             * DiddyGoblin. The Diddy Miner behaves like a spell card: it can be

             * deployed anywhere on the battlefield and surfaces at the target

             * position. Finally, the Diddy Giant is a tank similar to the Giant

             * but projects an aura that enrages friendly troops within its radius.

             */

            // A nimble monkey warrior spawned from the Diddy Cage. Not a card itself.

            class DiddyGoblin extends Unit {

                constructor(x, y, team, level = 1) {

                    // Base stats for level 1; higher levels will be auto-calculated

                    const baseHealth = 250;

                    const baseDamage = 45;

                    const baseHitSpeed = 1.1;

                    const baseSpeed = 1.0;

                    super(x, y, 12, team, baseHealth, baseSpeed, 25, baseDamage, baseHitSpeed, 'ðŸµ', false, false, level, 100);

                }

            }

            // A cage that spawns a Diddy Goblin when it expires or is destroyed.

            class DiddyCage extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'diddyCage');

                    this.hasSpawned = false;

                }

                update() {

                    // Apply decay and lifetime as usual

                    if (this.health <= 0 || this.lifetime <= 0) {

                        // Only spawn once

                        if (!this.hasSpawned) {

                            this.hasSpawned = true;

                            // Spawn a DiddyGoblin at the cageâ€™s location

                            gameObjects.push(new DiddyGoblin(this.x, this.y, this.team, this.level));

                        }

                        this.health = 0;

                        return;

                    }

                    this.lifetime -= deltaTime * 60;

                    const decayPerFrame = this.maxHealth / this.maxLifetime;

                    this.health -= decayPerFrame * (deltaTime * 60);

                }

                draw() {

                    // Reuse the Building draw method for visuals

                    super.draw();

                }

            }

            // A burrowing miner that travels from the king tower to a target point over a few seconds

            class DiddyMiner extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['diddyMiner'].stats[level];

                    const spawnX = WIDTH / 2;

                    const spawnY = team === 'player' ? HEIGHT - 50 : 50;

                    super(x, y, 12, team, s.health, s.speed, 20, s.damage, s.hitSpeed, 'â›ï¸', false, false, level, allCards['diddyMiner'].aggroRange || 100);

                    this.destX = x;

                    this.destY = y;

                    this.spawnX = spawnX;

                    this.spawnY = spawnY;

                    this.x = spawnX;

                    this.y = spawnY;

                    this.hasSurfaced = false;

                    this.emergeDelay = 60;

                    const distance = getDistance({ x: spawnX, y: spawnY }, { x: x, y: y });

                    const normalized = Math.min(1, distance / (WIDTH * 0.75));

                    const baseTravel = 180;

                    const extraTravel = 140;

                    this.travelDuration = Math.round(Math.max(120, Math.min(340, baseTravel + normalized * extraTravel)));

                    this.emergeTimer = 0;

                    this.particleInterval = Math.max(3, Math.round(10 - normalized * 5));

                    this.particleTimer = this.particleInterval;

                    this.isTargetable = false;

                }

                update() {

                    if (!this.hasSurfaced) {

                        this.emergeTimer++;

                        if (this.emergeTimer >= this.emergeDelay) {

                            const travelProgress = Math.min(1, (this.emergeTimer - this.emergeDelay) / this.travelDuration);

                            this.x = this.spawnX + (this.destX - this.spawnX) * travelProgress;

                            this.y = this.spawnY + (this.destY - this.spawnY) * travelProgress;

                            this.particleTimer--;

                            if (this.particleTimer <= 0) {

                                this.particleTimer = this.particleInterval;

                                const angle = Math.atan2(this.destY - this.spawnY, this.destX - this.spawnX);

                                const jitter = (Math.random() - 0.5) * 0.4;

                                const particle = new DiddyDirtParticle(this.x, this.y, angle + jitter);

                                gameObjects.push(particle);

                            }

                            if (travelProgress >= 1) {

                                this.hasSurfaced = true;

                                this.isTargetable = true;

                                this.x = this.destX;

                                this.y = this.destY;

                            }

                        }

                        return;

                    }

                    super.update();

                }

                draw() {

                    if (!this.hasSurfaced) return;

                    super.draw();

                }

            }

            class DiddyDirtParticle extends GameObject {

                constructor(x, y, angle, speed = 3, life = 60) {

                    super(x, y, 2, 'neutral', 1);

                    this.vx = Math.cos(angle) * speed;

                    this.vy = Math.sin(angle) * speed;

                    this.life = life;

                    this.maxLife = life;

                }

                update() {

                    this.x += this.vx;

                    this.y += this.vy;

                    this.life--;

                    if (this.life <= 0) this.health = 0;

                }

                draw() {

                    ctx.save();

                    const alpha = Math.max(0, this.life / this.maxLife);

                    ctx.globalAlpha = alpha;

                    ctx.fillStyle = '#a16207';

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, 3 + (1 - alpha) * 2, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.restore();

                }

            }

            class Stonefish extends GameObject {

                constructor(x, y, team, level = 1) {

                    const s = allCards['stonefish'].stats[level];

                    super(x, y, s.radius, team, s.health);

                    this.damage = s.damage;

                    this.maxLifetime = Math.max(1, parseFloat(s.lifetime) || 20) * 60;

                    this.lifetime = this.maxLifetime;

                    this.activationRadius = s.activationRadius || s.radius || 18;

                    this.isTargetable = false;

                }

                update() {

                    if (this.health <= 0) return;

                    this.lifetime -= deltaTime * 60;

                    const decayPerFrame = this.maxHealth / this.maxLifetime;

                    this.health -= decayPerFrame * (deltaTime * 60);

                    if (this.lifetime <= 0 || this.health <= 0) {

                        this.health = 0;

                        return;

                    }

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && obj instanceof Unit && obj.health > 0) {

                            if (getDistance(this, obj) <= this.activationRadius + obj.radius) {

                                applyDamage(obj, this.damage);

                                this.health = 0;

                                break;

                            }

                        }

                    }

                }

                draw() {

                    if (this.team !== 'player' || this.health <= 0) return;

                    ctx.save();

                    ctx.fillStyle = 'rgba(56, 189, 248, 0.55)';

                    ctx.strokeStyle = 'rgba(2, 132, 199, 0.8)';

                    ctx.lineWidth = 2;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.stroke();

                    ctx.font = 'bold 11px Inter';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'bottom';

                    ctx.fillStyle = '#fcd34d';

                    ctx.fillText('Stonefish', this.x, this.y - this.radius - 4);

                    ctx.restore();

                    ctx.font = 'bold 12px Inter';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'top';

                    ctx.fillStyle = '#fde68a';

                    ctx.strokeStyle = 'black';

                    ctx.lineWidth = 2;

                    const healthText = Math.max(0, Math.round(this.health));

                    ctx.strokeText(healthText, this.x, this.y + this.radius + 4);

                    ctx.fillText(healthText, this.x, this.y + this.radius + 4);

                    this.drawHealthBar();

                }

            }

            class Zombie extends Unit {

                constructor(x, y, team, level = 1, options = {}) {

                    const cardKey = options.templateCard || 'zombies';

                    const card = allCards[cardKey] || allCards['zombies'];

                    const stats = card.stats[level] || card.stats[1];

                    const s = stats || {};

                    const healthMultiplier = options.nerf ? 0.65 : 1;

                    const damageMultiplier = options.nerf ? 0.75 : 1;

                    const speedMultiplier = options.nerf ? 0.85 : 1;

                    const health = Math.max(1, Math.round((s.health || 1) * healthMultiplier));

                    const damage = Math.max(1, Math.round((s.damage || 1) * damageMultiplier));

                    const speed = Math.max(0.5, (s.speed || 1) * speedMultiplier);

                    const radius = s.radius || 6;

                    const attackRange = s.attackRange || 20;

                    const aggroRange = card.aggroRange || 110;

                    const emoji = card.emoji || 'ðŸ§Ÿ';

                    super(x, y, radius, team, health, speed, attackRange, damage, s.hitSpeed || 1.1, emoji, false, false, level, aggroRange);

                    this._poisonSpawned = false;

                    this.variant = options.variant || cardKey;

                    const requiresTwoTowerHits = options.requiresTwoTowerHits !== undefined ? options.requiresTwoTowerHits : !options.nerf;

                    this.requiresTwoTowerHits = requiresTwoTowerHits;

                    this._towerHitsTaken = 0;

                }

            }

            class Zombies {

                constructor(x, y, team, level = 1) {

                    const s = allCards['zombies'].stats[level];

                    const count = s.count || 3;

                    for (let i = 0; i < count; i++) {

                        const zx = x + (Math.random() * 16 - 8);

                        const zy = y + (Math.random() * 16 - 8);

                        const spawned = new Zombie(zx, zy, team, level);

                        try {

                            if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                                spawned.isEvolved = true;

                                spawned.shieldTimer = 0;

                            }

                        } catch (e) {}

                        gameObjects.push(spawned);

                    }

                }

            }

            class Lab extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'lab');

                    const baseStats = allCards['lab'].stats[level];

                    const rate = baseStats ? parseFloat(baseStats.spawn_speed) || 10 : 10;

                    this.zombieSpawnRate = Math.max(1, rate) * 60;

                    this.zombieSpawnTimer = this.zombieSpawnRate;

                    this.spawnZombie();

                }

                update() {

                    if (this.health <= 0) return;

                    super.update();

                    this.zombieSpawnTimer -= deltaTime * 60;

                    if (this.zombieSpawnTimer <= 0 && this.health > 0) {

                        this.zombieSpawnTimer += this.zombieSpawnRate;

                        this.spawnZombie();

                    }

                }

                spawnZombie() {

                    const spawnLevel = this.spawnLevel || this.level;

                    const spawnX = this.x + (Math.random() * 20 - 10);

                    const spawnY = this.y + (Math.random() * 20 - 10);

                    gameObjects.push(new Zombie(spawnX, spawnY, this.team, spawnLevel));

                }

            }

            class Necromancer extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['necromancer'].stats[level];

                    super(x, y, s.radius || 12, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'ðŸ§™â€â™‚ï¸', false, true, level, allCards['necromancer'].aggroRange || 150);

                    this.markDuration = s.markDuration || 3;

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    const dist = getDistance(this, this.target);

                    if (dist > this.attackRange) return;

                    const markInfo = {

                        level: this.level,

                        nerf: true,

                        templateCard: 'necromancerZombie',

                        variant: 'necromancer'

                    };

                    gameObjects.push(new NecromancerOrbProjectile(this.x, this.y, this.target, this.team, this.attackDamage, markInfo));

                    this.cooldownTimer = this.attackCooldown;

                }

                findClosestBuilding(range = this.aggroRange) {

                    let closest = null;

                    let closestDist = range;

                    for (const obj of gameObjects) {

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Building) && !(obj instanceof Tower)) continue;

                        const dist = getDistance(this, obj);

                        if (dist < closestDist) {

                            closestDist = dist;

                            closest = obj;

                        }

                    }

                    return closest;

                }

                findTarget(forceFindTower = false) {

                    const building = this.findClosestBuilding();

                    if (building) return building;

                    return super.findTarget(forceFindTower);

                }

            }

            class DeathSpirit extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['deathSpirit'].stats[level];

                    super(x, y, s.radius || 8, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'ðŸ§›', false, false, level, allCards['deathSpirit'].aggroRange || 120);

                    this.jumpRadius = s.jumpRadius || 90;

                    this.hasJumped = false;

                }

                update() {

                    if (this.health <= 0 || this.hasJumped) return;

                    if (this.handleZapFreeze()) return;

                    const target = this.findJumpTarget();

                    if (target) {

                        this.performJump(target);

                        return;

                    }

                    if (!this.target || this.target.health <= 0) {

                        this.target = this.findTarget(true);

                    }

                    if (this.target && this.target.health > 0) {

                        this.move();

                    }

                }

                findJumpTarget() {

                    let closestUnitDist = this.jumpRadius;

                    let closestUnit = null;

                    let closestTowerDist = this.jumpRadius;

                    let closestTower = null;

                    for (const obj of gameObjects) {

                        if (obj.team === this.team || obj.health <= 0) continue;

                        const isUnit = obj instanceof Unit;

                        const isTower = obj instanceof Tower;

                        if (!isUnit && !isTower) continue;

                        if (isUnit) {

                            if (obj.isFlying) continue;

                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;

                        }

                        const dist = getDistance(this, obj);

                        const contactDist = this.radius + (obj.radius || 0);

                        if (dist <= contactDist + 1) return obj;

                        if (isUnit && dist < closestUnitDist) {

                            closestUnitDist = dist;

                            closestUnit = obj;

                        } else if (isTower && dist < closestTowerDist) {

                            closestTowerDist = dist;

                            closestTower = obj;

                        }

                    }

                    return closestUnit || closestTower;

                }

                performJump(target) {

                    if (!target || target.health <= 0) return;

                    this.x = target.x;

                    this.y = target.y;

                    applyDamage(target, this.attackDamage);

                    markUnitAsZombie(target, this.team, 'deathSpirit', {

                        level: this.level,

                        nerf: false,

                        templateCard: 'deathSpiritZombie',

                        variant: 'deathSpirit'

                    });

                    this.hasJumped = true;

                    this.health = 0;

                }

            }

            class Worm extends Unit {

                constructor(x, y, team, level = 1) {

                    const baseHealth = 90;

                    const baseDamage = 40;

                    const baseSpeed = 1.25;

                    super(x, y, 6, team, baseHealth, baseSpeed, 18, baseDamage, 1.1, 'ðŸª±', false, false, level, 110);

                }

            }

            class Rotter extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['rotter'].stats[level];

                    super(x, y, s.radius || 16, team, s.health, s.speed, s.attackRange, s.damage, s.hitSpeed, 'ðŸ¦´', false, false, level, allCards['rotter'].aggroRange || 140);

                    this.isWinCondition = true;

                    this.didSpawnWorms = false;

                    this.ignoresTroops = true;

                }

                findTarget(forceFindTower = true) {

                    const structure = findClosestEnemyStructure(this);

                    if (structure) return structure;

                    return super.findTarget(forceFindTower);

                }

            }

            // A giant with an anger aura. Buffs allied troops within its radius.

            class DiddyGiant extends Unit {

                constructor(x, y, team, level = 1) {

                    const s = allCards['diddyGiant'].stats[level];

                    super(x, y, 18, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'ðŸµðŸ’ª', false, false, level, allCards['diddyGiant'].aggroRange || 100);

                    this.isWinCondition = true;

                    this.ignoresTroops = true;

                    // Radius of the anger aura

                    this.auraRadius = 80;

                    // Track units buffed by this giant to revert them when necessary

                    this.angeredUnits = new Set();

                }

                findTarget(forceFindTower = false) {

                    let closestDist = Infinity;

                    let buildingTarget = null;

                    for (const obj of gameObjects) {

                        if (obj.team !== this.team && (obj instanceof Building || obj instanceof Tower)) {

                            const dist = getDistance(this, obj);

                            if (dist < closestDist) {

                                closestDist = dist;

                                buildingTarget = obj;

                            }

                        }

                    }

                    this.target = buildingTarget;

                    return buildingTarget;

                }

                update() {

                    // Call base update for movement/attacks

                    super.update();

                    // If the giant has died, remove its buffs

                    if (this.health <= 0) {

                        for (const obj of this.angeredUnits) {

                            if (obj.angeredBy === this) {

                                // Restore original stats

                                if (obj.originalDamage !== undefined) obj.attackDamage = obj.originalDamage;

                                if (obj.originalCooldown !== undefined) obj.attackCooldown = obj.originalCooldown;

                                obj.isAngered = false;

                                obj.angeredBy = null;

                            }

                        }

                        this.angeredUnits.clear();

                        return;

                    }

                    // Apply the aura to nearby friendly units/buildings/towers

                    for (const obj of gameObjects) {

                        if (obj === this) continue;

                        if (obj.team === this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {

                            const dist = getDistance(this, obj);

                            if (dist < this.auraRadius) {

                                // Grant anger buff if not already angered by this giant

                                if (obj.angeredBy !== this) {

                                    obj.angeredBy = this;

                                    obj.isAngered = true;

                                    // Store original stats if not already stored

                                    if (obj.originalDamage === undefined && obj.attackDamage !== undefined) {

                                        obj.originalDamage = obj.attackDamage;

                                    }

                                    if (obj.originalCooldown === undefined && obj.attackCooldown !== undefined) {

                                        obj.originalCooldown = obj.attackCooldown;

                                    }

                                    // Apply buff

                                    if (obj.attackDamage !== undefined) obj.attackDamage = Math.floor(obj.attackDamage * 1.25);

                                    if (obj.attackCooldown !== undefined) obj.attackCooldown = Math.floor(obj.attackCooldown / 1.5);

                                    this.angeredUnits.add(obj);

                                }

                            } else {

                                // Unit has left the aura; revert if it was buffed by this giant

                                if (obj.angeredBy === this) {

                                    if (obj.originalDamage !== undefined) obj.attackDamage = obj.originalDamage;

                                    if (obj.originalCooldown !== undefined) obj.attackCooldown = obj.originalCooldown;

                                    obj.isAngered = false;

                                    obj.angeredBy = null;

                                    this.angeredUnits.delete(obj);

                                }

                            }

                        }

                    }

                }

                draw() {

                    // Draw the aura circle as a faint white ring

                    ctx.save();

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';

                    ctx.lineWidth = 2;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.auraRadius, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                    super.draw();

                }

            }

            

            function getDistance(obj1, obj2) {

                const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return Math.sqrt(dx * dx + dy * dy);

            }

            // Helper for Farmer attack

            function isInside(point, cx, cy, width, height, angle) {

                const dx = point.x - cx;

                const dy = point.y - cy;

                const rotatedX = dx * Math.cos(-angle) - dy * Math.sin(-angle);

                const rotatedY = dx * Math.sin(-angle) + dy * Math.cos(-angle);

                // Check if point is inside the rectangle defined in front of the farmer

                return rotatedX > 0 && rotatedX < height && Math.abs(rotatedY) < width / 2;

            }

            function drawArena() {

                // River

                if (gameMode === 'snowman_challenge') {

                     ctx.fillStyle = '#bfdbfe'; // Icy River

                } else if (currentArenaTheme === 'arena-3') {

                    ctx.fillStyle = '#f45d22'; // Lava

                } else if (currentArenaTheme === 'arena-2') {

                    ctx.fillStyle = '#4a90e2'; // Lighter blue

                } else if (currentArenaTheme === 'arena-4') {

                    ctx.fillStyle = '#65a30d'; // Farm river

                } else if (currentArenaTheme === 'arena-5') {

                    ctx.fillStyle = '#4338ca'; // Indigo-700

                } else if (currentArenaTheme === 'arena-6') {

                    ctx.fillStyle = '#92400e'; // Brown-700

                } else if (currentArenaTheme === 'arena-8') {

                    ctx.fillStyle = '#9333ea'; // Purple-600 for chaos

                } else if (currentArenaTheme === 'arena-9') {

                    ctx.fillStyle = '#1e293b'; // Slate-800 for void

                } else if (currentArenaTheme === 'arena-13') {

                    ctx.fillStyle = '#0ea5e9'; // Aqua river

                } else if (currentArenaTheme === 'arena-14') {

                    ctx.fillStyle = '#6d28d9'; // Forsaken purple glow

                } else if (currentArenaTheme === 'arena-15') {

                    ctx.fillStyle = '#111827'; // Buried kingdom stone

                } else if (currentArenaTheme === 'arena-16') {

                    ctx.fillStyle = '#0f172a'; // Mirror Plateau river

                } else if (currentArenaTheme === 'arena-17') {

                    ctx.fillStyle = '#a5b4fc'; // Celestial glow

                } else if (currentArenaTheme === 'arena-18') {

                    ctx.fillStyle = '#0a0b1a'; // Nebula night

                } else if (currentArenaTheme === 'arena-19') {

                    ctx.fillStyle = '#020616'; // Observatory dusk

                } else if (currentArenaTheme === 'arena-20') {

                    ctx.fillStyle = '#050513'; // Celestial Cascade mist

                } else if (currentArenaTheme === 'arena-21') {

                    ctx.fillStyle = '#fbbf24'; // Snack Pit glow

                } else if (currentArenaTheme === 'arena-12') {

                    ctx.fillStyle = '#0b1220'; // Mythic river

                } else {

                    ctx.fillStyle = '#3b82f6'; // Default blue

                }

                ctx.fillRect(0, RIVER_Y - 10, WIDTH, 20);

                

                // Bridges

                ctx.fillStyle = '#a16207'; // Brown

                ctx.fillRect(LANE_LEFT_X - 25, RIVER_Y - 15, 50, 30);

                ctx.fillRect(LANE_RIGHT_X - 25, RIVER_Y - 15, 50, 30);

            }

function getHighestDeckCardLevel(mode = gameMode) {

    if (isMaxLevelMatch(mode)) return 15;

    const deck = getDeckForMode(mode) || [];

    let maxLevel = 1;

                deck.forEach(cardId => {

                    const cardData = cardCollection[cardId];

                    const level = (cardData && cardData.level) ? cardData.level : 1;

                    if (level > maxLevel) maxLevel = level;

                });

                return Math.max(1, Math.min(15, maxLevel));

            }

            function getAILevel() {

                const baseLevel = getHighestDeckCardLevel(gameMode);

                if (baseLevel >= 15) return 15;

                const boost = Math.random() < 0.5 ? 1 : 0;

                return Math.min(15, baseLevel + boost);

            }

            function ignoreDuplicates() {

            // REMOVED DUPLICATE BLOCK

            // (Duplicate functions removed to fix SyntaxError)

                let arenaNum = 1;

                if (aiLevel > 0) {

                    arenaNum = aiLevel;

                } else {

                    if (currentArenaFloor >= 3000) arenaNum = 13;

                    else if (currentArenaFloor >= 2750) arenaNum = 12;

                    else if (currentArenaFloor >= 2500) arenaNum = 11;

                    else if (currentArenaFloor >= 2250) arenaNum = 10;

                    else if (currentArenaFloor >= 2000) arenaNum = 9;

                    else if (currentArenaFloor >= 1750) arenaNum = 8;

                    else if (currentArenaFloor >= 1500) arenaNum = 7;

                    else if (currentArenaFloor >= 1250) arenaNum = 6;

                    else if (currentArenaFloor >= 1000) arenaNum = 5;

                    else if (currentArenaFloor >= 750) arenaNum = 4;

                    else if (currentArenaFloor >= 500) arenaNum = 3;

                    else if (currentArenaFloor >= 250) arenaNum = 2;

                    else arenaNum = 1;

                }

                for (const cardId in allCards) {

                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Never include tower or internal mini in this list

                    if (allCards[cardId] && allCards[cardId].hidden) continue;

                    if (allCards[cardId].arena <= arenaNum) {

                        unlocked.push(cardId);

                    }

                }

                if (includeTower) {

                    unlocked.push('tower');

                }

                return unlocked;

            }

            function createCardDOM(cardId, isSmall = false, inHand = false) {

                const card = allCards[cardId];

                if (!card || card.hidden) return null;

                

                const cardData = cardCollection[cardId];

                const isParty = (gameMode === '2v2' || gameMode === 'party1v1' || gameMode === 'chaos');

                const isEmojiDashMode = (gameMode === 'emojiDash');

                const emojiDashRestricted = isEmojiDashMode && isEmojiDashRestrictedCard(card);

                const generalLocked = !inHand && (!cardData || !cardData.unlocked);

                const isLocked = emojiDashRestricted || (!isEmojiDashMode && !isParty && generalLocked);

                

                const cardEl = document.createElement('div');

                cardEl.className = `card-ui btn-shine ${isSmall ? 'card-ui-small' : ''}`;

                cardEl.dataset.unit = cardId;

                

                if (isLocked) { // Removed !inHand check, it's now at the top

                    cardEl.classList.add('card-ui-locked');

                    let lockedText = ``;

                    if (emojiDashRestricted) {

                        lockedText = `<div class="card-ui-locked-arena">Not available in Emoji Dash</div>`;

                    } else if (!inHand && card.arena !== 1) {

                        lockedText = `<div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>`;

                    }

                    cardEl.innerHTML = `

                        <div class="card-ui-cost">${card.cost}</div>

                        <span class="card-ui-name">${card.name}</span>

                        <span class="card-ui-emoji">${card.emoji}</span>

                        <span class="card-ui-type">${card.type}</span>

                        ${lockedText}

                    `;

                    return cardEl;

                }

                const useMaxLevel = isMaxLevelMatch();

                const displayLevel = useMaxLevel ? 15 : ((cardData && cardData.level) ? cardData.level : 1);

                const displayCount = (cardData && cardData.count) ? cardData.count : 0;

                

                cardEl.dataset.cost = card.cost;

                cardEl.dataset.type = card.type;

                cardEl.dataset.emoji = card.emoji;

                cardEl.dataset.radius = card.placementRadius;

                if (card.radius) cardEl.dataset.spellRadius = card.radius;

                let progressBarHTML = '';

                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;

                if (!inHand) {

                    const costs = upgradeCosts[displayLevel];

                    let progress = 0;

                    let canUpgrade = false;

                    if (costs) {

                        progress = (displayCount / costs.cards) * 100;

                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }

                    } else { progress = 100; } // Max level

                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;

                } else { levelTextHTML = ''; }

                const mirrorPreviewHTML = (cardId === 'mirror') ? '<span class="card-ui-mirror-preview"></span>' : '';

                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}${mirrorPreviewHTML}`;

                return cardEl;

            }

            function updateCardUI() {

                const elixirInt = Math.floor(playerElixir);

                const mirrorRequirement = getMirrorRequiredCost();

                const mirrorCardDef = allCards['mirror'];

                const mirrorBaseCost = (mirrorCardDef && typeof mirrorCardDef.cost === 'number') ? mirrorCardDef.cost : 1;

                const lastPlayerCard = lastPlayedCardByTeam.player ? allCards[lastPlayedCardByTeam.player.cardId] : null;

                elixirBar.style.width = `${(playerElixir / MAX_ELIXIR) * 100}%`;

                elixirText.textContent = elixirInt;

                document.querySelectorAll('#cardHand .card-ui').forEach(cardEl => {

                    const costEl = cardEl.querySelector('.card-ui-cost');

                    if (!costEl) return;

                    let costValue = parseInt(cardEl.dataset.cost, 10) || 0;

                    if (cardEl.dataset.unit === 'mirror') {

                        const dynamicCost = mirrorRequirement || mirrorBaseCost;

                        costValue = dynamicCost;

                        costEl.textContent = dynamicCost;

                        cardEl.dataset.cost = dynamicCost;

                        const previewEl = cardEl.querySelector('.card-ui-mirror-preview');

                        if (previewEl) {

                            const shouldShowPreview = mirrorRequirement && lastPlayerCard;

                            const mirrorEmoji = shouldShowPreview ? (lastPlayerCard.emoji || '') : '';

                            previewEl.textContent = mirrorEmoji;

                            previewEl.style.opacity = mirrorEmoji ? '1' : '0';

                        }

                    }

                    let disabled = costValue > elixirInt;

                    if (cardEl.dataset.unit === 'mirror') {

                        if (!mirrorRequirement || mirrorRequirement > elixirInt) {

                            disabled = true;

                        }

                    }

                    cardEl.classList.toggle('disabled', disabled);

                });

            }

            function shuffleDeck(deck) {

                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;

            }

            function renderHand() {

                cardHandEl.innerHTML = '';

                hand.forEach((cardId, index) => {

                    const cardEl = createCardDOM(cardId, false, true);

                    cardEl.dataset.handIndex = index;

                    applyCardEvoDots(cardEl, cardId);

                    // Handle touch/mouse down for card selection

                    cardEl.addEventListener('mousedown', (e) => selectCard(e, cardEl, cardId));

                    cardEl.addEventListener('touchstart', (e) => selectCard(e, cardEl, cardId), { passive: false });

                    cardHandEl.appendChild(cardEl);

                });

                nextCardSlotEl.innerHTML = '';

                if (nextCard) {

                    const nextCardEl = createCardDOM(nextCard, true, true);

                    applyCardEvoDots(nextCardEl, nextCard);

                    nextCardSlotEl.appendChild(nextCardEl);

                }

                updateCardUI();

                refreshCardEvoIndicators();

            }
            function getRandomHeroId({ allowLocked = false, exclude = [] } = {}) {

                const excludeSet = new Set((Array.isArray(exclude) ? exclude : [exclude]).filter(Boolean));

                const heroIds = Object.keys(allCards).filter(id => {

                    if (excludeSet.has(id)) return false;

                    const card = allCards[id];

                    if (!card || !card.isSuperhero) return false;

                    if (allowLocked) return true;

                    const cardData = cardCollection[id];

                    return cardData && cardData.unlocked;

                });

                const trimmedPool = heroIds.length ? heroIds : Object.keys(allCards).filter(id => {

                    const card = allCards[id];

                    return card && card.isSuperhero && (allowLocked || (cardCollection[id] && cardCollection[id].unlocked));

                });

                if (!trimmedPool.length) return null;

                return trimmedPool[Math.floor(Math.random() * trimmedPool.length)];

            }



                        function startGameDecks() {

            

            

            

                            // Player

            

                            const deckToUseUnmodified = getDeckForMode(gameMode);

            

                            const heroId = getHeroSlotForMode(gameMode);

            

                            let deckToUse = [...deckToUseUnmodified];

                            if (gameMode === 'new_year_new_me') {

                                const eventHeroId = rollNewYearHero({ excludeCurrent: true }) || getRandomHeroId({
                                    allowLocked: true,
                                    exclude: heroOverrideForEvent
                                });

                                if (eventHeroId && deckToUse.length) {

                                    heroOverrideForEvent = eventHeroId;

                                    const heroIndexes = deckToUse.map((cid, idx) => (allCards[cid]?.isSuperhero ? idx : -1)).filter(idx => idx >= 0);

                                    if (heroIndexes.length) {

                                        deckToUse[heroIndexes[0]] = eventHeroId;

                                    } else {

                                        const swapIndex = Math.floor(Math.random() * deckToUse.length);

                                        deckToUse[swapIndex] = eventHeroId;

                                    }

                                }

                            }



                            if (heroId && gameMode !== 'new_year_new_me') {

            

                                deckToUse.push(heroId);

            

                            }

            

                            const modeKey = getMatchModeKey();

            

                            ensureMatchEvoSlotsForMode(modeKey);

            

                            gameDeck = shuffleDeck(deckToUse);

                hand = [];

                discardPile = [];

                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }

                nextCard = gameDeck.pop();

                renderHand();

                

                // AI

                const aiArenaLevel = getAILevel(); // This reflects the current arena level (1-12)

                const floorArenaNumber = Math.max(1, Math.min(18, getArenaNumberFromFloor(currentArenaFloor)));

                aiDeckArena = floorArenaNumber || Math.max(1, Math.min(18, aiArenaLevel));

                aiCanUseEvo = aiDeckArena >= 11;

                ai2CanUseEvo = aiCanUseEvo;

                

                // AI gets cards from its arena pool, NO tower card

                const aiArenaCards = getUnlockedCards(false, aiDeckArena, gameMode);

                

                // Build a random 8-card deck

                aiDeck = [];

                let availableCards = [...aiArenaCards];

                for (let i = 0; i < 8; i++) {

                    if (availableCards.length === 0) availableCards = [...aiArenaCards]; // Refill if needed

                    let cardIndex = Math.floor(Math.random() * availableCards.length);

                    aiDeck.push(availableCards.splice(cardIndex, 1)[0]);

                }

                

                let aiHeroId = null;

                if (gameMode === 'new_year_new_me') {

                    aiHeroId = getRandomHeroId({ allowLocked: true });

                } else if (superheroesUnlocked) {

                    aiHeroId = getRandomHeroId();

                }

                if (aiHeroId && aiDeck.length) {

                    aiDeck[Math.floor(Math.random() * aiDeck.length)] = aiHeroId;

                }

                aiDeck = shuffleDeck(aiDeck);

                aiHand = [];

                aiDiscardPile = [];

                for (let i = 0; i < 4; i++) { if(aiDeck.length > 0) aiHand.push(aiDeck.pop()); }

                if(aiDeck.length > 0) aiNextCard = aiDeck.pop();

                // Initialize second AI for 2v2 - uses all available cards

                if (gameMode === '2v2') {

                    ai2Deck = [];

                    // Get all cards except internal ones

                    const all2v2Cards = Object.keys(allCards).filter(cardId => 

                        cardId !== 'tower' && cardId !== 'miniStoneGiant'

                    );

                    let availableCards2 = [...all2v2Cards];

                    for (let i = 0; i < 8; i++) {

                        if (availableCards2.length === 0) availableCards2 = [...all2v2Cards];

                        let cardIndex = Math.floor(Math.random() * availableCards2.length);

                        ai2Deck.push(availableCards2.splice(cardIndex, 1)[0]);

                    }

                    ai2Deck = shuffleDeck(ai2Deck);

                    ai2Hand = [];

                    ai2DiscardPile = [];

                    for (let i = 0; i < 4; i++) { if(ai2Deck.length > 0) ai2Hand.push(ai2Deck.pop()); }

                    if(ai2Deck.length > 0) ai2NextCard = ai2Deck.pop();

                }

                configureAiEvolutionBudgets();

            }

            function playCard(cardId, handIndex, costOverride) {

                const costToUse = typeof costOverride === 'number' ? costOverride : allCards[cardId].cost;

                playerElixir -= costToUse;

                discardPile.push(cardId);

                hand.splice(handIndex, 1);

                hand.push(nextCard);

                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }

                nextCard = gameDeck.pop();

                renderHand();

            }

            function aiPlayCard(cardId) {

                if (!allCards[cardId]) return; // Safety check

                aiElixir -= allCards[cardId].cost;

                aiDiscardPile.push(cardId);

                const handIndex = aiHand.indexOf(cardId);

                if (handIndex > -1) { aiHand.splice(handIndex, 1); }

                aiHand.push(aiNextCard);

                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }

                aiNextCard = aiDeck.pop() || null;

            }

            function initGame() {

                if (gameLoopId) cancelAnimationFrame(gameLoopId); // Prevent multiple loops

                // keep the background particles animating during gameplay

                stopPreviewLoop(); // Stop preview loop during gameplay

                isDemoMode = false; // Disable demo mode during real games

                gameObjects = [];
                playerHeroUnit = null;

                // Initialize elixir to 7 for player, AI and teammate at the start of each match

                playerElixir = 7;

                aiElixir = 7;

                aiTeammateElixir = 7; // Reset AI teammate elixir to start at 7

                selectedSpawningUnit = null;

                isSpawningSpell = false;

                gameRunning = true;

                aiThinkTimer = 0;

                gameTimer = REGULATION_TIME;

                isOvertime = false;

                if (timerDisplay) timerDisplay.classList.remove('timer-display--overtime');

                isTieBreaker = false;

                tieBreakerTick = 0;

                overtimeInitialPlayerTowers = 0; // NEW

                overtimeInitialAiTowers = 0; // NEW

                

                // Reset spawn zones

                playerLeftTowerDestroyed = false;

                playerRightTowerDestroyed = false;

                aiLeftTowerDestroyed = false;

                aiRightTowerDestroyed = false;

                updatePlacementOverlay();

                // Reset evolution cycle counters for both player and AI.  

                // These counters track how many times each card has been played since the last evolved placement.

                playerEvoCycleCounts = {};

                aiEvoCycleCounts = {};

                ai2EvoCycleCounts = {};

                

                messageOverlay.style.display = 'none';

                startButton.style.display = 'none';

                menuButton.style.display = 'inline-block';

                const aiArenaLevel = getAILevel();

                const highestLevel = getHighestDeckCardLevel(gameMode);

                const allowBoost = highestLevel < 15 && Math.random() < 0.5;

                currentAiStatLevel = Math.min(15, highestLevel + (allowBoost ? 1 : 0));

                

                const useMaxLevel = isMaxLevelMatch();

                const playerTowerLevel = useMaxLevel ? 15 : towerLevel;

                const aiTowerLevel = useMaxLevel ? 15 : currentAiStatLevel;

                

                if (gameMode === '2v2') {

                    // 2v2: Two princess towers per side, one combined double king tower per side

                    // Use collection level if available for player

                    const pTowerData = towerCollection[selectedTower];

                    const pLvl = (pTowerData ? pTowerData.level : 15); // 2v2 defaults to 15 if no collection data

                    

                    gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, pLvl, false, selectedTower));

                    gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, pLvl, false, selectedTower));

                    gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, pLvl, true, selectedTower));

                    // AI Random Tower if high level

                    const aiType = (aiArenaLevel >= 10 && Math.random() > 0.5) ? ['waffle','machineGun','rocketeer'][Math.floor(Math.random()*3)] : 'princess';

                    gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiTowerLevel, false, aiType));

                    gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiTowerLevel, false, aiType));

                    gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiTowerLevel, true, aiType));

                } else if (gameMode === 'snowman_challenge') {

                    // Snowman Challenge: No Towers, Just Snowman Kings!

                    // Spawn them slightly forward so they have room to run

                    gameObjects.push(new SnowmanKing(WIDTH / 2, HEIGHT - 150, 'player'));

                    gameObjects.push(new SnowmanKing(WIDTH / 2, 150, 'ai'));

                } else {

                    // Normal: two princess towers, one king tower per side

                    const aiType = (aiArenaLevel >= 10 && Math.random() > 0.5) ? ['waffle','machineGun','rocketeer'][Math.floor(Math.random()*3)] : 'princess';

                    // Use collection level if available for player

                    const pTowerData = towerCollection[selectedTower];

                    const pLvl = useMaxLevel ? 15 : (pTowerData ? pTowerData.level : playerTowerLevel);

                    

                    gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, pLvl, false, selectedTower));

                    gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, pLvl, false, selectedTower));

                    gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, pLvl, false, selectedTower));

                    gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiTowerLevel, false, aiType));

                    gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiTowerLevel, false, aiType));

                    gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiTowerLevel, false, aiType));

                }

                startGameDecks();
                updateCardUI();
                // Initialize AI teammate if in 2v2 AI mode
                if (gameMode === '2v2' && is2v2AITeammate) {
                    initAITeammate();
                    updateAITeammateUI();
                }
            }

            const aiCounterConfig = [

                {

                    predicate: unit => unit instanceof EarthDragon,

                    cards: ['archer', 'zapDragon', 'fireDragon', 'arrows'],

                    defensive: true

                },

                {

                    predicate: unit => unit.isFlying,

                    cards: ['fireDragon', 'archer', 'arrows'],

                    defensive: true

                },

                {

                    predicate: unit => unit instanceof Skeleton || unit instanceof SkeletonArmy || unit instanceof Barbarians,

                    cards: ['poison', 'axeSwinger', 'arrows'],

                    defensive: true

                },

                {

                    predicate: unit => unit instanceof FlyingSkeleton || unit instanceof FlyingSkeletonGroup || unit instanceof MegaFlyingSkeleton,

                    cards: ['fireDragon', 'archer', 'arrows'],

                    defensive: true

                },

                {

                    predicate: isMeleeWinConditionUnit,

                    cards: ['farmer', 'tinyBot', 'barbarians'],

                    defensive: true

                },

                {

                    predicate: unit => unit instanceof FireDragon || unit instanceof ZapDragon,

                    cards: ['archer', 'arrows', 'zapDragon'],

                    defensive: true

                },

                {

                    minArena: 7,

                    predicate: unit => unit instanceof Giant || unit instanceof StoneGiant || unit instanceof DiddyGiant,

                    cards: ['poison', 'chaosOrb', 'goblinHex'],

                    defensive: true

                },

                {

                    minArena: 9,

                    predicate: unit => unit instanceof FireDragon || unit instanceof ZapDragon,

                    cards: ['goblinHex', 'poison', 'chaosOrb', 'fireDragon'],

                    defensive: true

                },

                {

                    predicate: isWinConditionUnit,

                    cards: ['zapSpirit', 'barbarians', 'goblins'],

                    defensive: true

                }

            ];

            function isMeleeWinConditionUnit(unit) {

                if (!unit) return false;

                const heavyCounters = [

                    Giant, Pigs, HorseRider, PigJockey, StoneGiant, ZapGiant,

                    ElixirGiant, ElixirGiantMini, ElixirGiantShard, DiddyGiant, MegaSmasher, BattleRam

                ];

                if (heavyCounters.some(cls => unit instanceof cls)) return true;

                if (unit instanceof Unit && !unit.isFlying && unit.targetsAir === false && unit.attackRange <= 40 && unit.health >= 1200) {

                    return true;

                }

                return false;

            }

            function isWinConditionUnit(unit) {

                return unit instanceof PigJockey || unit instanceof MegaSmasher || unit instanceof HorseRider || unit instanceof Pigs

                    || unit instanceof ElixirGiant || unit instanceof ElixirGiantMini || unit instanceof ElixirGiantShard || unit instanceof Rotter

                    || unit instanceof PrismVanguard || unit instanceof NebulaDrift || unit instanceof StarlineCorsair || unit instanceof AstralBastion;

            }

                        function evaluateUnitThreatScore(unit, towers) {

                            if (!unit || unit.health <= 0) return 0;

                            let score = unit.attackDamage || 0;

                            if (unit.isFlying) score += 25;

                            if (isWinConditionUnit(unit) || unit.isSuperhero) score += 40;

                            if (unit instanceof Unit && unit.targetsAir === false && unit.attackRange > 0 && !unit.isFlying) {

                                score += 10;

                            }

                            if (towers.length > 0) {

                                const closestDist = Math.min(...towers.map(t => getDistance(unit, t)));

                                score += Math.max(0, 250 - closestDist);

                            }

                            return score;

                        }

            function selectCounterCard(units, towers, strategy) {

                const sortedThreats = units

                    .map(u => ({ unit: u, score: evaluateUnitThreatScore(u, towers) }))

                    .filter(entry => entry.score > 0)

                    .sort((a, b) => b.score - a.score);

                for (const threat of sortedThreats) {

                    const counter = findCounterForUnit(threat.unit, strategy);

                    if (counter) return counter;

                }

                return null;

            }

            function summarizePlayerThreats(units) {

                const summary = {

                    hasFlying: false,

                    hasWinCon: false,

                    hasSwarm: false,

                    hasMelee: false,

                    totalHealth: 0,

                    targetingTower: false,

                    hasSplash: false,

                    hasZapThreat: false,

                    hasFlameDragon: false

                };

                units.forEach(unit => {

                    if (!unit || unit.health <= 0) return;

                    summary.totalHealth += unit.health;

                    if (unit.isFlying) summary.hasFlying = true;

                    if (isWinConditionUnit(unit) || isMeleeWinConditionUnit(unit)) summary.hasWinCon = true;

                    if (unit instanceof Skeleton || unit instanceof SkeletonArmy || unit instanceof GoblinGang || unit instanceof FlyingSkeletonGroup) summary.hasSwarm = true;

                    if (!unit.isFlying && unit.attackRange <= (unit.radius + 20)) summary.hasMelee = true;

                    if (unit.target instanceof Tower && unit.target.team === 'ai') summary.targetingTower = true;

                    const nearCount = units.filter(other => other !== unit && getDistance(other, unit) < 40).length;

                    if (nearCount >= 2) summary.hasSplash = true;

                    if (unit instanceof ZapSpirit || unit instanceof ZapWizard || unit instanceof ZapDragon || unit.emoji === 'âš¡') summary.hasZapThreat = true;

                    if (unit instanceof FlameDragon) summary.hasFlameDragon = true;

                });

                return summary;

            }

            const aiFallbackThreatCounters = [

                { condition: summary => summary.hasFlying, cards: ['zapDragon', 'fireDragon', 'archer', 'arrows'], defensive: true },

                { condition: summary => summary.hasSplash || summary.hasZapThreat, cards: ['arrows', 'poison', 'zapDragon'], defensive: true },

                { condition: summary => summary.targetingTower, cards: ['barbarians', 'farmer', 'tinyBot', 'axeSwinger'], defensive: true },

                { condition: summary => summary.hasWinCon, cards: ['barbarians', 'farmer', 'tinyBot', 'axeSwinger'], defensive: true },

                { condition: summary => summary.hasSwarm, cards: ['poison', 'arrows', 'axeSwinger'], defensive: true },

                { condition: summary => summary.hasFlameDragon, cards: ['zapDragon', 'archer', 'arrows', 'fireDragon'], defensive: true },

                { condition: summary => summary.hasMelee, cards: ['barbarians', 'axeSwinger', 'zapWizard'], defensive: true },

                { condition: summary => summary.hasWinCon && summary.totalHealth > 1200, cards: ['poison', 'chaosOrb', 'goblinHex'], defensive: true, minArena: 8 }

            ];

            function findFallbackCounter(summary, strategy) {

                for (const entry of aiFallbackThreatCounters) {

                    if (entry.minArena && strategy && strategy.arenaNumber < entry.minArena) continue;

                    if (!entry.condition(summary)) continue;

                    const candidate = entry.cards.find(cardId => aiHand.includes(cardId) && aiElixir >= (allCards[cardId]?.cost || Infinity));

                    if (candidate) {

                        if (strategy?.earlyArena && (allCards[candidate]?.cost || 0) > 5) continue;

                        return { card: candidate, isDefensive: entry.defensive };

                    }

                }

                return null;

            }

            function findStrongestAffordableUnitCard(strategy) {

                const candidates = aiHand

                    .filter(cardId => {

                        const card = allCards[cardId];

                        if (!card || card.type === 'Spell') return false;

                        if (strategy?.earlyArena && card.cost > 5) return false;

                        return aiElixir >= card.cost;

                    })

                    .sort((a, b) => {

                        const cardA = allCards[a];

                        const cardB = allCards[b];

                        if (strategy?.smartArena) {

                            const arenaDiff = (cardB?.arena || 0) - (cardA?.arena || 0);

                            if (arenaDiff !== 0) return arenaDiff;

                        }

                        return (cardB?.cost || 0) - (cardA?.cost || 0);

                    });

                return candidates.length > 0 ? candidates[0] : null;

            }

            function findCounterForUnit(unit, strategy) {

                for (const entry of aiCounterConfig) {

                    if (entry.minArena && strategy && strategy.arenaNumber < entry.minArena) continue;

                    if (!entry.predicate(unit)) continue;

                    for (const cardId of entry.cards) {

                        if (aiHand.includes(cardId) && aiElixir >= (allCards[cardId]?.cost || Infinity)) {

                            if (strategy?.earlyArena && (allCards[cardId]?.cost || 0) > 5) continue;

                            return { card: cardId, isDefensive: entry.defensive !== undefined ? entry.defensive : true };

                        }

                    }

                }

                return null;

            }

            function runAI() {

                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit);

                const arenaProfile = getArenaStrategyProfile();

                const urgentUnitThreshold = arenaProfile.earlyArena ? 4 : 3;

                if (aiHand.length === 0) {

                    if (aiDeck.length === 0 && aiDiscardPile.length > 0) {

                        aiDeck = shuffleDeck(aiDiscardPile);

                        aiDiscardPile = [];

                    }

                    if (aiDeck.length > 0) {

                        aiHand.push(aiDeck.pop());

                    }

                }

                if (playerUnits.length >= urgentUnitThreshold) {

                    const urgentCard = findStrongestAffordableUnitCard(arenaProfile);

                    if (urgentCard) {

                        spawnAIUnit(urgentCard, currentAiStatLevel, true);

                        return;

                    }

                    if (aiHand.length > 0) {

                        spawnAIUnit(aiHand[0], currentAiStatLevel, true);

                        return;

                    }

                }

                const aiTowers = gameObjects.filter(obj => obj.team === 'ai' && obj instanceof Tower && obj.health > 0);

                let towerThreats = playerUnits.filter(u => {

                    if (u.target && u.target instanceof Tower && u.target.team === 'ai') {

                        return true;

                    }

                    return aiTowers.some(t => getDistance(u, t) < 120);

                });

                if (arenaProfile.earlyArena && towerThreats.length > 0 && Math.random() < 0.35) {

                    towerThreats = [];

                }

                const aiKingTower = aiTowers.find(t => t.isKing && t.health > 0);

                const kingThreat = aiKingTower && playerUnits.some(u => {

                    if (!u || !u.health) return false;

                    if (u.target === aiKingTower) return true;

                    return getDistance(u, aiKingTower) < aiKingTower.radius + 80;

                });

                if (!towerThreats.length && kingThreat) {

                    towerThreats.push({ king: true });

                }

                if (playerUnits.length === 0 && aiTowers.length < 3) {

                    const pushCard = findStrongestAffordableUnitCard(arenaProfile);

                    if (pushCard) {

                        spawnAIUnit(pushCard, currentAiStatLevel, false);

                        return;

                    }

                }

                if (towerThreats.length > 0) {

                    const defenseOrder = ['poison', 'arrows', 'barbarians', 'archer', 'goblins'];

                    let defenseCard = null;

                    for (const candidate of defenseOrder) {

                        if (aiHand.includes(candidate) && aiElixir >= allCards[candidate].cost) {

                            defenseCard = candidate;

                            break;

                        }

                    }

                    if (defenseCard) {

                        spawnAIUnit(defenseCard, currentAiStatLevel, true);

                        return;

                    }

                }

                if (playerUnits.length > 0) {

                    let counterPlay = selectCounterCard(playerUnits, aiTowers, arenaProfile);

                    if (counterPlay && arenaProfile.earlyArena && (allCards[counterPlay.card]?.cost || 0) > 5) {

                        counterPlay = null;

                    }

                    if (counterPlay) {

                        spawnAIUnit(counterPlay.card, currentAiStatLevel, counterPlay.isDefensive);

                        return;

                    }

                    const threatSummary = summarizePlayerThreats(playerUnits);

                    const fallbackCounter = findFallbackCounter(threatSummary, arenaProfile);

                    if (fallbackCounter) {

                        spawnAIUnit(fallbackCounter.card, currentAiStatLevel, fallbackCounter.isDefensive);

                        return;

                    }

                    if (arenaProfile.preferSpells && playerUnits.length > 0) {

                        const advancedSpellCandidates = ['chaosOrb', 'goblinHex', 'poison'];

                        const spellToUse = advancedSpellCandidates.find(cardId => aiHand.includes(cardId) && aiElixir >= (allCards[cardId]?.cost || Infinity));

                        if (spellToUse) {

                            spawnAIUnit(spellToUse, currentAiStatLevel, true);

                            return;

                        }

                    }

                    let bestCardId = null;

                    // --- NEW AI LOGIC ---

                    if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && aiHand.includes('fireDragon') && aiElixir >= allCards['fireDragon'].cost) {

                         bestCardId = 'fireDragon';

                    } else if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup || u instanceof MegaFlyingSkeleton) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {

                         bestCardId = 'archer';

                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof Barbarians || u instanceof GoblinGang) && aiHand.includes('poison') && aiElixir >= allCards['poison'].cost) {

                        bestCardId = 'poison';

                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof Barbarians) && aiHand.includes('axeSwinger') && aiElixir >= allCards['axeSwinger'].cost) {

                        bestCardId = 'axeSwinger';

                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && aiHand.includes('arrows') && aiElixir >= allCards['arrows'].cost) {

                        bestCardId = 'arrows';

                    } else if (playerUnits.some(u => u instanceof Giant || u instanceof Pigs) && aiHand.includes('farmer') && aiElixir >= allCards['farmer'].cost) {

                        bestCardId = 'farmer';

                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) {

                        bestCardId = 'tinyBot';

                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('barbarians') && aiElixir >= allCards['barbarians'].cost) {

                        bestCardId = 'barbarians';

                    } else if (playerUnits.some(u => u instanceof FireDragon) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {

                        bestCardId = 'archer';

                    } else if (aiHand.includes('goblins') && aiElixir >= allCards['goblins'].cost) {

                        bestCardId = 'goblins';

                    }

                    if (bestCardId) { spawnAIUnit(bestCardId, currentAiStatLevel, true); return; } // Use global

                    const fallbackPush = findStrongestAffordableUnitCard(arenaProfile);

                    if (fallbackPush) {

                        spawnAIUnit(fallbackPush, currentAiStatLevel, false);

                        return;

                    }

                }

                

                // Fallback: If elixir is high, play a card

                if (aiElixir > 7) {

                    let bestCardId = null;

                    if(aiHand.includes('pigs') && aiElixir >= allCards['pigs'].cost) { bestCardId = 'pigs'; } // NEW

                    else if(aiHand.includes('giant') && aiElixir >= allCards['giant'].cost) { bestCardId = 'giant'; }

                    else if(aiHand.includes('barbarianHut') && aiElixir >= allCards['barbarianHut'].cost) { bestCardId = 'barbarianHut'; }

                    else if (aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) { bestCardId = 'tinyBot'; }

                    else if (aiHand.includes('megaFlyingSkeleton') && aiElixir >= allCards['megaFlyingSkeleton'].cost) { bestCardId = 'megaFlyingSkeleton'; }

                    else {

                        // Play any random affordable unit

                        let affordableCards = aiHand.filter(id => allCards[id] && allCards[id].cost <= aiElixir && allCards[id].type !== 'Spell');

                        if (affordableCards.length > 0) {

                            bestCardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];

                        }

                    }

                    if (bestCardId) { spawnAIUnit(bestCardId, currentAiStatLevel, false); return; } // Use global

                }

                // Use spell on tower

                if (aiElixir === MAX_ELIXIR && Math.random() < 0.2) {

                    let spellToUse = null;

                    if (aiHand.includes('poison')) spellToUse = 'poison';

                    else if (aiHand.includes('fireball')) spellToUse = 'fireball';

                    if (spellToUse) {

                        spawnAIUnit(spellToUse, currentAiStatLevel, false); // Use global

                        return;

                    }

                }

            }

            class TemporarySlowEffect extends GameObject {

                constructor(target, factor, durationSeconds) {

                    super(target.x, target.y, 0, 'neutral', 1);

                    this.target = target;

                    this.originalSpeed = target.speed;

                    this.factor = factor;

                    this.frames = Math.max(1, Math.round(durationSeconds * 60));

                    if (target.speed !== undefined && target.speed > 0) {

                        target.speed = Math.max(0.1, target.speed * factor);

                    }

                }

                update() {

                    if (!this.target || this.target.health <= 0) { this.health = 0; return; }

                    this.frames -= deltaTime * 60;

                    if (this.frames <= 0) {

                        if (this.target.speed !== undefined) {

                            this.target.speed = Math.max(0.1, this.originalSpeed);

                        }

                        this.health = 0;

                    } else {

                        this.x = this.target.x;

                        this.y = this.target.y;

                    }

                }

                draw() {

                    // Invisible effect

                }

            }

    class Tombstone extends Building {

        constructor(x, y, team, level = 1) {

            super(x, y, team, level, 'tombstone');

            this.spawnTimer = this.spawnRate;

            this.deathWaveSpawned = false;

        }

        update() {

            if (this.health <= 0) return;

            this.lifetime -= deltaTime * 60;

            const decayPerFrame = this.maxHealth / this.maxLifetime;

            this.health -= decayPerFrame * (deltaTime * 60);

            if (this.lifetime <= 0 || this.health <= 0) {

                if (!this.deathWaveSpawned) {

                    this.deathWaveSpawned = true;

                    this.spawnSkeletonWave(4);

                }

                this.health = 0;

                return;

            }

            this.spawnTimer -= deltaTime * 60;

            if (this.spawnTimer <= 0) {

                this.spawnTimer += this.spawnRate;

                this.spawnSkeletonWave(3);

            }

        }

        spawnSkeletonWave(count) {

            for (let i = 0; i < count; i++) {

                const angle = Math.random() * Math.PI * 2;

                const distance = this.radius + 8;

                const sx = this.x + Math.cos(angle) * distance + (Math.random() * 6 - 3);

                const sy = this.y + Math.sin(angle) * distance + (Math.random() * 6 - 3);

                const clampedX = Math.max(10, Math.min(WIDTH - 10, sx));

                const clampedY = Math.max(10, Math.min(HEIGHT - 10, sy));

                gameObjects.push(new Skeleton(clampedX, clampedY, this.team, this.spawnLevel));

            }

        }

    }

    class EarthSpirit extends Unit {

        constructor(x, y, team, level = 1) {

            const s = allCards['earthSpirit'].stats[level];

            super(x, y, s.radius || 10, team, s.health, 0, s.attackRange || 16, s.damage || 0, s.hitSpeed || 1, s.emoji || '??', false, false, level, allCards['earthSpirit'].aggroRange || 120);

            this.isTargetable = false;

            this.effectRadius = s.effectRadius || 60;

            this.freezeTimer = Math.max(1, Math.round((s.duration || 5) * 60));

            this.slowPercent = s.slowPercent || 0.25;

            this.affectedUnits = new Set();

            this.active = true;

        }

        update() {

            if (this.health <= 0) return;

            if (this.freezeTimer > 0) {

                this.freezeTimer -= deltaTime * 60;

                this.applyFreeze();

            } else if (this.active) {

                this.active = false;

                this.releaseSlow();

                this.health = 0;

            }

        }

        applyFreeze() {

            for (const obj of gameObjects) {

                if (obj.team === this.team) continue;

                if (!(obj instanceof Unit)) continue;

                if (obj instanceof Tower) continue;

                const dist = getDistance(this, obj);

                if (dist > this.effectRadius + (obj.radius || 0)) continue;

                if (obj._earthSpiritFrozenBy === this) continue;

                if (!obj._earthSpiritOriginalSpeed) {

                    obj._earthSpiritOriginalSpeed = obj.speed || 1;

                }

                obj._earthSpiritFrozenBy = this;

                obj._earthSpiritFrozen = true;

                obj.speed = 0;

                this.affectedUnits.add(obj);

            }

        }

        releaseSlow() {

            for (const obj of this.affectedUnits) {

                if (!obj || obj.health <= 0) continue;

                if (!obj._earthSpiritSlowedSources) obj._earthSpiritSlowedSources = new Set();

                if (obj._earthSpiritSlowedSources.has(this)) continue;

                obj._earthSpiritSlowedSources.add(this);

                const baseSpeed = obj._earthSpiritOriginalSpeed || obj.speed || 1;

                obj.speed = Math.max(0.1, baseSpeed * (1 - this.slowPercent));

                obj._earthSpiritFrozen = false;

                delete obj._earthSpiritOriginalSpeed;

                delete obj._earthSpiritFrozenBy;

            }

            this.affectedUnits.clear();

        }

        draw() {

            ctx.save();

            ctx.beginPath();

            ctx.arc(this.x, this.y, this.effectRadius, 0, Math.PI * 2);

            ctx.fillStyle = 'rgba(16, 185, 129, 0.15)';

            ctx.fill();

            ctx.strokeStyle = 'rgba(16, 185, 129, 0.6)';

            ctx.lineWidth = 2;

            ctx.stroke();

            ctx.restore();

        }

    }

            class Barricade extends Unit {

                constructor(x, y, team, level = 1) {

                    super(x, y, 14, team, 1, 0, 0, 0, 1, 'ðŸª¨', false, false, level, allCards['barricade'].aggroRange || 100);

                    this.lifetime = 30 * 60;

                    this.maxLifetime = this.lifetime;

                    this.isBarricade = true;

                    this.isTargetable = false;

                    this.blockSpacing = this.radius * 0.85;

                }

                update() {

                    if (this.health <= 0) return;

                    this.lifetime -= deltaTime * 60;

                    if (this.lifetime <= 0) {

                        this.health = 0;

            }

            }

                draw() {

                    ctx.save();

                    const alpha = Math.max(0, this.lifetime / this.maxLifetime);

                    ctx.globalAlpha = alpha * 0.95;

                    const rockRadius = this.radius * 0.65;

                    const spacing = this.blockSpacing;

                    const baseX = this.x - spacing;

                    for (let i = 0; i < 3; i++) {

                        const rockX = baseX + i * spacing;

                        ctx.fillStyle = '#78716c';

                        ctx.beginPath();

                ctx.arc(rockX, this.y, rockRadius, 0, Math.PI * 2);

                ctx.fill();

                ctx.strokeStyle = '#a8bcd3';

                ctx.lineWidth = 1.5;

                ctx.stroke();

                ctx.fillStyle = '#f1f5f9';

                        ctx.beginPath();

                        ctx.arc(rockX - rockRadius * 0.3, this.y - rockRadius * 0.3, rockRadius * 0.25, 0, Math.PI * 2);

                        ctx.fill();

                    }

                    ctx.globalAlpha = 1;

                    const timerWidth = rockRadius * 3 + spacing * 0.8;

            const timerHeight = 6;

            const timerX = this.x - timerWidth / 2;

            const timerY = this.y - this.radius - 16;

            const ratio = Math.max(0, Math.min(1, this.lifetime / this.maxLifetime));

            ctx.fillStyle = 'rgba(0,0,0,0.4)';

            ctx.fillRect(timerX, timerY, timerWidth, timerHeight);

            ctx.fillStyle = '#fcd34d';

            ctx.fillRect(timerX, timerY, timerWidth * ratio, timerHeight);

            ctx.strokeStyle = '#0f172a';

            ctx.lineWidth = 1;

            ctx.strokeRect(timerX, timerY, timerWidth, timerHeight);

            ctx.restore();

        }

    }


            function getElixirForTeam(team) {
                if (team === 'ai') return aiElixir;
                return playerElixir;
            }

            function consumeElixirForTeam(team, amount) {
                if (amount <= 0) return;
                if (team === 'ai') {
                    aiElixir = Math.max(0, aiElixir - amount);
                } else {
                    playerElixir = Math.max(0, playerElixir - amount);
                    if (typeof updateCardUI === 'function') updateCardUI();
                }
            }

            class SuperheroUnit extends Unit {

                constructor(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, heroId, aggroRange = 140, spawnLevel = 1) {

                    super(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, false, false, spawnLevel, aggroRange);

                    this.heroId = heroId;

                    this.isControlledHero = true;

                    this.heroAbilityData = (allCards[heroId] && allCards[heroId].ability) ? allCards[heroId].ability : null;

                    this.heroAbilityUses = this.heroAbilityData ? this.heroAbilityData.uses : null;

                    this.heroAbilityTimer = 0;

                    this.heroAbilityRange = this.heroAbilityData?.range || 180;

                    this.magnetActive = false;

                    this.magnetTimer = 0;

                    this.magnetTargets = [];
                    this.magnetEffect = null;
                    this.heroAuraTimer = 0;

                }

                update() {

                    if (this.heroAbilityTimer > 0) {

                        this.heroAbilityTimer = Math.max(0, this.heroAbilityTimer - deltaTime * 60);

                    }

                    super.update();

                    if (typeof this.updateHeroSpecific === 'function') {

                        this.updateHeroSpecific();

                    }

                }

                canUseHeroAbility() {

                    if (!this.heroAbilityData) return false;

                    if (this.heroAbilityTimer > 0) return false;

                    if (typeof this.heroAbilityUses === 'number' && this.heroAbilityUses <= 0) return false;

                    const abilityCost = typeof this.heroAbilityData.cost === 'number' ? this.heroAbilityData.cost : 0;

                    const teamElixir = getElixirForTeam(this.team);

                    if (abilityCost > 0 && typeof teamElixir === 'number' && teamElixir < abilityCost) return false;

                    return true;

                }

                markAbilityUse() {

                    if (typeof this.heroAbilityUses === 'number' && this.heroAbilityUses > 0) {

                        this.heroAbilityUses--;

                    }

                }

                triggerHeroAbility() {

                    if (!this.canUseHeroAbility()) return false;

                    const triggered = this.activateHeroAbility();

                    if (!triggered) return false;

                    this.heroAbilityTimer = 60;

                    this.markAbilityUse();

                    const abilityCost = typeof this.heroAbilityData?.cost === 'number' ? this.heroAbilityData.cost : 0;

                    if (abilityCost > 0) {

                        consumeElixirForTeam(this.team, abilityCost);

                    }

                    return true;

                }

                draw() {

                    const frameDelta = typeof deltaTime === 'number' ? deltaTime : 0.016;

                    this.heroAuraTimer = (this.heroAuraTimer || 0) + frameDelta * 60;

                    const pulse = (Math.sin(this.heroAuraTimer * 0.08) + 1) / 2;

                    const auraRadius = this.radius + 12 + pulse * 4;

                    ctx.save();

                    const gradient = ctx.createRadialGradient(this.x, this.y, this.radius + 2, this.x, this.y, auraRadius);

                    gradient.addColorStop(0, 'rgba(253, 224, 71, 0.35)');

                    gradient.addColorStop(1, 'rgba(245, 158, 11, 0)');

                    ctx.fillStyle = gradient;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, auraRadius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.restore();

                    super.draw();

                }

                activateHeroAbility() {

                    return false;

                }

            }

            function findClosestEnemyUnit(source, predicate = () => true, maxRange = Infinity) {

                let closest = null;

                let bestDist = maxRange;

                for (const obj of gameObjects) {

                    if (!obj || !obj.team || obj.team === source.team) continue;

                    if (obj === source) continue;

                    if (!(obj instanceof Unit)) continue;

                    if (!predicate(obj)) continue;

                    const dist = getDistance(source, obj);

                    if (dist < bestDist) {

                        bestDist = dist;

                        closest = obj;

                    }

                }

                return closest;

            }

            function findClosestEnemyStructure(source, maxRange = Infinity) {

                let closest = null;

                let bestDist = maxRange;

                for (const obj of gameObjects) {

                    if (!obj || !obj.team || obj.team === source.team) continue;

                    if (!(obj instanceof Tower) && !(obj instanceof Building)) continue;

                    const dist = getDistance(source, obj);

                    if (dist < bestDist) {

                        bestDist = dist;

                        closest = obj;

                    }

                }

                return closest;

            }

            class SuperSkeletonBone extends GameObject {

                constructor(x, y, team, angle, maxDistance = 360, target = null, destX = null, destY = null) {

                    super(x, y, 16, team, 1);

                    this.angle = angle;

                    this.speed = 12;

                    this.maxDistance = maxDistance;

                    this.travelled = 0;

                    this.damage = 160;

                    this.pathPush = 40;

                    this.hitObjects = new Set();

                    this.capturedTarget = target;

                    this.released = false;

                    this.releaseDamage = 120;

                    this.explosionRadius = 70;

                    const releaseMargin = 30;

                    this.startX = this.x;

                    this.destinationX = typeof destX === 'number' ? destX : this.x;

                    this.destinationY = typeof destY === 'number'
                        ? destY
                        : (team === 'player' ? -releaseMargin : HEIGHT + releaseMargin);

                    this.releaseLineY = this.destinationY;

                    if (this.capturedTarget) {

                        this.capturedTarget.isCarriedByBone = this;

                        this.capturedTarget.frozen = Math.max(this.capturedTarget.frozen || 0, 60);

                    }

                }

                detachCapturedTarget() {

                    if (!this.capturedTarget) return;

                    if (this.capturedTarget.isCarriedByBone === this) {

                        this.capturedTarget.isCarriedByBone = null;

                    }

                    this.capturedTarget.frozen = 0;

                    this.capturedTarget = null;

                }

                releaseTarget() {

                    if (this.released) return;

                    const heldTarget = this.capturedTarget;

                    if (heldTarget) {

                        if (heldTarget.isCarriedByBone === this) {

                            heldTarget.isCarriedByBone = null;

                        }

                        heldTarget.frozen = 0;

                        const offset = 18;

                        const landingY = this.team === 'player'
                            ? Math.max(10, Math.min(HEIGHT - 10, this.releaseLineY - 10))
                            : Math.max(10, Math.min(HEIGHT - 10, this.releaseLineY + 10));

                        heldTarget.x = Math.max(10, Math.min(WIDTH - 10, this.x + Math.cos(this.angle) * offset));

                        heldTarget.y = landingY;

                        applyDamage(heldTarget, this.releaseDamage);

                        this.capturedTarget = null;

                    }

                    for (const obj of gameObjects) {

                        if (!obj || obj.team === this.team || obj.health <= 0) continue;

                        if (obj === heldTarget) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Tower) && !(obj instanceof Building)) continue;

                        const dist = getDistance(this, obj);

                        if (dist >= this.explosionRadius) continue;

                        applyDamage(obj, this.damage);

                    }

                    gameObjects.push(new ExplosionEffect(this.x, this.y, this.explosionRadius));

                    this.hitObjects.clear();

                    this.released = true;

                    this.health = 0;

                }

                update() {

                    if (this.released) return;

                    const moveStep = this.speed * (deltaTime * 60);

                    this.x += Math.cos(this.angle) * moveStep;

                    this.y += Math.sin(this.angle) * moveStep;

                    this.travelled += moveStep;

                    if (this.capturedTarget && this.capturedTarget.health <= 0) {

                        this.detachCapturedTarget();

                    }

                    if (this.capturedTarget && this.capturedTarget.health > 0) {

                        this.capturedTarget.x = this.x;

                        this.capturedTarget.y = this.y;

                        this.capturedTarget.isCarriedByBone = this;

                        this.capturedTarget.frozen = Math.max(this.capturedTarget.frozen || 0, 30);

                    }

                    for (const obj of gameObjects) {

                        if (!obj || obj.team === this.team || obj.health <= 0) continue;

                        if (obj === this.capturedTarget) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Tower) && !(obj instanceof Building)) continue;

                        if (this.hitObjects.has(obj)) continue;

                        const dist = getDistance(this, obj);

                        if (dist > this.radius + (obj.radius || 0)) continue;

                        this.hitObjects.add(obj);

                        const angle = Math.atan2(obj.y - this.y, obj.x - this.x);

                        const isStructure = obj instanceof Tower || obj instanceof Building;
                        if (!isStructure) {
                            const push = this.pathPush;
                            obj.x = Math.max(10, Math.min(WIDTH - 10, obj.x + Math.cos(angle) * push));
                            obj.y = Math.max(10, Math.min(HEIGHT - 10, obj.y + Math.sin(angle) * push));
                        }
                        applyDamage(obj, this.damage);

                    }

                    const movingRight = this.destinationX > this.startX;

                    const reachedDestX = movingRight ? (this.x >= this.destinationX - 5) : (this.x <= this.destinationX + 5);

                    const releaseTrigger = this.travelled >= this.maxDistance || reachedDestX;

                    if (this.x < -30 || this.x > WIDTH + 30 || this.y < -30 || this.y > HEIGHT + 30 || releaseTrigger) {

                        this.releaseTarget();

                    }

                }

                draw() {

                    if (this.capturedTarget && this.capturedTarget.health > 0) {

                        ctx.save();

                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';

                        ctx.lineWidth = 3;

                        ctx.beginPath();

                        const ringRadius = (this.capturedTarget.radius || 10) + 6;

                        ctx.arc(this.capturedTarget.x, this.capturedTarget.y, ringRadius, 0, Math.PI * 2);

                        ctx.stroke();

                        ctx.restore();

                    }

                    ctx.save();

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.font = `${this.radius}px Arial`;

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'middle';

                    ctx.fillStyle = '#facc15';

                    ctx.fillText('ðŸ¦´', this.x, this.y);

                    ctx.restore();

                }

            }

            class SuperSkeleton extends SuperheroUnit {

                constructor(x, y, team, level = 1) {

                    const stats = (allCards['superSkeleton'].stats && (allCards['superSkeleton'].stats[level] || allCards['superSkeleton'].stats[1])) ? allCards['superSkeleton'].stats[level] || allCards['superSkeleton'].stats[1] : { health: 1400, damage: 140, hitSpeed: 1.25, speed: 0.85, attackRange: 18 };

                    super(x, y, 14, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, allCards['superSkeleton'].emoji, 'superSkeleton', allCards['superSkeleton'].aggroRange || 150, level);

                }

                activateHeroAbility() {

                    const target = findClosestEnemyUnit(this, obj => !obj.isBarricade && !(obj instanceof Tower), this.heroAbilityRange);

                    if (!target) return false;

                    const laneSwitchX = target.x < WIDTH / 2 ? LANE_RIGHT_X : LANE_LEFT_X;

                    const destY = this.y;

                    const destX = Math.max(10, Math.min(WIDTH - 10, laneSwitchX + (Math.random() - 0.5) * 10));

                    const angle = Math.atan2(destY - this.y, destX - this.x);

                    const maxDistance = Math.max(520, Math.hypot(destY - this.y, destX - this.x) + 120);

                    gameObjects.push(new SuperSkeletonBone(this.x, this.y, this.team, angle, maxDistance, target, destX, destY));

                    this.target = null;

                    this.recentlyThrownTarget = target;

                    this.recentThrowTimer = 120;

                    return true;

                }

                triggerHeroAbility() {

                    const triggered = super.triggerHeroAbility();

                    if (triggered) {

                        this.heroAbilityTimer = 420;

                    }

                    return triggered;

                }

                updateHeroSpecific() {

                    if (this.recentThrowTimer > 0) {

                        this.recentThrowTimer = Math.max(0, this.recentThrowTimer - deltaTime * 60);

                        if (this.recentThrowTimer === 0) {

                            this.recentlyThrownTarget = null;

                        }

                    }

                }

            }

            class SuperGoblin extends SuperheroUnit {

                constructor(x, y, team, level = 1) {

                    const stats = (allCards['superGoblin'].stats && (allCards['superGoblin'].stats[level] || allCards['superGoblin'].stats[1])) ? allCards['superGoblin'].stats[level] || allCards['superGoblin'].stats[1] : { health: 780, damage: 110, hitSpeed: 1.0, speed: 1.5, attackRange: 15 };

                    super(x, y, 14, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, allCards['superGoblin'].emoji, 'superGoblin', allCards['superGoblin'].aggroRange || 140, level);

                }

                                activateHeroAbility() {

                                    let target = findClosestEnemyStructure(this, this.heroAbilityRange);

                                    if (!target) return false;

                

                                    // If already very close to the target, find the next one

                                    if (getDistance(this, target) < this.radius + target.radius + 5) {

                                        const nextTarget = findClosestEnemyStructure(this, this.heroAbilityRange, target);

                                        if (nextTarget) {

                                            target = nextTarget;

                                        } else {

                                            // No other target, so don't use ability

                                            return false;

                                        }

                                    }

                                    

                                    const spawnSmoke = (x, y) => {

                                        gameObjects.push(new SmokePuff(x, y, this.team));

                                    };

                                    spawnSmoke(this.x, this.y);

                                    applyDamage(target, 180);

                                    const offset = this.team === 'player' ? -20 : 20;

                                    this.x = Math.max(10, Math.min(WIDTH - 10, target.x + offset));

                                    this.y = Math.max(10, Math.min(HEIGHT - 10, target.y));

                                    spawnSmoke(this.x, this.y);

                                    return true;

                                }

            }

            class SuperMagician extends SuperheroUnit {

                constructor(x, y, team, level = 1) {

                    const stats = (allCards['superMagician'].stats && (allCards['superMagician'].stats[level] || allCards['superMagician'].stats[1])) ? allCards['superMagician'].stats[level] || allCards['superMagician'].stats[1] : { health: 920, damage: 95, hitSpeed: 1.3, speed: 0.9, attackRange: 14 };

                    super(x, y, 14, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, allCards['superMagician'].emoji, 'superMagician', allCards['superMagician'].aggroRange || 140, level);

                    this.magnetActive = false;

                    this.magnetTimer = 0;

                    this.magnetTargets = [];

                    this.magnetEffect = null;

                }

                activateHeroAbility() {

                    this.magnetTargets = [];

                    for (const obj of gameObjects) {

                        if (!obj || obj.team === this.team || !(obj instanceof Unit) || obj instanceof Tower || obj.isBarricade) continue;

                        const dist = getDistance(this, obj);

                        if (dist <= this.heroAbilityRange) {

                            obj.frozen = 180;

                            this.magnetTargets.push(obj);

                        }

                    }

                    if (!this.magnetTargets.length) return false;

                    this.magnetActive = true;

                    this.ignoresTroops = true;

                    this.magnetTimer = 120;

                    this.frozen = true;

                    if (this.magnetEffect) {

                        this.magnetEffect.health = 0;

                    }

                    this.magnetEffect = new MagnetFieldEffect(this, this.heroAbilityRange + 12);

                    gameObjects.push(this.magnetEffect);

                    return true;

                }

                updateHeroSpecific() {

                    if (!this.magnetActive) return;

                    this.ignoresTroops = true;

                    if (this.magnetTimer > 0) {

                        this.magnetTimer = Math.max(0, this.magnetTimer - deltaTime * 60);

                        const pullRadius = this.heroAbilityRange + 12;

                        for (const obj of gameObjects) {

                            if (!obj || obj.team === this.team || !(obj instanceof Unit) || obj instanceof Tower || obj.isBarricade) continue;

                            if (this.magnetTargets.includes(obj)) continue;

                            const dist = getDistance(this, obj);

                            if (dist > pullRadius) continue;

                            obj.frozen = 30;

                            this.magnetTargets.push(obj);

                        }

                        this.magnetTargets.forEach(unit => {

                            if (!unit || unit.health <= 0) return;

                            const angle = Math.atan2(this.y - unit.y, this.x - unit.x);

                            unit.x += Math.cos(angle) * 2;

                            unit.y += Math.sin(angle) * 2;

                            unit.frozen = 30;

                        });

                        return;

                    } else {

                        const explosionRadius = Math.max(120, Math.min(220, this.heroAbilityRange + 30));

                        const explosionDamage = 190;

                        gameObjects.push(new ShockwavePulse(this.x, this.y, explosionRadius));

                        for (const obj of gameObjects) {

                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {

                                if (getDistance(this, obj) < explosionRadius) {

                                    applyDamage(obj, explosionDamage);

                                }

                            }

                        }

                        const push = 140;

                        this.magnetTargets.forEach(unit => {

                            if (!unit || unit.health <= 0) return;

                            const angle = Math.atan2(unit.y - this.y, unit.x - this.x);

                            const moveDistance = push + (unit.radius || 0);

                            unit.x = Math.max(10, Math.min(WIDTH - 10, unit.x + Math.cos(angle) * moveDistance));

                            unit.y = Math.max(10, Math.min(HEIGHT - 10, unit.y + Math.sin(angle) * moveDistance));

                            unit.frozen = 0;

                        });

                        this.magnetTargets = [];

                        this.magnetActive = false;

                        this.magnetTimer = 0;

                        this.frozen = false;

                        this.ignoresTroops = false;

                        if (this.magnetEffect) {

                            this.magnetEffect.health = 0;

                            this.magnetEffect = null;

                        }

                    }

                }

            }

            function getMirrorRequiredCost() {

                const previous = lastPlayedCardByTeam.player;

                if (!previous) return null;

                const prevCard = allCards[previous.cardId];

                if (prevCard && prevCard.type === 'Spell') return null;

                const baseCost = previous.cost || prevCard?.cost || 0;

                return Math.max(1, baseCost + 1);

            }

    function recordLastCardPlay(team, cardId, level, isEvo, cost) {

        if (!team || !cardId || cardId === 'mirror') return;

        const normalizedLevel = Math.min(15, Math.max(1, level || 1));

        lastPlayedCardByTeam[team] = {

            cardId,

            level: normalizedLevel,

            isEvo: !!isEvo,

            cost: typeof cost === 'number' ? cost : (allCards[cardId]?.cost || 0)

        };

    }

    function getOpposingTeam(team) {
        if (team === 'player') return 'ai';
        if (team === 'ai') return 'player';
        return 'ai';
    }

    function findDenseCluster({ team, radius = 90, minUnits = 3, focusLowHealth = false } = {}) {
        if (!team || radius <= 0) return null;
        const candidates = [];
        for (const obj of gameObjects) {
            if (!obj || obj.team !== team || obj.health <= 0) continue;
            if (obj instanceof Unit) {
                candidates.push(obj);
            }
        }
        if (!candidates.length) return null;
        const radiusSq = radius * radius;
        let best = null;
        for (const candidate of candidates) {
            let count = 0;
            let sumX = 0;
            let sumY = 0;
            let healthScore = 0;
            for (const other of candidates) {
                const dx = candidate.x - other.x;
                const dy = candidate.y - other.y;
                if (dx * dx + dy * dy <= radiusSq) {
                    sumX += other.x;
                    sumY += other.y;
                    count++;
                    if (focusLowHealth && other.maxHealth) {
                        const healthRatio = Math.max(0, Math.min(1, other.health / Math.max(1, other.maxHealth)));
                        healthScore += (1 - healthRatio);
                    }
                }
            }
            if (count < minUnits) continue;
            const score = count + (focusLowHealth ? healthScore : 0);
            if (!best || score > best.score) {
                best = { score, count, x: sumX / count, y: sumY / count };
            }
        }
        return best;
    }

    function clampToCanvas(x = WIDTH / 2, y = HEIGHT / 2) {
        return [
            Math.max(0, Math.min(WIDTH, x)),
            Math.max(0, Math.min(HEIGHT, y))
        ];
    }

    function getClusterPlacement(options = {}) {
        const cluster = findDenseCluster(options);
        if (!cluster) return null;
        const [x, y] = clampToCanvas(cluster.x, cluster.y);
        return { ...cluster, x, y };
    }

    function spawnSpellForCard(cardId, team, level, x, y, isEvo = false) {

        const card = allCards[cardId];

        if (!card) return false;

        const stats = card.stats[level] || card.stats[1] || {};

        if (cardId === 'bigStick') {

            const distance = 220;

            const speed = typeof stats.speed === 'number' ? stats.speed : 3.2;

            const pushDistance = stats.pushDistance || stats.push_distance || 32;

            const hitRadius = stats.hitRadius || stats.hit_radius || card.radius || 22;

            const dirX = 0;

            const dirY = team === 'player' ? -1 : 1;

            const stick = new BigStickRoll(x, y, team, dirX, dirY, distance, speed, stats.damage || 160, pushDistance, hitRadius);

            gameObjects.push(stick);

            return true;

        }

        
        if (cardId === 'novaPulse') {
            const pulses = Math.max(1, stats.pulses || 3);
            const interval = stats.pulseInterval || stats.pulse_interval || 0.55;
            const effectRadius = stats.radius || card.radius || 90;
            const damage = stats.damage || 0;
            gameObjects.push(new NovaPulseEffect(x, y, team, damage, pulses, interval, effectRadius));
            return true;
        }
if (cardId === 'poison') {

            gameObjects.push(new PoisonSpell(x, y, team, stats.damagePerSecond, card.radius, stats.duration));

            return true;

        }

        if (cardId === 'anger') {

            gameObjects.push(new AngerSpell(x, y, team, card.radius, stats.duration, stats.damage));

            return true;

        }

        if (cardId === 'voidTrap') {

            const damage = stats.damage || 0;

            gameObjects.push(new VoidTrapEffect(x, y, team, card.radius, damage));

            return true;

        }

        if (cardId === 'chaosOrb') {

            const damage = stats.damage || 0;

            gameObjects.push(new ChaosOrbEffect(x, y, team, card.radius, damage));

            return true;

        }

        if (cardId === 'skeletonYard') {

            gameObjects.push(new SkeletonYard(x, y, team, stats.duration || 6, card.radius, level));

            return true;

        }

        if (cardId === 'tornado') {

            gameObjects.push(new TornadoSpell(x, y, team, card.radius, stats.duration, stats.pullStrength, stats.damagePerSecond, card.emoji));

            return true;

        }

        if (cardId === 'meteor') {

            const damage = stats.damage || 0;

            gameObjects.push(new Projectile(x, y - 200, { x, y, health: 1 }, team, damage, card.radius));

            gameObjects.push(new Spell(x, y, team, damage, card.radius, card.emoji, isEvo));

            return true;

        }

        if (cardId === 'diddyMiner') {

            const miner = new DiddyMiner(x, y, team, level);

            if (miner instanceof GameObject) {

                gameObjects.push(miner);

            }

            return true;

        }

        if (cardId === 'starlightCascade') {

            const pulses = Math.max(1, stats.pulses || 3);

            const pulseDelay = stats.pulseDelay || 0.5;

            const effectRadius = stats.radius || card.radius || 120;

            gameObjects.push(new StarlightCascadeSpell(x, y, team, stats.damage || 0, effectRadius, pulses, pulseDelay));

            return true;

        }

        const damage = stats.damage || stats.damagePerSecond || 0;

        gameObjects.push(new Spell(x, y, team, damage, card.radius, card.emoji, isEvo));

        return true;

    }

    function getChaosTroopCandidates() {

        return Object.keys(allCards).filter(cardId => {

            const card = allCards[cardId];

            if (!card || card.hidden) return false;

            if (!card.unitClass || typeof card.unitClass !== 'function') return false;

            if (card.type === 'Spell' || card.type === 'Building' || card.type === 'Tower') return false;

            if (cardId === 'tower' || cardId === 'miniStoneGiant') return false;
 
            if (card.evo) return false;

            return true;

        });

    }

    function spawnChaosTroopForTeam(team) {

        if (gameMode !== 'chaos' || !team) return;

        const candidates = getChaosTroopCandidates();

        if (!candidates.length) return;

        const randomId = candidates[Math.floor(Math.random() * candidates.length)];

        const card = allCards[randomId];

        if (!card || !card.unitClass || typeof card.unitClass !== 'function') return;

        const spawnX = WIDTH / 2 + (Math.random() * 70 - 35);

        const spawnY = team === 'player'

            ? Math.min(HEIGHT - 40, HEIGHT - 60 + Math.random() * 20)

            : Math.max(20, 40 + Math.random() * 18);

        const chaosLevel = 15;

        let unit;
        const hasWindow = typeof window !== 'undefined';
        let prevPending;
        let prevCurrent;

        if (hasWindow) {
            prevPending = window.pendingEvoSpawn;
            prevCurrent = window.currentSpawnCardHasEvo;
        }

        try {
            if (hasWindow) {
                window.pendingEvoSpawn = false;
                window.currentSpawnCardHasEvo = false;
            }

            unit = new card.unitClass(spawnX, spawnY, team, chaosLevel);
        } finally {
            if (hasWindow) {
                window.pendingEvoSpawn = prevPending;
                window.currentSpawnCardHasEvo = prevCurrent;
            }
        }

        if (unit instanceof GameObject) {

            gameObjects.push(unit);

        }

    }

    function maybeTriggerChaosTroopSpawn(card, team) {

        if (gameMode !== 'chaos' || !team) return;

        if (!card) return;

        if (card.type === 'Spell' || card.type === 'Tower') return;

        spawnChaosTroopForTeam(team);

    }

    function spawnMirroredCardAt(cardId, team, level, x, y) {

        const card = allCards[cardId];

        if (!card) return false;

        const normalizedLevel = Math.min(15, Math.max(1, level || 1));

        if (card.type === 'Spell') {

            return spawnSpellForCard(cardId, team, normalizedLevel, x, y, false);

        }

        if (card.unitClass && typeof card.unitClass === 'function') {

            const newUnit = new card.unitClass(x, y, team, normalizedLevel);

            if (newUnit instanceof GameObject) {

                gameObjects.push(newUnit);

            }

            return true; // Swarm/unit constructors manage their own pushes, so treat as success

        }

        return false;

    }

    function spawnAIUnit(cardId, level, isDefensive = false) {

                const card = allCards[cardId];

                if (!card || card.cost > aiElixir) return;

                let aiEvoSpawn = shouldSpawnAiEvolution(cardId, card, aiEvoCycleCounts, aiCanUseEvo, aiEvoBudget);

                

                // Get AI's level for this card (force 15 in 2v2 or Party 1v1)

                const cardLevel = isMaxLevelMatch() ? 15 : level;

                

                if (card.type === 'Spell') {

                    let target = null;

                if (cardId === 'fireball') {

                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0 && o.health < 600);

                        if (!target) target = gameObjects.find(o => o.team === 'player' && (o instanceof Barbarian || o instanceof Farmer));

                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit);

                    } else if (cardId === 'arrows') {

                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Skeleton || o instanceof SkeletonArmy || o instanceof GoblinGang || o instanceof FlyingSkeleton || o instanceof FlyingSkeletonGroup));

                    } else if (cardId === 'poison') { // NEW

                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Tower) && o.health > 0);

                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit && o.y > RIVER_Y - 50);

                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit);

                    } else if (cardId === 'anger') { // NEW

                        target = gameObjects.find(o => o.team === 'ai' && (o instanceof Unit || o instanceof Tower || o instanceof Building) && o.health > 0);

                    } else if (cardId === 'voidTrap') { // NEW

                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0);

                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit && o.health > 0);

                    } else if (cardId === 'chaosOrb') { // NEW

                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Unit || o instanceof Building) && o.health > 0);

                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0);

                    } else if (cardId === 'starlightCascade') {

                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0);

                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit && o.health > 0);

                    }

                    if (cardId === 'bigStick') {

                        const startX = LANE_RIGHT_X - 40;

                        const startY = BRIDGE_Y + 5;

                        spawnSpellForCard(cardId, 'ai', cardLevel, startX, startY, aiEvoSpawn);

                        recordLastCardPlay('ai', cardId, cardLevel, aiEvoSpawn, card.cost);

                        maybeTriggerChaosTroopSpawn(card, 'ai');

                        aiPlayCard(cardId);

                        return;

                    }

                    if (target) {

                        if (cardId === 'poison') { // NEW

                            const s = card.stats[cardLevel];

                            gameObjects.push(new PoisonSpell(target.x, target.y, 'ai', s.damagePerSecond, card.radius, s.duration));

                        } else if (cardId === 'anger') { // NEW

                            const s = card.stats[cardLevel];

                            gameObjects.push(new AngerSpell(target.x, target.y, 'ai', card.radius, s.duration, s.damage));

                        } else if (cardId === 'voidTrap') { // NEW

                            const damage = card.stats[cardLevel].damage;

                            gameObjects.push(new VoidTrapEffect(target.x, target.y, 'ai', card.radius, damage));

                        } else if (cardId === 'chaosOrb') { // NEW

                            const damage = card.stats[cardLevel].damage;

                            gameObjects.push(new ChaosOrbEffect(target.x, target.y, 'ai', card.radius, damage));

                        } else if (cardId === 'starlightCascade') {

                            const s = card.stats[cardLevel];

                            const pulses = Math.max(1, s.pulses || 3);

                            const pulseDelay = s.pulseDelay || 0.5;

                            const effectRadius = s.radius || card.radius || 120;

                            gameObjects.push(new StarlightCascadeSpell(target.x, target.y, 'ai', s.damage || 0, effectRadius, pulses, pulseDelay));

                        } else {

                            const damage = card.stats[cardLevel].damage;

                            gameObjects.push(new Spell(target.x, target.y, 'ai', damage, card.radius, card.emoji, aiEvoSpawn));

                        }

                        recordLastCardPlay('ai', cardId, cardLevel, aiEvoSpawn, card.cost);

                        maybeTriggerChaosTroopSpawn(card, 'ai');

                        aiPlayCard(cardId);

                    }

                    return;

                }

                

                // NEW: Handle spirits

                if (card.type === 'Spirit') {

                    // Safety check: ensure unitClass exists

                    if (!card.unitClass || typeof card.unitClass !== 'function') {

                        console.error('Invalid unitClass for spirit card:', cardId, card);

                        return;

                    }

                    const spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;

                    const spawnY = isDefensive ? 150 + Math.random() * 50 : 50 + Math.random() * 50;

                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);

                    if (newUnit instanceof GameObject) {

                        gameObjects.push(newUnit);

                    }

                    recordLastCardPlay('ai', cardId, cardLevel, aiEvoSpawn, card.cost);

                    maybeTriggerChaosTroopSpawn(card, 'ai');

                    aiPlayCard(cardId);

                    return;

                }

                

                // Determine spawn Y & X

                let spawnY, spawnX;

                if (isDefensive) {

                    if (gameMode === 'snowman_challenge') {

                         // Snowman Defense: Spawn near the King to protect it

                         const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);

                         if (aiKing) {

                             spawnY = aiKing.y + (Math.random() * 60 - 30);

                             spawnX = aiKing.x + (Math.random() * 60 - 30);

                         } else {

                             spawnY = 150 + Math.random() * 50;

                             spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;

                         }

                    } else {

                        // Spawn behind princess towers

                        spawnY = 150 + Math.random() * 50;

                        spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;

                    }

                } else {

                    // Spawn at the back

                    spawnY = 50 + Math.random() * 50;

                    spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;

                }

                

                // Check if spawn is valid (not on top of another building)

                let canSpawn = true;

                if (card.type === 'Building') {

                    for (const obj of gameObjects) {

                        if (obj instanceof Tower || obj instanceof Building) {

                            const dist = getDistance({x: spawnX, y: spawnY}, obj);

                            if (dist < card.placementRadius + obj.radius) { 

                                canSpawn = false; 

                                break; 

                            }

                        }

                    }

                }

                

                if (canSpawn && card.unitClass && typeof card.unitClass === 'function') {

                    if (aiEvoSpawn) {

                        window.pendingEvoSpawn = true;

                        window.currentSpawnCardHasEvo = true;

                    }

                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);

                    // --- TYPEERROR FIX ---

                    // This is the bug. 'newUnit' is just the spawner (e.g. Pigs), not an actual Unit (e.g. Pig)

                    // We must check if the *class* is a single unit/building

                    if (newUnit instanceof GameObject) {

                        // If this is an evolved Knight, grant a 5 second shield

                        if (aiEvoSpawn && cardId === 'knight') {

                            newUnit.shieldTimer = 5;

                        }

                        gameObjects.push(newUnit);

                        recordLastCardPlay('ai', cardId, cardLevel, aiEvoSpawn, card.cost);

                        maybeTriggerChaosTroopSpawn(card, 'ai');

                    }

                    // Reset global evo flags after spawning AI unit

                    if (aiEvoSpawn) {

                        try {

                            window.pendingEvoSpawn = false;

                            window.currentSpawnCardHasEvo = false;

                        } catch(err) {}

                    }

                    aiPlayCard(cardId);

                }

            }

            class CelestialGuardian extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['celestialGuardian'];

                    const stats = template.stats[level];

                    const emoji = template.emoji || 'ðŸ›¡ï¸';

                    super(x, y, 16, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, emoji, false, false, level, template.aggroRange || 140);

                }

            }

            class NebulaSentinel extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['nebulaSentinel'];

                    const stats = template.stats[level];

                    const emoji = template.emoji || 'ðŸŒŒ';

                    super(x, y, 12, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, emoji, false, true, level, template.aggroRange || 150);

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    if (this.target instanceof PhantomKnight && this.target.isInvisible) return;

                    const damage = this.attackDamage;

                    const template = allCards['nebulaSentinel'];

                    const cardStats = template.stats[this.level] || template.stats[1];

                    const shardDamage = cardStats.shardDamage || Math.max(1, Math.round(damage * 0.35));

                    if (this.target instanceof Knight && this.target.isEvolved && this.target.shieldTimer > 0) {

                        applyDamage(this, damage);

                    } else {

                        const shardCount = template.shardCount || 7;

                        const shardSpread = template.shardSpread || 1.2;

                        const shardSpeed = template.shardSpeed || 5.5;

                        const shardLifetime = template.shardLifetime || 1.2;

                        const shardRadius = template.shardRadius || 5;

                        gameObjects.push(new NebulaBolt(this.x, this.y, this.target, this.team, damage, shardDamage, shardCount, shardSpread, shardSpeed, shardLifetime, shardRadius));

                    }

                    this.cooldownTimer = this.attackCooldown;

                }

            }

            class EchoSprite extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['echoSprite'];

                    const stats = template.stats[level] || template.stats[1];

                    const emoji = template.emoji || 'ðŸŒŸ';

                    super(x, y, 12, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, emoji, false, false, level, template.aggroRange || 140);

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    if (this.target instanceof PhantomKnight && this.target.isInvisible) return;

                    applyDamage(this.target, this.attackDamage, { sourceType: 'echoSprite' });

                    const echoTarget = this.findEchoTarget();

                    if (echoTarget) {

                        const echoDamage = Math.max(1, Math.round(this.attackDamage * 0.45));

                        applyDamage(echoTarget, echoDamage, { sourceType: 'echoSprite' });

                        if (echoTarget.health > 0) {

                            echoTarget.x += (this.team === 'player' ? 1 : -1) * 14;

                        }

                    }

                    this.cooldownTimer = this.attackCooldown;

                }

                findEchoTarget() {

                    let best = null;

                    let shortest = 60;

                    for (const obj of gameObjects) {

                        if (obj === this.target) continue;

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit)) continue;

                        if (obj.isFlying) continue;

                        const dist = getDistance(this, obj);

                        if (dist < shortest) {

                            shortest = dist;

                            best = obj;

                        }

                    }

                    return best;

                }

            }

            class BulletGoblin extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['bulletGoblin'];

                    const stats = template.stats[level] || template.stats[1];

                    const emoji = template.emoji || 'ðŸ”«';

                    super(x, y, 10, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, emoji, false, true, level, template.aggroRange || 160);

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    if (this.target instanceof PhantomKnight && this.target.isInvisible) return;

                    const damage = this.attackDamage;

                    const bolt = new Projectile(this.x, this.y, this.target, this.team, damage, 0, 'bulletGoblin');

                    bolt.speed = Math.max(6, (allCards['bulletGoblin'].stats[this.level]?.projectileSpeed || 8));

                    bolt.radius = 3;

                    gameObjects.push(bolt);

                    this.cooldownTimer = this.attackCooldown;

                }

            }

            class ResonantBeacon extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'resonantBeacon');

                    const template = allCards['resonantBeacon'];

                    const stats = template.stats[level] || template.stats[1];

                    this.pulseDamage = stats.damage || 90;

                    this.pulseRange = stats.range || 150;

                    const interval = parseFloat(stats.pulse_interval || stats.pulseInterval || 1.6);

                    this.pulseInterval = Math.max(0.4, interval) * 60;

                    this.pulseTimer = this.pulseInterval;

                    this.beamSpeed = stats.beam_speed || stats.beamSpeed || 7;

                    this.pushDistance = stats.push_distance || stats.pushDistance || 18;

                }

                update() {

                    if (this.health <= 0) return;

                    this.lifetime -= deltaTime * 60;

                    if (this.lifetime <= 0) {

                        this.health = 0;

                        return;

                    }

                    this.pulseTimer -= deltaTime * 60;

                    if (this.pulseTimer <= 0) {

                        const target = this.findTarget();

                        if (target) {

                            const beam = new Projectile(this.x, this.y, target, this.team, this.pulseDamage, 0, 'resonantBeacon');

                            beam.speed = this.beamSpeed;

                            gameObjects.push(beam);

                            if (target.health > 0) {

                                target.x += (this.team === 'player' ? -1 : 1) * this.pushDistance;

                            }

                        }

                        this.pulseTimer = this.pulseInterval;

                    }

                }

                findTarget() {

                    let best = null;

                    let shortest = this.pulseRange || 140;

                    for (const obj of gameObjects) {

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit)) continue;

                        if (obj.isFlying) continue;

                        const dist = getDistance(this, obj);

                        if (dist < shortest) {

                            shortest = dist;

                            best = obj;

                        }

                    }

                    return best;

                }

                draw() {

                    super.draw();

                    ctx.save();

                    ctx.strokeStyle = '#c084fc';

                    ctx.lineWidth = 2;

                    ctx.globalAlpha = 0.6;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, Math.min(60, this.pulseRange * 0.4), 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class PrismLattice extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'prismLattice');

                    const stats = allCards['prismLattice'].stats[level] || allCards['prismLattice'].stats[1] || {};

                    this.pulseDamage = stats.pulseDamage || 42;

                    this.pulseRadius = stats.pulseRadius || 92;

                    const interval = Math.max(0.3, parseFloat(stats.pulseInterval) || 0.7);

                    this.pulseInterval = interval * 60;

                    this.pulseTimer = this.pulseInterval;

                    this.pushDistance = stats.pushDistance || 14;

                }

                update() {

                    if (this.health <= 0) return;

                    super.update();

                    if (this.health <= 0) return;

                    this.pulseTimer -= deltaTime * 60;

                    if (this.pulseTimer <= 0) {

                        this.pulseTimer += this.pulseInterval;

                        const pushDir = this.team === 'player' ? -1 : 1;

                        for (const obj of gameObjects) {

                    if (obj.team === this.team || obj.health <= 0) continue;

                    if (!(obj instanceof Unit) && !(obj instanceof Tower)) continue;

                            if (getDistance(this, obj) > this.pulseRadius) continue;

                            applyDamage(obj, this.pulseDamage, { sourceType: 'prismLattice' });

                            if (obj.health > 0) {

                                obj.x += pushDir * this.pushDistance;

                            }

                        }

                    }

                }

                draw() {

                    super.draw();

                    ctx.save();

                    ctx.strokeStyle = 'rgba(56, 189, 248, 0.7)';

                    ctx.lineWidth = 2;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.pulseRadius, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class ZapTesla extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'zapTesla');

                    const stats = allCards['zapTesla'].stats[level] || allCards['zapTesla'].stats[1] || {};

                    this.zapRange = stats.zapRange || 140;

                    const interval = Math.max(0.3, parseFloat(stats.zapInterval) || 0.6);

                    this.zapInterval = interval * 60;

                    this.zapTimer = this.zapInterval;

                    this.zapDamage = stats.zapDamage || 64;

                    this.pushDistance = stats.pushDistance || 16;

                    this.isUnderground = true;

                    this.isSpellImmune = true;

                }

                update() {

                    if (this.health <= 0) return;

                    super.update();

                    if (this.health <= 0) return;

                    if (this.isUnderground) {

                        const target = this.findGroundTarget(this.zapRange);

                        if (target) {

                            this.isUnderground = false;

                            this.isSpellImmune = false;

                            this.zapTimer = this.zapInterval;

                        }

                        return;

                    }

                    this.zapTimer -= deltaTime * 60;

                    if (this.zapTimer <= 0) {

                        this.zapTimer += this.zapInterval;

                        const target = this.findGroundTarget(this.zapRange);

                        if (target) {

                            applyDamage(target, this.zapDamage, { sourceType: 'zapTesla', ignoreSpellImmunity: true });

                            spawnZapTrail(this, [target], '#7dd3fc', 12);

                        }

                    }

                }

                findGroundTarget(range) {

                    let best = null;

                    let shortest = range;

                    for (const obj of gameObjects) {

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Tower)) continue;

                        const dist = getDistance(this, obj);

                        if (dist > range) continue;

                        if (dist < shortest) {

                            shortest = dist;

                            best = obj;

                        }

                    }

                    return best;

                }

                draw() {

                    super.draw();

                    ctx.save();

                    ctx.lineWidth = 2;

                    ctx.strokeStyle = this.isUnderground ? 'rgba(148, 163, 184, 0.7)' : 'rgba(14, 165, 233, 0.8)';

                    if (this.isUnderground) ctx.setLineDash([6, 4]);

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.zapRange, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                    ctx.save();

                    ctx.font = '18px Inter';

                    ctx.textAlign = 'center';

                    ctx.textBaseline = 'bottom';

                    ctx.fillStyle = this.isUnderground ? '#94a3b8' : '#22c55e';

                    const statusEmoji = this.isUnderground ? 'ðŸ•³ï¸' : 'âš¡';

                    ctx.fillText(statusEmoji, this.x, this.y - this.radius - 4);

                    ctx.restore();

                }

            }

            class PrismShard extends Unit {

                constructor(x, y, team, level = 1) {

                    super(x, y, 6, team, 150, 1.6, 12, 45, 1.0, '\u2728', false, false, level, 80);


                    this.lifeSpan = 70;

                }

                update() {

                    super.update();

                    this.lifeSpan -= deltaTime * 60;

                    if (this.lifeSpan <= 0) {

                        this.health = 0;

                    }

                }

            }

            class PrismVanguard extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['prismVanguard'];

                    const stats = template.stats[level] || template.stats[1];

                                        const emoji = template.emoji || '\U0001F5E1\uFE0F\U00002728';


                    super(x, y, 12, team, stats.health, stats.speed, stats.attackRange || 18, stats.damage, stats.hitSpeed, emoji, false, false, level, template.aggroRange || 120);

                    this.isWinCondition = true;
                    this.ignoresTroops = true;

                    this.shardTimer = 0;

                    this.shardCooldown = 120;

                    this.shardCount = stats.splitCount || 3;

                    this.shardDamage = stats.splitDamage || 45;

                    this.shardRange = stats.splitRange || 40;

                }

                update() {

                    if (this.shardTimer > 0) {

                        this.shardTimer = Math.max(0, this.shardTimer - deltaTime * 60);

                    }

                    super.update();

                }

                attack() {

                    if (!this.target) return;

                    const buildingHit = (this.target instanceof Tower) || (this.target instanceof Building);

                    super.attack();

                    if (buildingHit && this.shardTimer <= 0) {

                        this.shardTimer = this.shardCooldown;

                        for (let i = 0; i < this.shardCount; i++) {

                            const angle = (Math.PI * 2 / this.shardCount) * i + (Math.random() - 0.5) * 0.4;

                            const distance = this.shardRange + Math.random() * 10;

                            const sx = this.x + Math.cos(angle) * distance;

                            const sy = this.y + Math.sin(angle) * distance;

                            const shard = new PrismShard(sx, sy, this.team, this.level);

                            shard.attackDamage = this.shardDamage;

                            shard.target = this.target;

                            shard.speed = Math.max(1.1, this.speed + 0.1);

                            gameObjects.push(shard);

                        }

                    }

                }

                findTarget(forceFindTower = false) {

                    return findClosestEnemyTowerTarget(this);

                }

            }

            class NebulaDart extends Unit {

                constructor(x, y, team, level = 1) {

                    const emoji = 'ðŸŒ€';

                    super(x, y, 6, team, 160, 1.9, 12, 55, 0.9, emoji, false, false, level, 120);

                    this.lifeSpan = 80;

                    this.splashRange = 0;

                    this.splashDamage = 0;

                }

                update() {

                    super.update();

                    this.lifeSpan -= deltaTime * 60;

                    if (this.lifeSpan <= 0) this.health = 0;

                }

                attack() {

                    if (!this.target) return;

                    const towerTarget = this.target instanceof Tower ? this.target : null;

                    super.attack();

                    if (towerTarget && this.splashDamage > 0) {

                        for (const obj of gameObjects) {

                            if (!obj || obj === towerTarget || obj.team !== this.team) continue;

                            if (!(obj instanceof Tower)) continue;

                            const dist = getDistance(this, obj);

                            if (dist > this.splashRange) continue;

                            applyDamage(obj, this.splashDamage, { sourceType: 'nebulaDartSplash' });

                        }

                    }

                }

                findTarget(forceFindTower = false) {

                    return findClosestEnemyTowerTarget(this);

                }

            }

            class NebulaDrift extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['nebulaDrift'];

                    const stats = template.stats[level] || template.stats[1];

                                                                                                                        const emoji = template.emoji || '\U0001F30C\U0001F6F0\uFE0F';


                    super(x, y, 12, team, stats.health, stats.speed, stats.attackRange || 22, stats.damage, stats.hitSpeed, emoji, false, false, level, template.aggroRange || 120);

                    this.isWinCondition = true;
                    this.ignoresTroops = true;

                    this.splitTriggered = false;

                    this.splitThreshold = stats.splitThreshold || 0.7;

                    this.splitCount = stats.splitCount || 3;

                    this.splitSpeed = stats.splitSpeed || 1.8;

                    this.splitDamage = stats.splitDamage || 90;

                    this.splitRange = stats.splitRange || 56;

                    this.splitSplashRange = stats.splitSplashRange || 58;

                    this.splitSplashDamage = stats.splitSplashDamage || Math.round(this.splitDamage * 0.45);

                    this.maxHealth = stats.health;

                }

                update() {

                    if (!this.splitTriggered && this.maxHealth > 0) {

                        const healthRatio = this.health / this.maxHealth;
                        const closeTower = this.findClosestEnemyTower();
                        const nearTower = closeTower && getDistance(this, closeTower) <= this.splitRange;

                        if (closeTower && (healthRatio <= this.splitThreshold || nearTower)) {

                            this.splitTriggered = true;

                            this.spawnDarts(closeTower);

                        }

                    }

                    super.update();

                }

                spawnDarts(targetTower = null) {

                    const primaryTarget = targetTower || this.findClosestEnemyTower();

                    for (let i = 0; i < this.splitCount; i++) {

                        const offsetX = (Math.random() - 0.5) * 18;

                        const offsetY = (Math.random() - 0.5) * 18;

                        const dart = new NebulaDart(this.x + offsetX, this.y + offsetY, this.team, this.level);

                        dart.attackDamage = this.splitDamage;

                        dart.speed = this.splitSpeed;

                        dart.splashRange = this.splitSplashRange;

                        dart.splashDamage = this.splitSplashDamage;

                        if (primaryTarget) {
                            dart.target = primaryTarget;
                        }

                        gameObjects.push(dart);

                    }

                }

                findClosestEnemyTower() {

                    return findClosestEnemyTowerTarget(this);

                }

                findTarget(forceFindTower = false) {

                    return this.findClosestEnemyTower();

                }

            }

            class StarlineCorsair extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['starlineCorsair'];

                    const stats = template.stats[level] || template.stats[1];

                                        const emoji = template.emoji || '\U0001F680\u26A1';


                    super(x, y, 12, team, stats.health, stats.speed, stats.attackRange || 118, stats.damage, stats.hitSpeed, emoji, false, true, level, template.aggroRange || 140);

                    this.isWinCondition = true;
                    this.ignoresTroops = true;

                    this.baseDamage = stats.damage;

                    this.chainCount = 0;

                    this.chainTimer = 0;

                    this.chainAbilityCooldown = 0;

                    this.chainCooldownDuration = stats.chainCooldown || template.chainCooldown || 140;

                    this.burstSpeed = stats.bonusSpeed || 1.4;

                    this.preferredLaneX = this.x < WIDTH / 2 ? LANE_LEFT_X : LANE_RIGHT_X;

                    this.laneSwitchThreshold = template.laneSwitchThreshold || 2;

                    this.laneSwitchRange = template.laneSwitchRange || 70;

                    this.laneSwitched = false;

                    this.isPhaseTraveling = false;

                    this.phaseOriginX = this.x;

                    this.phaseTargetX = this.preferredLaneX;

                    this.phaseDirection = this.x < WIDTH / 2 ? 'left' : 'right';

                    this.phaseTravelProgress = 0;

                    this.phaseTravelDuration = 45;

                    this.phaseSparkleAngle = 0;

                }

                update() {

                    if (this.chainTimer > 0) {

                        this.chainTimer -= deltaTime * 60;

                        if (this.chainTimer <= 0) {

                            this.chainCount = 0;

                        }

                    }

                    if (this.chainAbilityCooldown > 0) {

                        this.chainAbilityCooldown = Math.max(0, this.chainAbilityCooldown - deltaTime * 60);

                    }

                    this.monitorLanePressure();

                    if (this.isPhaseTraveling) {

                        this.updatePhaseTravel();

                        return;

                    }

                    super.update();

                }

                attack() {

                    if (!this.target) return;

                    const currentTarget = this.target;

                    const buildingHit = currentTarget && (currentTarget instanceof Tower || currentTarget instanceof Building);

                    if (!buildingHit) return;

                    this.attackDamage = this.baseDamage;

                    super.attack();

                    this.chainTimer = 0;

                    this.chainAbilityCooldown = 0;

                    this.lastTargetRef = currentTarget && currentTarget.health > 0 ? currentTarget : null;

                }

                monitorLanePressure() {

                    if (this.laneSwitched) return;

                    const leftCount = this.countLaneUnits('left');

                    const rightCount = this.countLaneUnits('right');

                    const currentLaneKey = this.preferredLaneX === LANE_LEFT_X ? 'left' : 'right';

                    const otherLaneKey = currentLaneKey === 'left' ? 'right' : 'left';

                    const currentCount = currentLaneKey === 'left' ? leftCount : rightCount;

                    const otherCount = otherLaneKey === 'left' ? leftCount : rightCount;

                    if (currentCount >= this.laneSwitchThreshold && otherCount < currentCount) {

                        this.target = null;

                        this.startLanePhase(otherLaneKey);

                        if (typeof window !== 'undefined' && typeof window.onStarlineLaneSwitch === 'function') {

                            window.onStarlineLaneSwitch(otherLaneKey);

                        }

                    }

                }

                startLanePhase(targetLaneKey) {

                    if (this.isPhaseTraveling) return;

                    this.laneSwitched = true;

                    this.phaseDirection = targetLaneKey;

                    this.phaseOriginX = this.x;

                    this.phaseTargetX = targetLaneKey === 'left' ? LANE_LEFT_X : LANE_RIGHT_X;

                    const distance = Math.abs(this.phaseTargetX - this.phaseOriginX);

                    this.phaseTravelDuration = Math.max(35, Math.min(75, Math.round(distance / WIDTH * 60 + 20)));

                    this.phaseTravelProgress = 0;

                    this.isPhaseTraveling = true;

                    this.isTargetable = false;

                    if (typeof window !== 'undefined' && typeof window.onStarlinePhaseStart === 'function') {

                        window.onStarlinePhaseStart(targetLaneKey);

                    }

                }

                updatePhaseTravel() {

                    this.phaseTravelProgress += deltaTime * 60;

                    const progress = Math.min(1, this.phaseTravelProgress / this.phaseTravelDuration);

                    this.x = this.phaseOriginX + (this.phaseTargetX - this.phaseOriginX) * progress;

                    this.phaseSparkleAngle += 0.2 + progress * 0.1;

                    if (typeof window !== 'undefined' && typeof window.onStarlinePhaseUpdate === 'function') {

                        window.onStarlinePhaseUpdate(this.x, this.y, this.phaseDirection);

                    }

                    if (progress >= 1) {

                        this.completePhaseTravel();

                    }

                }

                completePhaseTravel() {

                    this.isPhaseTraveling = false;

                    this.isTargetable = true;

                    this.preferredLaneX = this.phaseTargetX;

                    this.target = null;

                    if (typeof window !== 'undefined' && typeof window.onStarlinePhaseComplete === 'function') {

                        window.onStarlinePhaseComplete(this.phaseDirection);

                    }

                }

                countLaneUnits(laneKey) {

                    let count = 0;

                    for (const obj of gameObjects) {

                        if (!obj || obj.health <= 0) continue;

                        if (obj.team === this.team) continue;

                        if (!(obj instanceof Unit)) continue;

                        if (obj.isFlying) continue;

                        const key = obj.x < WIDTH / 2 ? 'left' : 'right';

                        if (key === laneKey) {

                            count++;

                        }

                    }

                    return count;

                }

                draw() {

                    if (this.isPhaseTraveling) {

                        ctx.save();

                        const shimmer = (Math.sin(this.phaseSparkleAngle) + 1) / 2;

                        const glowRadius = this.radius * (1.5 + shimmer * 0.6);

                        ctx.globalAlpha = 0.65 + shimmer * 0.35;

                        ctx.fillStyle = `rgba(255, 255, 255, ${0.65 + shimmer * 0.2})`;

                        ctx.beginPath();

                        ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);

                        ctx.fill();

                        ctx.strokeStyle = '#fde047';

                        ctx.lineWidth = 3;

                        ctx.stroke();

                        ctx.restore();

                        return;

                    }

                    super.draw();

                }

                findSecondaryTargets(max = 1, primary = null) {

                    const candidates = [];

                    for (const obj of gameObjects) {

                        if (!obj || obj === primary || obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Tower)) continue;

                        const dist = getDistance(this, obj);

                        candidates.push({ dist, obj });

                    }

                    candidates.sort((a, b) => a.dist - b.dist);

                    return candidates.slice(0, max).map(entry => entry.obj);

                }

                findTarget(forceFindTower = false) {

                    return findClosestEnemyTowerTarget(this);

                }

            }

            class AstralBastion extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['astralBastion'];

                    const stats = template.stats[level] || template.stats[1];

                                        const emoji = template.emoji || '\U0001F31F\U0001F6E1\uFE0F';


                    super(x, y, 14, team, stats.health, stats.speed, stats.attackRange || 96, stats.damage, stats.hitSpeed, emoji, false, false, level, template.aggroRange || 160);

                    this.isWinCondition = true;
                    this.ignoresTroops = true;

                    this.baseAttackRange = this.attackRangeBase;

                    this.baseAttackCooldown = this.attackCooldown;

                    this.buffRadius = stats.buffRadius || 70;

                    this.pulseDamage = stats.pulseDamage || 38;

                    this.pulseTimer = (stats.pulseInterval || 2.8) * 60;

                    this.pulseCooldown = Math.max(1, (stats.pulseInterval || 2.8)) * 60;

                }

                update() {

                    let closeAllies = 0;

                    for (const obj of gameObjects) {

                        if (obj === this || obj.team !== this.team) continue;

                        if (!(obj instanceof Unit)) continue;

                        if (getDistance(this, obj) > this.buffRadius) continue;

                        closeAllies++;

                    }

                    this.attackRange = this.baseAttackRange + closeAllies * 8;

                    const cooldownReduction = Math.min(40, closeAllies * 5);

                    this.attackCooldown = Math.max(25, this.baseAttackCooldown - cooldownReduction);

                    this.pulseTimer -= deltaTime * 60;

                    if (this.pulseTimer <= 0) {

                        this.pulseTimer += this.pulseCooldown;

                        this.emitPulse();

                    }

                    super.update();

                }

                emitPulse() {

                    for (const obj of gameObjects) {

                        if (!obj || obj.health <= 0) continue;

                        const dist = getDistance(this, obj);

                        if (dist > this.buffRadius) continue;

                        if (obj.team === this.team && obj instanceof Unit && obj.cooldownTimer !== undefined) {

                            obj.cooldownTimer = Math.max(0, obj.cooldownTimer - 12);

                        }

                        if (obj.team !== this.team && obj instanceof Tower) {

                            applyDamage(obj, this.pulseDamage, { sourceType: 'astralBastionPulse' });

                        }

                    }

                }

                findTarget(forceFindTower = false) {

                    return findClosestEnemyTowerTarget(this);

                }

            }

            class StarSpark extends Unit {

                constructor(x, y, team, level = 1) {

                    const template = allCards['starSwarm'];

                    const stats = template.stats[level] || template.stats[1];

                    const emoji = template.emoji || 'âœ¨';

                    super(x, y, 10, team, stats.health, stats.speed, stats.attackRange, stats.damage, stats.hitSpeed, emoji, false, false, level, template.aggroRange || 120);

                }

                attack() {

                    if (!this.target || this.cooldownTimer > 0) return;

                    applyDamage(this.target, this.attackDamage, { sourceType: 'starSwarm' });

                    this.cooldownTimer = this.attackCooldown;

                }

            }

            class StarSwarm {

                constructor(x, y, team, level = 1) {

                    const template = allCards['starSwarm'];

                    const stats = template.stats[level] || template.stats[1];

                    const count = stats.count || 4;

                    for (let i = 0; i < count; i++) {

                        const spark = new StarSpark(x + (Math.random() * 16 - 8), y + (Math.random() * 16 - 8), team, level);

                        try {

                            if (window.pendingEvoSpawn && window.currentSpawnCardHasEvo) {

                                spark.isEvolved = true;

                            }

                        } catch (e) {}

                        gameObjects.push(spark);

                    }

                }

            }

            class NovaPulseEffect extends GameObject {

                constructor(x, y, team, damage, pulses = 3, interval = 0.55, radius = 90) {

                    super(x, y, radius, team, 1);

                    this.damage = damage;

                    this.pulses = Math.max(1, pulses);

                    this.interval = Math.max(0.3, interval) * 60;

                    this.timer = this.interval;

                    this.count = 0;

                    this.maxRadius = radius;

                }

                update() {

                    if (this.count >= this.pulses) {

                        this.health = 0;

                        return;

                    }

                    this.timer -= deltaTime * 60;

                    if (this.timer <= 0) {

                        this.timer += this.interval;

                        this.count++;

                        const pulseRadius = this.maxRadius * (0.9 + (1 - this.count / this.pulses) * 0.1);

                        for (const obj of gameObjects) {

                            if (obj.team === this.team || obj.health <= 0) continue;

                            if (!(obj instanceof Unit) && !(obj instanceof Tower)) continue;

                            if (obj.isFlying) continue;

                            if (getDistance(this, obj) > pulseRadius) continue;

                            applyDamage(obj, this.damage, { sourceType: 'novaPulse' });

                        }

                    }

                }

                draw() {

                    ctx.save();

                    const pulseRadius = this.maxRadius * (0.9 + (1 - this.count / Math.max(1, this.pulses)) * 0.2);

                    const alpha = 0.35 + 0.35 * (1 - this.count / Math.max(1, this.pulses));

                    ctx.strokeStyle = `rgba(37, 99, 235, ${alpha})`;

                    ctx.lineWidth = 3;

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class EchoRift extends Building {

                constructor(x, y, team, level = 1) {

                    super(x, y, team, level, 'echoRift');

                    const stats = allCards['echoRift'].stats[level] || allCards['echoRift'].stats[1] || {};

                    this.pulseDamage = stats.pulseDamage || 24;

                    this.pulseRadius = stats.pulseRadius || 90;

                    this.slowPercent = Math.min(0.65, Math.max(0.1, stats.slowPercent || 0.35));

                    this.slowDuration = Math.max(0.6, stats.slowDuration || 1.2) * 60;

                    const interval = Math.max(0.4, parseFloat(stats.pulseInterval) || 1.2);

                    this.pulseInterval = interval * 60;

                    this.pulseTimer = this.pulseInterval;

                    this.slowedUnits = new Map();

                }

                update() {

                    if (this.health <= 0) return;

                    super.update();

                    if (this.health <= 0) return;

                    for (const [unit, timer] of [...this.slowedUnits.entries()]) {

                        const next = timer - deltaTime * 60;

                        if (next <= 0 || unit.health <= 0) {

                            this.restoreUnitSpeed(unit);

                            this.slowedUnits.delete(unit);

                            continue;

                        }

                        this.slowedUnits.set(unit, next);

                    }

                    this.pulseTimer -= deltaTime * 60;

                    if (this.pulseTimer <= 0) {

                        this.pulseTimer += this.pulseInterval;

                        for (const obj of gameObjects) {

                            if (obj.team === this.team || obj.health <= 0) continue;

                            if (!(obj instanceof Unit)) continue;

                            if (obj.isFlying) continue;

                            if (getDistance(this, obj) > this.pulseRadius) continue;

                            applyDamage(obj, this.pulseDamage, { sourceType: 'echoRift' });

                            this.applySlow(obj);

                        }

                    }

                }

                applySlow(unit) {

                    if (!unit || unit.health <= 0) return;

                    if (!this.slowedUnits.has(unit)) {

                        unit._echoRiftOriginalSpeed = unit.speed || 1;

                    }

                    const baseSpeed = unit._echoRiftOriginalSpeed || unit.speed || 1;

                    const slowed = Math.max(0.2, baseSpeed * (1 - this.slowPercent));

                    unit.speed = slowed;

                    this.slowedUnits.set(unit, Math.max(this.slowDuration, this.slowedUnits.get(unit) || 0));

                }

                restoreUnitSpeed(unit) {

                    if (!unit) return;

                    if (unit._echoRiftOriginalSpeed !== undefined) {

                        unit.speed = unit._echoRiftOriginalSpeed;

                        delete unit._echoRiftOriginalSpeed;

                    }

                }

                draw() {

                    super.draw();

                    ctx.save();

                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';

                    ctx.lineWidth = 2;

                    ctx.setLineDash([6, 4]);

                    ctx.beginPath();

                    ctx.arc(this.x, this.y, this.pulseRadius, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

            }

            class BigStickRoll extends GameObject {

                constructor(x, y, team, dirX = 0, dirY = -1, distance = 230, speed = 3.2, damage = 160, pushDistance = 32, hitRadius = 20) {

                    super(x, y, hitRadius, team, 1);

                    const magnitude = Math.hypot(dirX, dirY) || 1;

                    this.dirX = dirX / magnitude;

                    this.dirY = dirY / magnitude;

                    this.maxDistance = Math.max(0, distance);

                    this.speed = speed;

                    this.traveled = 0;

                    this.damage = damage;

                    this.pushDistance = pushDistance;

                    this.hitRadius = hitRadius;

                    this.hitTargets = new Set();

                }

                update() {

                    const deltaFrames = deltaTime * 60;

                    const movement = this.speed * deltaFrames;

                    this.x += this.dirX * movement;

                    this.y += this.dirY * movement;

                    this.traveled += movement;

                    if (this.traveled >= this.maxDistance) {

                        this.health = 0;

                        return;

                    }

                    for (const obj of gameObjects) {

                        if (this.hitTargets.has(obj)) continue;

                        if (obj.team === this.team || obj.health <= 0) continue;

                        if (!(obj instanceof Unit) && !(obj instanceof Tower) && !(obj instanceof Building)) continue;

                        if (obj.isFlying) continue;

                        if (getDistance(this, obj) > this.radius + (obj.radius || 10)) continue;

                        applyDamage(obj, this.damage, { sourceType: 'bigStick' });

                        this.hitTargets.add(obj);

                        if (obj.health > 0 && !(obj instanceof Tower) && !(obj instanceof Building)) {

                            obj.x += this.dirX * this.pushDistance;

                            obj.y += this.dirY * this.pushDistance;

                        }

                    }

                }

                draw() {

                    ctx.save();

                    const stickWidth = Math.max(this.radius * 1.7, 36);

                    const stickHeight = Math.max(this.radius * 0.6, 18);

                    const left = this.x - stickWidth / 2;

                    const top = this.y - stickHeight / 2;

                    const right = left + stickWidth;

                    const bottom = top + stickHeight;

                    const gradient = ctx.createLinearGradient(left, top, left + stickWidth, top);

                    gradient.addColorStop(0, '#6b2f0f');

                    gradient.addColorStop(0.25, '#8b5c12');

                    gradient.addColorStop(0.6, '#c9840f');

                    gradient.addColorStop(1, '#7c2d0c');

                    ctx.fillStyle = gradient;

                    ctx.strokeStyle = '#4f1f08';

                    ctx.lineWidth = 2;

                    ctx.lineJoin = 'round';

                    ctx.beginPath();

                    ctx.moveTo(left + stickHeight / 2, top);

                    ctx.lineTo(right - stickHeight / 2, top);

                    ctx.arcTo(right, top, right, top + stickHeight, stickHeight / 2);

                    ctx.lineTo(right, bottom - stickHeight / 2);

                    ctx.arcTo(right, bottom, right - stickHeight / 2, bottom, stickHeight / 2);

                    ctx.lineTo(left + stickHeight / 2, bottom);

                    ctx.arcTo(left, bottom, left, bottom - stickHeight / 2, stickHeight / 2);

                    ctx.lineTo(left, top + stickHeight / 2);

                    ctx.arcTo(left, top, left + stickHeight / 2, top, stickHeight / 2);

                    ctx.closePath();

                    ctx.fill();

                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(255,255,255,0.25)';

                    ctx.lineWidth = 1;

                    for (let i = 0; i < 4; i++) {

                        const offset = i * (stickWidth / 5);

                        ctx.beginPath();

                        const xStart = left + 8 + offset;

                        ctx.moveTo(xStart, top + (i % 2 === 0 ? 4 : 6));

                        ctx.quadraticCurveTo(xStart + 6, this.y, xStart + 12, top + stickHeight - (i % 2 === 0 ? 4 : 6));

                        ctx.stroke();

                    }

                    const knotX = left + stickWidth * 0.75;

                    const knotY = this.y;

                    const knotRadius = stickHeight * 0.4;

                    ctx.beginPath();

                    ctx.fillStyle = 'rgba(0,0,0,0.2)';

                    ctx.arc(knotX, knotY, knotRadius, 0, Math.PI * 2);

                    ctx.fill();

                    ctx.fillStyle = 'rgba(255,255,255,0.3)';

                    ctx.beginPath();

                    ctx.arc(knotX, knotY, knotRadius * 0.45, 0, Math.PI * 2);

                    ctx.stroke();

                    ctx.restore();

                }

                findTarget(forceFindTower = false) {

                    return findClosestEnemyBuilding(this);

                }

            }

            function findClosestEnemyBuilding(source) {

                let best = null;

                let bestDist = Infinity;

                for (const obj of gameObjects) {

                    if (!obj || obj.health <= 0) continue;

                    if (obj.team === source.team) continue;

                    if (!(obj instanceof Tower) && !(obj instanceof Building)) continue;

                    const dist = getDistance(source, obj);

                    if (dist < bestDist) {

                        bestDist = dist;

                        best = obj;

                    }

                }

                return best;

            }

            function findClosestEnemyTowerTarget(source) {

                const laneCenter = typeof source.preferredLaneX === 'number' ? source.preferredLaneX : null;

                const laneTolerance = laneCenter !== null && typeof source.laneSwitchRange === 'number' ? source.laneSwitchRange : 40;

                const tryFindTower = (filterLane) => {

                    let best = null;

                    let bestDist = Infinity;

                    for (const obj of gameObjects) {

                        if (!obj || obj.health <= 0) continue;

                        if (obj.team === source.team) continue;

                        if (!(obj instanceof Tower)) continue;

                        if (filterLane && laneCenter !== null && Math.abs(obj.x - laneCenter) > laneTolerance) continue;

                        const dist = getDistance(source, obj);

                        if (dist < bestDist) {

                            bestDist = dist;

                            best = obj;

                        }

                    }

                    return best;

                };

                let best = tryFindTower(true);

                if (best) return best;

                best = tryFindTower(false);

                if (best) return best;

                let bestBuilding = null;

                let bestBuildingDist = Infinity;

                for (const obj of gameObjects) {

                    if (!obj || obj.health <= 0) continue;

                    if (obj.team === source.team) continue;

                    if (!(obj instanceof Building)) continue;

                    const dist = getDistance(source, obj);

                    if (dist < bestBuildingDist) {

                        bestBuildingDist = dist;

                        bestBuilding = obj;

                    }

                }

                return bestBuilding;

            }

            // --- AI Teammate (for 2v2) ---

            let aiTeammateTimer = 0;

            let aiTeammateElixir = 0;

            let aiTeammateHandCards = [];

            let aiTeammateDeck = [];

            let aiTeammateDiscardPile = []; // Add discard pile for recycling

            let aiTeammateNextCard = null; // Add NEXT card for proper cycling

            function initAITeammate() {

                // Note: elixir is reset to 3 in initGame(), not here

                aiTeammateHandCards = [];

                aiTeammateDiscardPile = []; // Reset discard pile

                aiTeammateNextCard = null; // Reset NEXT card

                

                // Build an 8-card deck for AI teammate (any card in the game)

                aiTeammateDeck = [];

                // Use all cards in the game for maximum variety

                const allGameCards = Object.keys(allCards).filter(cardId => 

                    cardId !== 'tower' && cardId !== 'miniStoneGiant' // Exclude internal cards

                );

                let availableCards = [...allGameCards];

                

                for (let i = 0; i < 8; i++) {

                    if (availableCards.length === 0) availableCards = [...allGameCards]; // Refill if needed

                    let cardIndex = Math.floor(Math.random() * availableCards.length);

                    aiTeammateDeck.push(availableCards.splice(cardIndex, 1)[0]);

                }

                

                aiTeammateDeck = shuffleDeck(aiTeammateDeck);

                

                // Draw initial hand (4 cards from the 8-card deck)

                for (let i = 0; i < 4; i++) {

                    aiTeammateHandCards.push(aiTeammateDeck.pop());

                }

                

                // Set initial NEXT card from the remaining 4 cards in deck

                if (aiTeammateDeck.length > 0) {

                    aiTeammateNextCard = aiTeammateDeck.pop();

                }

                

                updateAITeammateUI();

            }

            function drawAITeammateCard() {

                // Draw new NEXT card from remaining deck

                if (aiTeammateDeck.length > 0) {

                    aiTeammateNextCard = aiTeammateDeck.pop();

                }

                

                updateAITeammateUI();

            }

            function updateAITeammateUI() {

                if (gameMode !== '2v2' || !is2v2AITeammate) {

                    aiTeammateUI.style.display = 'none';

                    return;

                }

                aiTeammateUI.style.display = 'flex';

                // Render hand (exact same style as player hand)

                aiTeammateHand.innerHTML = '';

                aiTeammateHandCards.forEach(cardId => {

                    const cardEl = createCardDOM(cardId, false, true); // Same as player hand

                    if (!cardEl) return;

                    cardEl.style.opacity = '0.8'; // Slightly transparent to distinguish from player

                    aiTeammateHand.appendChild(cardEl);

                });

                // Render next card (same style as player next)

                aiTeammateNext.innerHTML = '';

                if (aiTeammateNextCard) {

                    const cardEl = createCardDOM(aiTeammateNextCard, true, true); // Same as player next

                    if (cardEl) {

                        cardEl.style.opacity = '0.6'; // Slightly transparent to distinguish from player

                        aiTeammateNext.appendChild(cardEl);

                    }

                }

                // Update elixir bar and count

                const elixirPercent = (aiTeammateElixir / MAX_ELIXIR) * 100;

                aiTeammateElixirBar.style.width = `${elixirPercent}%`;

                aiTeammateElixirCount.textContent = `${Math.floor(aiTeammateElixir)}/${MAX_ELIXIR}`;

            }

            function runAI2() {

                if (ai2ThinkTimer > 0) { ai2ThinkTimer--; return; }

                ai2ThinkTimer = 120; // Think every 2 seconds

                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);

                if (playerUnits.length > 0) {

                    let bestCardId = null;

                    // --- NEW AI LOGIC ---

                    if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && ai2Hand.includes('fireDragon') && ai2Elixir >= allCards['fireDragon'].cost) {

                         bestCardId = 'fireDragon';

                    } else if (playerUnits.some(u => u.isFlying) && ai2Hand.includes('arrows') && ai2Elixir >= allCards['arrows'].cost) {

                         bestCardId = 'arrows';

                    } else if (playerUnits.some(u => !u.isFlying) && ai2Hand.includes('axeSwinger') && ai2Elixir >= allCards['axeSwinger'].cost) {

                         bestCardId = 'axeSwinger';

                    } else if (ai2Hand.includes('giant') && ai2Elixir >= allCards['giant'].cost) {

                         bestCardId = 'giant';

                    } else if (ai2Hand.includes('stoneGiant') && ai2Elixir >= allCards['stoneGiant'].cost) {

                         bestCardId = 'stoneGiant';

                    } else if (ai2Hand.includes('fireDragon') && ai2Elixir >= allCards['fireDragon'].cost) {

                         bestCardId = 'fireDragon';

                    } else if (ai2Hand.includes('archer') && ai2Elixir >= allCards['archer'].cost) {

                         bestCardId = 'archer';

                    } else if (ai2Hand.includes('mage') && ai2Elixir >= allCards['mage'].cost) {

                         bestCardId = 'mage';

                    } else if (ai2Hand.includes('skeletons') && ai2Elixir >= allCards['skeletons'].cost) {

                         bestCardId = 'skeletons';

                    } else if (ai2Hand.includes('goblinGang') && ai2Elixir >= allCards['goblinGang'].cost) {

                         bestCardId = 'goblinGang';

                    } else if (ai2Hand.includes('barbarians') && ai2Elixir >= allCards['barbarians'].cost) {

                         bestCardId = 'barbarians';

                    } else if (ai2Hand.includes('cannon') && ai2Elixir >= allCards['cannon'].cost) {

                         bestCardId = 'cannon';

                    } else if (ai2Hand.includes('poison') && ai2Elixir >= allCards['poison'].cost) {

                         bestCardId = 'poison';

                    } else if (ai2Hand.includes('rage') && ai2Elixir >= allCards['rage'].cost) {

                         bestCardId = 'rage';

                    } else if (ai2Hand.includes('heal') && ai2Elixir >= allCards['heal'].cost) {

                         bestCardId = 'heal';

                    } else if (ai2Hand.includes('fireball') && ai2Elixir >= allCards['fireball'].cost) {

                         bestCardId = 'fireball';

                    } else if (ai2Hand.includes('lightning') && ai2Elixir >= allCards['lightning'].cost) {

                         bestCardId = 'lightning';

                    }

                    // --- END NEW AI LOGIC ---

                    if (bestCardId && ai2Elixir >= allCards[bestCardId].cost) {

                        const card = allCards[bestCardId];

                        // Safety check: ensure card exists and unitClass exists for non-spells

                        if (!card) {

                            console.error('Card not found:', bestCardId);

                            return;

                        }

                        if (card.type !== 'Spell' && (!card.unitClass || typeof card.unitClass !== 'function')) {

                            console.error('Invalid unitClass for non-spell card:', bestCardId, card);

                            return;

                        }

                        let spawnX = LANE_LEFT_X + Math.random() * (LANE_RIGHT_X - LANE_LEFT_X);

                        let spawnY = 100 + Math.random() * 100;

                        if (checkPlacement(spawnX, spawnY, card.placementRadius, card.type)) {

                            const level = isMaxLevelMatch() ? 15 : currentAi2StatLevel;

                            

                            // Handle spells properly

                            if (card.type === 'Spell') {

                                if (bestCardId === 'poison') {

                                    const s = card.stats[level];

                                    gameObjects.push(new PoisonSpell(spawnX, spawnY, 'ai', s.damagePerSecond, card.radius, s.duration));

                                } else if (bestCardId === 'rage') {

                                    const s = card.stats[level];

                                    gameObjects.push(new AngerSpell(spawnX, spawnY, 'ai', card.radius, s.duration));

                                } else if (bestCardId === 'arrows' || bestCardId === 'fireball') {

                                    const s = card.stats[level];

                                    gameObjects.push(new Projectile(spawnX, spawnY, null, 'ai', s.damage, card.radius));

                                } else if (bestCardId === 'heal') {

                                    const s = card.stats[level];

                                    gameObjects.push(new HealSpell(spawnX, spawnY, 'ai', s.healAmount, card.radius));

                                } else if (bestCardId === 'lightning') {

                                    const s = card.stats[level];

                                    gameObjects.push(new LightningSpell(spawnX, spawnY, 'ai', s.damage, card.radius));

                                }

                    } else if (card.type === 'Building') {

                        const newBuilding = new card.unitClass(spawnX, spawnY, 'ai', level);

                        if (newBuilding instanceof GameObject) gameObjects.push(newBuilding);

                        maybeTriggerChaosTroopSpawn(card, 'ai');

                            } else {

                                // Determine if the AI should spawn an evolved unit for this card (ai2)

                                const ai2EvoSpawn = shouldSpawnAiEvolution(bestCardId, card, ai2EvoCycleCounts, ai2CanUseEvo, ai2EvoBudget);

                                if (ai2EvoSpawn) {

                                    try {

                                        window.pendingEvoSpawn = true;

                                        window.currentSpawnCardHasEvo = true;

                                    } catch(err) {}

                                }

                                const newUnit = new card.unitClass(spawnX, spawnY, 'ai', level);

                                if (newUnit instanceof GameObject) {

                                    // Grant Knight's shield for evolved Knight

                                    if (ai2EvoSpawn && bestCardId === 'knight') {

                                        newUnit.shieldTimer = 5;

                                    }

                                    gameObjects.push(newUnit);

                                    maybeTriggerChaosTroopSpawn(card, 'ai');

                                }

                                // Reset global evo flags after spawning

                                if (ai2EvoSpawn) {

                                    try {

                                        window.pendingEvoSpawn = false;

                                        window.currentSpawnCardHasEvo = false;

                                    } catch(err) {}

                                }

                            }

                            

                            // Proper card cycling like the first AI

                            const handIndex = ai2Hand.indexOf(bestCardId);

                            if (handIndex > -1) { 

                                ai2Hand.splice(handIndex, 1); 

                                ai2DiscardPile.push(bestCardId); // Add to discard pile

                            }

                            // Add NEXT card to hand (like player system)

                            if (ai2NextCard) {

                                ai2Hand.push(ai2NextCard);

                                ai2NextCard = null;

                            }

                            ai2Elixir -= card.cost;

                            // Draw new NEXT card and handle deck recycling

                            if (ai2Deck.length === 0 && ai2DiscardPile.length > 0) {

                                ai2Deck = shuffleDeck(ai2DiscardPile);

                                ai2DiscardPile = [];

                            }

                            if (ai2Deck.length > 0) {

                                ai2NextCard = ai2Deck.pop();

                            }

                        }

                    }

                }

            }

            function ai2PlayCard(cardId) {

                const index = ai2Hand.indexOf(cardId);

                if (index !== -1) {

                    ai2Hand.splice(index, 1);

                    ai2Elixir -= allCards[cardId].cost;

                    if (ai2Deck.length > 0) {

                        const newCard = ai2Deck.splice(Math.floor(Math.random() * ai2Deck.length), 1)[0];

                        ai2Hand.push(newCard);

                    }

                }

            }

            function runAITeammate() {

                if (gameMode !== '2v2' || !is2v2AITeammate) return;

                if (aiTeammateTimer > 0) { aiTeammateTimer -= deltaTime * 60; return; } /* Scale AI Teammate timer by delta time */

                aiTeammateTimer = 90; // Think every ~1.5s

                // Find an affordable card

                const affordableCards = aiTeammateHandCards.filter(cardId => {

                    const card = allCards[cardId];

                    return card && card.cost <= aiTeammateElixir;

                });

                if (affordableCards.length === 0) return;

                // Smart decision: choose best card based on board state

                let bestCardId = null;

                let bestScore = -Infinity;

                const aiUnits = gameObjects.filter(o => o.team === 'ai' && o instanceof Unit);

                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit);

                const aiTowers = gameObjects.filter(o => o.team === 'ai' && o instanceof Tower && o.health > 0);

                const playerTowers = gameObjects.filter(o => o.team === 'player' && o instanceof Tower && o.health > 0);

                for (const cardId of affordableCards) {

                    const card = allCards[cardId];

                    let score = 0;

                    // Defensive: if our towers are under attack

                    if (aiTowers.length > 0 && playerUnits.some(u => getDistance(u, aiTowers[0]) < 200)) {

                        if (card.type === 'Spell' && (cardId === 'arrows' || cardId === 'fireball' || cardId === 'poison')) {

                            score += 50;

                        } else if (card.type === 'Unit' && (cardId === 'skeletons' || cardId === 'goblinGang' || cardId === 'barbarians')) {

                            score += 30;

                        }

                    }

                    // Offensive: if enemy has units

                    if (playerUnits.length > 0) {

                        if (card.type === 'Unit') {

                            if (cardId === 'giant' || cardId === 'stoneGiant') score += 40;

                            else if (cardId === 'fireDragon' && playerUnits.some(u => u.isFlying)) score += 45;

                            else if (cardId === 'archer' && playerUnits.some(u => u.isFlying)) score += 35;

                            else if (cardId === 'axeSwinger' && playerUnits.some(u => !u.isFlying)) score += 35;

                            else score += 20;

                        } else if (card.type === 'Spell') {

                            if (playerUnits.length >= 3 && (cardId === 'poison' || cardId === 'fireball')) score += 40;

                            else if (playerUnits.some(u => u.isFlying) && cardId === 'arrows') score += 35;

                        } else if (card.type === 'Building') {

                            if (cardId === 'cannon') score += 25;

                        }

                    }

                    // Support: if we have units pushing

                    if (aiUnits.length > 2) {

                        if (cardId === 'rage') score += 30;

                        if (cardId === 'heal') score += 20;

                    }

                    // Randomness

                    score += Math.random() * 10;

                    if (score > bestScore) {

                        bestScore = score;

                        bestCardId = cardId;

                    }

                }

                if (!bestCardId) return;

                const card = allCards[bestCardId];

                const handIndex = aiTeammateHandCards.indexOf(bestCardId);

                // Choose placement

                let targetX, targetY;

                if (card.type === 'Spell') {

                    // Target enemy units or towers

                    const target = playerUnits.length > 0 ? playerUnits[0] : playerTowers[0];

                    if (target) {

                        targetX = target.x;

                        targetY = target.y;

                    } else {

                        return;

                    }

                } else if (card.type === 'Building') {

                    // Place near our king tower

                    targetX = WIDTH / 2 + (Math.random() - 0.5) * 100;

                    targetY = 50 + Math.random() * 50;

                } else {

                    // Units: spawn near river, prefer lanes with enemy units

                    const lane = playerUnits.length > 0 ? (playerUnits[0].x < WIDTH / 2 ? LANE_LEFT_X : LANE_RIGHT_X) : (Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X);

                    targetX = lane + (Math.random() - 0.5) * 40;

                    targetY = RIVER_Y + 20 + Math.random() * 80;

                }

                if (card.type === 'Spell' || checkPlacement(targetX, targetY, card.placementRadius || 20, card.type)) {

                    const level = 15;

                    if (card.type === 'Spell') {

                        // Handle spells

                        if (bestCardId === 'poison') {

                            const s = card.stats[level];

                            gameObjects.push(new PoisonSpell(targetX, targetY, 'player', s.damagePerSecond, card.radius, s.duration));

                        } else if (bestCardId === 'rage') {

                            const s = card.stats[level];

                            gameObjects.push(new AngerSpell(targetX, targetY, 'player', card.radius, s.duration));

                        } else if (bestCardId === 'arrows' || bestCardId === 'fireball') {

                            const s = card.stats[level];

                            gameObjects.push(new Projectile(targetX, targetY, null, 'player', s.damage, card.radius));

                        }

                    } else if (card.type === 'Building') {

                        const newBuilding = new card.unitClass(targetX, targetY, 'player', level);

                        if (newBuilding instanceof GameObject) gameObjects.push(newBuilding);

                    } else {

                        const newUnit = new card.unitClass(targetX, targetY, 'player', level);

                        if (newUnit instanceof GameObject) gameObjects.push(newUnit);

                    }

                    showTeammatePlacement(targetX, targetY, card.emoji);

                    aiTeammateHandCards.splice(handIndex, 1);

                    aiTeammateDiscardPile.push(bestCardId); // Add played card to discard pile

                    // Add NEXT card to hand (like player system)

                    if (aiTeammateNextCard) {

                        aiTeammateHandCards.push(aiTeammateNextCard);

                        aiTeammateNextCard = null;

                    }

                    // Draw new NEXT card from remaining deck

                    if (aiTeammateDeck.length > 0) {

                        aiTeammateNextCard = aiTeammateDeck.pop();

                    } else if (aiTeammateDiscardPile.length > 0) {

                        // Recycle discard pile when deck is empty

                        aiTeammateDeck = shuffleDeck(aiTeammateDiscardPile);

                        aiTeammateDiscardPile = [];

                        if (aiTeammateDeck.length > 0) {

                            aiTeammateNextCard = aiTeammateDeck.pop();

                        }

                    }

                    aiTeammateElixir -= card.cost; // Subtract elixir FIRST

                    updateAITeammateUI(); // Then update UI to show correct elixir

                }

            }

            function showTeammatePlacement(x, y, emoji) {

                const indicator = document.createElement('div');

                indicator.className = 'absolute text-2xl pointer-events-none';

                indicator.style.left = `${x - 12}px`;

                indicator.style.top = `${y - 12}px`;

                indicator.textContent = emoji;

                indicator.style.transition = 'opacity 0.5s';

                gameContainer.appendChild(indicator);

                setTimeout(() => {

                    indicator.style.opacity = '0';

                    setTimeout(() => indicator.remove(), 500);

                }, 100);

            }

            function evaluateAiHeroAbilities() {

                for (const obj of gameObjects) {

                    if (obj instanceof SuperheroUnit && obj.team === 'ai' && obj.canUseHeroAbility()) {

                        obj.triggerHeroAbility();

                    }

                }

            }

            function updateTimerAndElixir() {

                const totalSeconds = Math.max(0, Math.floor(gameTimer / 60));

                const minutes = Math.floor(totalSeconds / 60);

                const seconds = totalSeconds % 60;

                if (timerDisplay) timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (isOvertime) {

                    if (timerDisplay) timerDisplay.classList.add('timer-display--overtime');

                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 3 : BASE_ELIXIR_REGEN_RATE * 2;

                } else {

                    if (timerDisplay) timerDisplay.classList.remove('timer-display--overtime');

                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 2 : BASE_ELIXIR_REGEN_RATE;

                }

                if (playerElixir < MAX_ELIXIR) {

                    playerElixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */

                    playerElixir = Math.min(playerElixir, MAX_ELIXIR);

                }

                if (aiElixir < MAX_ELIXIR) {

                    aiElixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */

                    aiElixir = Math.min(aiElixir, MAX_ELIXIR);

                }

                // Second AI elixir (2v2 only)

                if (gameMode === '2v2' && ai2Elixir < MAX_ELIXIR) {

                    ai2Elixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */

                    ai2Elixir = Math.min(ai2Elixir, MAX_ELIXIR);

                }

                // AI teammate elixir (2v2 only)

                if (gameMode === '2v2' && is2v2AITeammate && aiTeammateElixir < MAX_ELIXIR) {

                    aiTeammateElixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */

                    aiTeammateElixir = Math.min(aiTeammateElixir, MAX_ELIXIR);

                    updateAITeammateUI(); // Update UI continuously when elixir is gained

                }

                evaluateAiHeroAbilities();

            }

            function rewardOpponentElixir(ownerTeam, amount) {

                if (amount <= 0) return;

                if (ownerTeam === 'player') {

                    aiElixir = Math.min(MAX_ELIXIR, aiElixir + amount);

                } else if (ownerTeam === 'ai') {

                    playerElixir = Math.min(MAX_ELIXIR, playerElixir + amount);

                }

            }

            

            // NEW: Update function to check tower status

            function checkTowerStatus() {

                const aiLeft = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x < WIDTH / 2);

                const aiRight = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x > WIDTH / 2);

                

                if (aiLeft && aiLeft.health <= 0 && !aiLeftTowerDestroyed) {

                    aiLeftTowerDestroyed = true;

                    if (selectedSpawningUnit) updatePlacementOverlay();

                }

                if (aiRight && aiRight.health <= 0 && !aiRightTowerDestroyed) {

                    aiRightTowerDestroyed = true;

                    if (selectedSpawningUnit) updatePlacementOverlay();

                }

                

                // Can check player towers here too if AI gets spawn zones

            }

            

            // NEW: Update the clip-path of the red overlay

            function updatePlacementOverlay() {

                const hasTroopSpellPlacement = selectedSpawningUnit && selectedSpawningUnit.isTroopSpell;

                if (!selectedSpawningUnit || (isSpawningSpell && !hasTroopSpellPlacement) || (selectedSpawningUnit.type === 'Spell' && !hasTroopSpellPlacement)) {

                    placementOverlay.style.display = 'none';

                    placementOverlay.style.clipPath = 'none';

                    return;

                }

                // Use M (move) and L (line) path commands

                // `M x y L x y L x y Z` creates a closed shape

                let pathData = "";

                const H = HEIGHT; // 500

                const W = WIDTH; // 400

                const R = RIVER_Y; // 250

                const F = AI_SPAWN_ZONE_LIMIT; // 150 (500 * 0.3)

                const M = W / 2; // 200 (mid-line)

                // Define parts of the player's side that are blocked (red overlay)

                let pathParts = [];

                

                // Always block the very far enemy zone (Y=0 to AI_SPAWN_ZONE_LIMIT)

                pathParts.push(`M0 0 L${W} 0 L${W} ${F} L0 ${F} Z`);

                // Conditionally block the middle zone (AI_SPAWN_ZONE_LIMIT to RIVER_Y) for each lane

                if (!aiLeftTowerDestroyed) {

                    pathParts.push(`M0 ${F} L${M} ${F} L${M} ${R} L0 ${R} Z`);

                }

                if (!aiRightTowerDestroyed) {

                    pathParts.push(`M${M} ${F} L${W} ${F} L${W} ${R} L${M} ${R} Z`);

                }

                // If no enemy princess towers are destroyed, block the full top half up to RIVER_Y.

                // This condition must be last to ensure it overwrites previous pushes if applicable.

                if (!aiLeftTowerDestroyed && !aiRightTowerDestroyed) {

                    pathParts = [`M0 0 L${W} 0 L${W} ${R} L0 ${R} Z`]; // Block entire enemy territory

                } else if (gameMode === 'snowman_challenge') {

                    // Special case for snowman challenge - always block up to river for player

                    pathParts = [`M0 0 L${W} 0 L${W} ${R} L0 ${R} Z`];

                }

                placementOverlay.style.clipPath = `path("${pathParts.join(" ")}")`;

            }

            function checkGameOver() {

                const playerKing = gameObjects.find(t => t.team === 'player' && t.isKing);

                const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);

                if (gameRunning && aiKing && aiKing.health <= 0) { showWinScreen(); }

                else if (gameRunning && playerKing && playerKing.health <= 0) { showLoseScreen(); }

            }

            

            function checkOvertime() { // RENAMED

                if (!gameRunning) return;

                const getTowerCount = (team) => { return gameObjects.filter(obj => obj.team === team && (obj instanceof Tower) && obj.health > 0).length; };

                const playerTowers = getTowerCount('player');

                const aiTowers = getTowerCount('ai');

                if (playerTowers === aiTowers) {

                    isOvertime = true;

                    overtimeInitialPlayerTowers = playerTowers; // NEW: Store initial counts

                    overtimeInitialAiTowers = aiTowers; // NEW: Store initial counts

                    gameTimer = OVERTIME_TIME;

                    currentElixirRate = BASE_ELIXIR_REGEN_RATE * 2;

                } else if (playerTowers > aiTowers) {

                    showWinScreen();

                } else {

                    showLoseScreen();

                }

            }

            function startTieBreaker() {

                if (!gameRunning) return;

                gameRunning = true; isTieBreaker = true; gameObjects = gameObjects.filter(obj => (obj instanceof Tower));

                messageText.textContent = 'TIEBREAKER!';

                messageOverlay.style.display = 'flex';

                startButton.style.display = 'none';

                menuButton.style.display = 'none'; // FIX: Hide menu button

                setTimeout(() => { if (isTieBreaker) messageOverlay.style.display = 'none'; }, 2000);

            }

            function tieBreakerLoop() {

                    tieBreakerTick -= deltaTime * 60; /* Scale tiebreaker tick by delta time */

                    if (tieBreakerTick <= 0) {

                    tieBreakerTick = 10;

                    let playerKing = null;

                    let aiKing = null;

                    for (const obj of gameObjects) {

                        if (obj instanceof Tower) { obj.health -= 20; }

                        if (obj.isKing && obj.team === 'player') playerKing = obj;

                        if (obj.isKing && obj.team === 'ai') aiKing = obj;

                    }

                    if (aiKing && aiKing.health <= 0 && playerKing && playerKing.health > 0) {

                        isTieBreaker = false;

                        showWinScreen();

                    } else if (playerKing && playerKing.health <= 0) {

                        isTieBreaker = false;

                        showLoseScreen();

                    }

                }

                ctx.clearRect(0, 0, WIDTH, HEIGHT); drawArena(); gameObjects.forEach(obj => obj.draw());

                if (isTieBreaker) {

                    gameLoopId = requestAnimationFrame(gameLoop);

                }

            }

            async function showWinScreen() {

                if (!gameRunning) return;

                gameRunning = false;

                isOvertime = false;

                isTieBreaker = false;

                cancelAnimationFrame(gameLoopId);

                startBgAnimation(); // Restart background animation when game ends

                

                // Trophies only for Trophy Road (ranked matches)

                if (isRankedMode()) {

                    trophies += 30;

                    updateArena();

                    trophyDisplay.textContent = `ðŸ† ${trophies}`;

                }

                

                if (gameMode === 'snowman_challenge') {

                     gold += 50; // Bonus for Challenge

                     messageText.textContent = 'Challenge Complete! (+100 ðŸ’° & Box ðŸ“¦)';

                }

                

                // Show Play Again button for multiplayer

                if (is2v2Friend && !is2v2AITeammate) {

                    startButton.textContent = 'Play Again';

                    startButton.style.display = 'inline-block';

                    startButton.onclick = () => requestRematch();

                    waitingForRematch = true;

                    if (conn && conn.open) {

                        conn.send({ type: 'playerReadyForRematch' });

                    }

                }

                gold += 50;

                goldDisplay.textContent = `ðŸ’° ${gold}`;

                // Always place chest in first available slot

                normalizeChestSlots();

                const emptySlotIndex = trophyChests.findIndex((chest, index) => index < 4 && !chest);

                if (emptySlotIndex !== -1) {

                    trophyChests[emptySlotIndex] = { id: 'wood', openTime: Date.now(), clicks: 0, stars: 1 };

                    renderChests();

                }

                let msg = 'You Win!';

                if (isRankedMode()) msg += ' (+30 ðŸ†, +50 ðŸ’°, ðŸ“¦)';

                else msg += ' (+50 ðŸ’°, ðŸ“¦)';

                

                messageText.textContent = msg;

                if (messageRewardText) messageRewardText.textContent = '';

                messageOverlay.style.display = 'flex';

                startButton.style.display = 'none';

                menuButton.style.display = 'inline-block';

                

                // Give gold/chest in all modes (except trophies in non-trophy modes)

                // Note: showWinScreen runs trophies+=30 only for trophy mode above, but duplication here must be fixed

                // The original code had a bug where it added trophies twice in non-2v2. I will fix.

                if (gameMode !== '2v2') {

                    // Removed duplicate trophies logic

                    // Just gold and chests for now

                }

                // Give rewards for ALL modes

                gold += 50;

                if (emptySlotIndex === -1) {

                    normalizeChestSlots();

                    const newEmptySlotIndex = trophyChests.findIndex((chest, index) => index < 4 && !chest);

                    if (newEmptySlotIndex !== -1) {

                        trophyChests[newEmptySlotIndex] = { id: 'wood', openTime: Date.now() + Math.random() * 1000, clicks: 0, stars: 1 };

                        renderChests();

                    }

                }

                await saveUserData();

            }

            async function showLoseScreen(message = 'You Lose!') {

                if (!gameRunning) return;

                gameRunning = false;

                isOvertime = false; // NEW: Stop overtime check

                isTieBreaker = false;

                cancelAnimationFrame(gameLoopId);

                startBgAnimation(); // Restart background animation when game ends

                

                // Show Play Again button for multiplayer

                if (is2v2Friend && !is2v2AITeammate) {

                    startButton.textContent = 'Play Again';

                    startButton.style.display = 'inline-block';

                    startButton.onclick = () => requestRematch();

                    waitingForRematch = true;

                    if (conn && conn.open) {

                        conn.send({ type: 'playerReadyForRematch' });

                    }

                }

                // Calculate minimum trophy floor for current arena

                let minTrophyFloor = 0;

                let lossAmount = 0;

                if (isRankedMode()) {

                    for (const floor in arenaFloors) {

                        if (trophies >= parseInt(floor)) {

                            minTrophyFloor = parseInt(floor);

                        }

                    }

                    lossAmount = 30;

                    if (trophies - lossAmount < minTrophyFloor) {

                        lossAmount = trophies - minTrophyFloor;

                    }

                    if (lossAmount < 0) lossAmount = 0;

                    trophies = Math.max(minTrophyFloor, trophies - lossAmount);

                    updateArena();

                    trophyDisplay.textContent = `ðŸ† ${trophies}`;

                }

                

                if (isRankedMode()) {

                     messageText.textContent = `${message} (-${lossAmount} ðŸ†)`;

                } else {

                     messageText.textContent = message;

                }

                if (messageRewardText) messageRewardText.textContent = '';

                messageOverlay.style.display = 'flex';

                startButton.style.display = 'none';

                menuButton.style.display = 'inline-block';

                await saveUserData();

            }

            function gameLoop(timestamp) {

                if (isTieBreaker) {

                    tieBreakerLoop();

                    return;

                }

                if (!gameRunning) {

                    cancelAnimationFrame(gameLoopId);

                    return;

                }

                deltaTime = (timestamp - lastTime) / 1000; /* Set global deltaTime */

                if (deltaTime > 0.1) deltaTime = 0.016; // Clamp to prevent huge jumps

                lastTime = timestamp;

                gameTimer -= deltaTime * 60; /* Scale game timer by delta time */

                updateTimerAndElixir();

                aiThinkTimer -= deltaTime * 60; /* Scale AI think timer by delta time */

                if (aiThinkTimer <= 0) {

                    runAI();

                    aiThinkTimer = 30 + Math.random() * 30; // Think every 0.5-1s

                }

                // Second AI (2v2 only)

                if (gameMode === '2v2') {

                    ai2ThinkTimer -= deltaTime * 60; /* Scale AI2 think timer by delta time */

                    if (ai2ThinkTimer <= 0) {

                        runAI2();

                        ai2ThinkTimer = 30 + Math.random() * 30;

                    }

                }

                // AI teammate (2v2 only)

                if (gameMode === '2v2' && is2v2AITeammate) {

                    runAITeammate();

                }

                

                // Update objects

                gameObjects.forEach(obj => obj.update());

                

                // NEW: Sudden Death Overtime Check

                if (gameRunning && isOvertime) {

                    const playerTowers = gameObjects.filter(obj => obj.team === 'player' && (obj instanceof Tower) && obj.health > 0).length;

                    const aiTowers = gameObjects.filter(obj => obj.team === 'ai' && (obj instanceof Tower) && obj.health > 0).length;

                    if (playerTowers < overtimeInitialPlayerTowers) {

                        // Player lost a tower

                        showLoseScreen("Sudden Death!");

                    } else if (aiTowers < overtimeInitialAiTowers) {

                        // AI lost a tower

                        showWinScreen(); // showWinScreen already handles stopping the game

                    }

                }

                

                // Check tower status for spawn zones

                checkTowerStatus();

                

                // Filter dead objects (and handle special death behavior)

                const newGameObjects = [];

                for (const obj of gameObjects) {

                    if (obj.health > 0) {

                        newGameObjects.push(obj);

                        continue;

                    }

                    if (obj instanceof Unit && obj.isControlledHero) {

                    }

                    // Handle units/projectiles/spells

                    if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell || obj instanceof PoisonSpell || obj instanceof AngerSpell || obj instanceof FreezeEffect || obj instanceof HealEffect || obj instanceof ExplosionEffect || obj instanceof VoidTrapEffect || obj instanceof ChaosOrbEffect || obj instanceof ParticleExplosion || obj instanceof DeathEffect || obj instanceof GiantBomb) {

                        // Spawn Death Effect for Units

                        if (obj instanceof Unit) {

                             gameObjects.push(new DeathEffect(obj.x, obj.y, obj.emoji));

                        }

                        // Special case: Battle Ram needs to spawn barbs

                        if (obj instanceof BattleRam && !obj.didHit) {

                            obj.spawnBarbs();

                        }

                        // Special case: Stone Giant splits into minis on death

                        if (obj instanceof StoneGiant && !obj.didSpawnMinis) {

                            console.log('Cleanup: StoneGiant died at', obj.x, obj.y, 'spawning minis');

                            obj.spawnMinis();

                        }

                        // Special case: Elixir Giant chain splits and rewards opponent elixir

                        if (obj instanceof ElixirGiant) {

                            rewardOpponentElixir(obj.team, 1);

                            obj.spawnMinis(newGameObjects);

                            continue;

                        }

                        if (obj instanceof ElixirGiantMini) {

                            rewardOpponentElixir(obj.team, 0.5);

                            obj.spawnShards(newGameObjects);

                            continue;

                        }

                        if (obj instanceof ElixirGiantShard) {

                            rewardOpponentElixir(obj.team, 0.25);

                            continue;

                        }

                        // Special case: Huge Skeleton drops bomb

                        if (obj instanceof HugeSkeleton && !obj.droppedBomb) {

                            obj.droppedBomb = true;

                            // Push to newGameObjects to ensure the bomb is added to the game after the Huge Skeleton dies

                            newGameObjects.push(new GiantBomb(obj.x, obj.y, obj.team, obj.bombDamage, 100));

                        }

                        if (obj instanceof Zombie && !obj._poisonSpawned) {

                            obj._poisonSpawned = true;

                            spawnPoisonCloud(obj.x, obj.y, obj.team, 3);

                        }

                        if (obj instanceof Rotter && !obj.didSpawnWorms) {

                            obj.didSpawnWorms = true;

                            for (let i = 0; i < 7; i++) {

                                const offsetX = Math.random() * 20 - 10;

                                const offsetY = Math.random() * 10 - 5;

                                gameObjects.push(new Worm(obj.x + offsetX, obj.y + offsetY, obj.team, obj.level));

                            }

                        }

                        if (obj._zombieMark) {

                            spawnMarkedZombie(obj);

                        }

                        continue; // Dead units/effects are not kept

                    }

                    // Handle towers/buildings

                    if (obj instanceof Tower || obj instanceof Building) {

                        if (obj.isKing) {

                            checkGameOver();

                            newGameObjects.push(obj);

                            continue;

                        }

                        if (obj.dyingAnimationTimer === 0) { obj.dyingAnimationTimer = 30; }

                        obj.dyingAnimationTimer--;

                        if (obj.dyingAnimationTimer > 0) {

                            newGameObjects.push(obj);

                        }

                        if (obj instanceof Lab && !obj.didSpawnZombiesOnDeath) {

                            obj.didSpawnZombiesOnDeath = true;

                            for (let i = 0; i < 3; i++) {

                                const dx = Math.random() * 18 - 9;

                                const dy = Math.random() * 18 - 9;

                                gameObjects.push(new Zombie(obj.x + dx, obj.y + dy, obj.team, obj.level));

                            }

                        }

                        continue;

                    }

                    // Everything else dead is dropped

                }

                gameObjects = newGameObjects;

                if (playerHeroUnit && !gameObjects.includes(playerHeroUnit)) {

                    playerHeroUnit = null;

                }

                updateHeroAbilityPanel();

                updateCardUI();

                if (gameTimer <= 0) {

                    if (isOvertime) { startTieBreaker(); }

                    else { checkOvertime(); }

                }

                ctx.clearRect(0, 0, WIDTH, HEIGHT);

                drawArena();

                gameObjects.forEach(obj => obj.draw());

                if (gameRunning) {

                    gameLoopId = requestAnimationFrame(gameLoop);

                }

            }

            function demoGameLoop(timestamp) {

                if (!isDemoMode) {

                    cancelAnimationFrame(gameLoopId);

                    return;

                }

                

                deltaTime = (timestamp - lastTime) / 1000; /* Set global deltaTime */

                lastTime = timestamp;

                const demoFadeOverlay = document.getElementById('demoFadeOverlay');

                // Handle Fading

                if (demoFadingOut) {

                    demoFadeTimer -= deltaTime * 60; /* Scale fade timer by delta time */

                    let fadeProgress = 1 - (demoFadeTimer / DEMO_FADE_TIME);

                    if (demoFadeOverlay) demoFadeOverlay.style.opacity = fadeProgress;

                    if (demoFadeTimer <= 0) {

                        // Reset

                        initGame(); // Reset the board and decks

                        demoLoopTimer = DEMO_LOOP_TIME;

                        demoFadingOut = false;

                        demoFadeTimer = DEMO_FADE_TIME; // Start fade-in

                    }

                } else if (demoFadeTimer > 0) {

                    // Fading IN

                    demoFadeTimer -= deltaTime * 60; /* Scale fade timer by delta time */

                    let fadeProgress = demoFadeTimer / DEMO_FADE_TIME;

                    if (demoFadeOverlay) demoFadeOverlay.style.opacity = fadeProgress;

                } else {

                    // Not fading, run game

                    demoLoopTimer -= deltaTime * 60; /* Scale demo loop timer by delta time */

                    if (demoLoopTimer <= 0) {

                        demoFadingOut = true;

                        demoFadeTimer = DEMO_FADE_TIME;

                    }

                    // Use existing gameTimer to run elixir etc.

                    gameTimer -= deltaTime * 60; /* Scale game timer by delta time */

                    updateTimerAndElixir();

                    aiThinkTimer -= deltaTime * 60; /* Scale AI think timer by delta time */

                    

                    if (aiThinkTimer <= 0) {

                        runAI(); // Existing AI

                        demoRunPlayerAI(); // New Player AI

                        aiThinkTimer = 30 + Math.random() * 30; // Think fast

                    }

                    

                    // Update objects

                    gameObjects.forEach(obj => obj.update());

                    

                    // Filter dead objects (simplified, no win/lose)

                    gameObjects = gameObjects.filter(obj => {

                        if (obj.health > 0) return true;

                        if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell || obj instanceof PoisonSpell || obj instanceof VoidTrapEffect || obj instanceof ChaosOrbEffect) { 

                            if (obj instanceof BattleRam && !obj.didHit) obj.spawnBarbs();

                            return false; 

                        }

                        if (obj instanceof Tower || obj instanceof Building) {

                            if (obj.isKing) { obj.health = obj.maxHealth; return true; } // Make kings invincible

                            if (obj.dyingAnimationTimer === 0) obj.dyingAnimationTimer = 30;

                            obj.dyingAnimationTimer--;

                            return obj.dyingAnimationTimer > 0;

                        }

                        return false;

                    });

                }

                

                ctx.clearRect(0, 0, WIDTH, HEIGHT);

                drawArena();

                gameObjects.forEach(obj => obj.draw());

                gameLoopId = requestAnimationFrame(demoGameLoop);

            }

            // ==============================================

            // INITIALIZATION

            // ==============================================

            

            // This MUST be called after all classes are defined

            initCardSystem();

            // --- BUG FIX: Start demo mode *after* classes and cards are defined ---

            const FORCE_HIDE_SITE_MOVE_NOTICE = true;

            initializeSiteMoveOverlay();

                        if (isDemoMode) {

                            initGame();

                            lastTime = performance.now(); // ADDED: Need this for gameLoop

                            gameLoopId = requestAnimationFrame(demoGameLoop);

                        }

            // --- END BUG FIX ---

            // ==============================================

            // EVENT LISTENERS

            // ==============================================

            

            // --- REFERENCEERROR FIX: All function definitions removed from here ---

            

            // --- Event Listeners ---

            

            function getCanvasClickPos(e) {

                const rect = canvas.getBoundingClientRect();

                let clientX, clientY;

                if (e.touches && e.touches.length > 0) { 

                    clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; 

                } else if (e.changedTouches && e.changedTouches.length > 0) { 

                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; 

                } else { 

                    clientX = e.clientX; clientY = e.clientY; 

                }

                const x = clientX - rect.left;

                const y = clientY - rect.top;

                return { x, y };

            }

            function checkPlacement(x, y, radius, cardType) {

                // Check if in allowed zone

                let inAllowedZone = false;

                

                if (gameMode === 'snowman_challenge') {

                    // Strict restriction: Player side only

                    if (y > RIVER_Y) inAllowedZone = true;

                } else {

                    if (y > RIVER_Y) {

                        inAllowedZone = true; // Always allowed in player's base

                    } else if (y > AI_SPAWN_ZONE_LIMIT) { // Can't place in "far end"

                        // Check enemy territory

                        if (aiLeftTowerDestroyed && x < WIDTH / 2) inAllowedZone = true;

                        if (aiRightTowerDestroyed && x > WIDTH / 2) inAllowedZone = true;

                    }

                }

                

                if (!inAllowedZone) return false;

                // Prevent barricades from covering the bridges

                if (selectedSpawningUnit && selectedSpawningUnit.id === 'barricade') {

                    const laneCenter = (x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;

                    const nearBridge = Math.abs(y - BRIDGE_Y) < 80 && Math.abs(x - laneCenter) < 90;

                    if (nearBridge) return false;

                }

                // Check for collision

                for (const obj of gameObjects) {

                    // NEW: Allow placing on troops, not buildings

                    if (obj instanceof Tower || obj instanceof Building) {

                        const dist = getDistance({x: x, y: y}, obj);

                        if (dist < radius + obj.radius) { return false; }

                    }

                }

                

                return true;

            }

            function handleDragMove(e) {

                if (!selectedSpawningUnit) return;

                e.preventDefault();

                let pos = (e.touches && e.touches[0]) ? e.touches[0] : e;

                

                // NEW: Drag sensitivity logic

                if (!isDragging) {

                    const dx = Math.abs(pos.clientX - dragStartX);

                    const dy = Math.abs(pos.clientY - dragStartY);

                    if (dx > DRAG_SENSITIVITY || dy > DRAG_SENSITIVITY) {

                        isDragging = true;

                    }

                }

                

                // NEW: Only move indicator if mouse is over canvas

                const rect = canvas.getBoundingClientRect();

                const isOverCanvas = (pos.clientX >= rect.left && pos.clientX <= rect.right &&

                                         pos.clientY >= rect.top && pos.clientY <= rect.bottom);

                

                if (isOverCanvas) {

                    placementIndicator.style.display = 'block';

                    movePlacementIndicator(pos);

                } else {

                    placementIndicator.style.display = 'none'; // Hide if off-canvas

                }

            }

            function movePlacementIndicator(e) {

                if (!selectedSpawningUnit) return;

                

                const { x, y } = getCanvasClickPos(e);

                const clampedX = Math.max(0, Math.min(WIDTH, x));

                const clampedY = Math.max(0, Math.min(HEIGHT, y));

                let radius = isSpawningSpell ? spellRadius : placementRadius;

                

                placementIndicator.style.left = `${clampedX}px`;

                placementIndicator.style.top = `${clampedY}px`;

                

                const worldX = clampedX;

                if (isSpawningSpell) {

                    canPlace = true; // Spells can be placed anywhere

                    placementIndicator.classList.remove('cant-place');

                    if (selectedSpawningUnit.id === 'diddyMiner') {

                        // Diddy miner has no placement restriction beyond spells

                    }

                } else {

                    canPlace = checkPlacement(worldX, clampedY, placementRadius, selectedSpawningUnit.type);

                    placementIndicator.classList.toggle('cant-place', !canPlace);

                }

            }

            

            // Re-bind mouse/touch move to window to allow dragging off canvas

            window.addEventListener('mousemove', handleDragMove);

            window.addEventListener('touchmove', handleDragMove, { passive: false });

            function handleDragEnd(e) {

                if (!selectedSpawningUnit || !gameRunning) {

                    cancelPlacement();

                    return;

                }

                // Check if mouse is over canvas

                const rect = canvas.getBoundingClientRect();

                let clientX, clientY;

                if (e.changedTouches && e.changedTouches.length > 0) {

                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY;

                } else {

                    clientX = e.clientX; clientY = e.clientY;

                }

                const isOverCanvas = (clientX >= rect.left && clientX <= rect.right &&

                                         clientY >= rect.top && clientY <= rect.bottom);

                

                // --- CLICK-TO-PLACE FIX ---

                if (!isDragging) {

                    // This was a "click"

                    if (isOverCanvas) {

                        // This is a "click-to-place"

                        // canPlace is already set by the last handleDragMove

                    } else {

                        // This was a click off-canvas, or just releasing the mouse from the card

                        // Check if the click-up was on a card

                        if (e.target && e.target.closest('.card-ui')) {

                            // This was the initial click-up on the card. Do nothing.

                            return; 

                        }

                        // Otherwise, it was a click off-canvas to cancel.

                        cancelPlacement();

                        return;

                    }

                } else {

                    // This was a "drag-and-drop"

                    if (!isOverCanvas) {

                        // Dragged off-canvas to cancel

                        cancelPlacement();

                        return;

                    }

                    // canPlace is already set

                }

                // --- END FIX ---

                

                if (!canPlace) {

                    console.log("Cannot spawn there!");

                    cancelPlacement();

                    return;

                }

                

                const { x, y } = getCanvasClickPos(e);

                const clampedX = Math.max(0, Math.min(WIDTH, x));

                const clampedY = Math.max(0, Math.min(HEIGHT, y));

                

                const card = allCards[selectedSpawningUnit.id];

                const useMaxLevel = isMaxLevelMatch();

                const level = useMaxLevel ? 15 : (cardCollection[selectedSpawningUnit.id] ? cardCollection[selectedSpawningUnit.id].level : 1);

                

                // Determine if this spawn should be evolved based on deck slot, unlock status, and cycle progress.

                let evoSpawnThisUnit = false;

                const cardId = selectedSpawningUnit.id;

                const cardDef = allCards[cardId];

                if (

                    cardDef &&

                    cardDef.evo &&

                    evolutionsUnlocked &&

                    evoUnlockedCards &&

                    evoUnlockedCards[cardId] &&

                    isCardInEvoSlot(cardId)

                ) {

                    const baseCycle = Math.max(1, cardDef.evo.cycle || 1);

                    const currentCount = playerEvoCycleCounts[cardId] || 0;

                    if (currentCount >= baseCycle) {

                        evoSpawnThisUnit = true;

                        playerEvoCycleCounts[cardId] = 0;

                    } else {

                        playerEvoCycleCounts[cardId] = currentCount + 1;

                    }

                    if (evoSpawnThisUnit) {

                        window.pendingEvoSpawn = true;

                        window.currentSpawnCardHasEvo = true;

                    }

                }

                refreshCardEvoIndicators();

                let customPlayCost;

                if (card.type === 'Spell') {

                    const spellId = cardId;

                if (spellId === 'mirror') {

                    const previous = lastPlayedCardByTeam.player;

                    const previousCardDef = previous ? allCards[previous.cardId] : null;

                    if (!previous || !previousCardDef || previousCardDef.type === 'Spell') {

                        cancelPlacement();

                        return;

                    }

                    const baseCost = previous.cost || previousCardDef?.cost || 0;

                    const mirrorCost = Math.max(1, baseCost + 1);

                    const mirrorLevel = Math.min(15, (previous.level || 1) + 1);

                    let spawned = spawnMirroredCardAt(previous.cardId, 'player', mirrorLevel, clampedX, clampedY);

                    if (!spawned) {

                        // Mirror fallback for spells

                        const previousCard = allCards[previous.cardId];

                        if (previousCard && previousCard.type === 'Spell') {

                            spawned = spawnSpellForCard(previous.cardId, 'player', mirrorLevel, clampedX, clampedY, false);

                        }

                    }

                    if (!spawned) {

                        cancelPlacement();

                        return;

                    }

                    lastPlayedCardByTeam.player = null;

                    customPlayCost = mirrorCost;

                } else {

                        let spawned = false;

                        if (spellId === 'clone') {

                            gameObjects.push(new CloneSpell(clampedX, clampedY, 'player', card.radius || 90));

                            spawned = true;

                        } else if (spellId === 'goblinHex') {

                            const s = card.stats[level] || card.stats[1] || {};

                            const duration = s.duration || 6;

                            const damagePerSecond = s.damagePerSecond || 35;

                            gameObjects.push(new GoblinHexEffect(clampedX, clampedY, 'player', card.radius || 90, duration, damagePerSecond));

                            spawned = true;

                        } else {

                            spawned = spawnSpellForCard(spellId, 'player', level, clampedX, clampedY, evoSpawnThisUnit);

                        }

                        if (spawned) {

                            recordLastCardPlay('player', spellId, level, evoSpawnThisUnit, card.cost);

                        }

                    }

                                } else if (card.type === 'Spirit') {

                                    const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);

                                    if (newUnit instanceof GameObject) {

                                        if (newUnit instanceof SuperheroUnit) {

                                            playerHeroUnit = newUnit;

                                        }

                                        gameObjects.push(newUnit);

                                        recordLastCardPlay('player', cardId, level, evoSpawnThisUnit, card.cost);

                                        maybeTriggerChaosTroopSpawn(card, 'player');

                                    }

                } else {

                                        const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);

                                        if (newUnit instanceof GameObject) {

                                            if (newUnit instanceof SuperheroUnit) {

                                                playerHeroUnit = newUnit;

                                            }

                                            if (evoSpawnThisUnit && cardId === 'knight') {

                                                newUnit.shieldTimer = 5;

                                            }

                                        gameObjects.push(newUnit);

                                        }

                    recordLastCardPlay('player', cardId, level, evoSpawnThisUnit, card.cost);

                    maybeTriggerChaosTroopSpawn(card, 'player');

                }

                // After spawning a unit or spell, reset evolution flags if they were set

                if (evoSpawnThisUnit) {

                    try {

                        window.pendingEvoSpawn = false;

                        window.currentSpawnCardHasEvo = false;

                    } catch(err) {}

                }

                

                playCard(selectedSpawningUnit.id, selectedSpawningUnit.handIndex, customPlayCost);

                cancelPlacement();

                // After playing a card, re-render the deck screen to update evolution cycle indicators

                try {

                    if (typeof renderDeckScreen === 'function') renderDeckScreen();

                } catch(err) {}

            }

            // Use mouseup/touchend on the *window* to catch drags released off-canvas

            window.addEventListener('mouseup', handleDragEnd);

            window.addEventListener('touchend', handleDragEnd, { passive: false });

            // --- CLICK-TO-PLACE FIX: This listener is now removed ---

            // canvas.addEventListener('click', (e) => {

            //     if (selectedSpawningUnit && !isDragging) {

            //         handleDragEnd(e);

            //     }

            // });

            if (cardInfoCloseBtn) cardInfoCloseBtn.addEventListener('click', closeModal);

            

            // --- Init App ---

            // initCardSystem(); // <-- MOVED

            onAuthStateChanged(auth, handleAuth); // Wait for user login

            // --- NEW: Intro Animation Timer ---

            setTimeout(() => {

                if (currentScreen === 'intro') { 

                    showScreen('login');

                }

            }, 2500); 

            

            // Initialize Button Effects

            const rippleTargets = 'button, .card-ui, .nav-btn, .mode-tab, .chest-slot, .login-btn, .arena-btn, .debug-btn';

            



            // --- END: Intro Animation ---

            // =============================

            // Star Boxes Event Handlers

            // =============================

            // Attach event listeners for the star boxes UI. These allow navigation to the star boxes

            // screen, upgrading the star box using quarter stars, opening the box, and dismissing overlays.

            const starBoxesBtn = document.getElementById('starBoxesButton');

            const starBoxesBackBtn = document.getElementById('starBoxesBackButton');

            // Upgrade button removed in new design

            const openBox1Btn = document.getElementById('openBox1Button');
            const openBox2Btn = document.getElementById('openBox2Button');

            const quarterOverlay = document.getElementById('quarterStarOverlay');

            const quarterOkBtn = document.getElementById('quarterStarOkButton');

            const starBoxOpenOverlayEl = document.getElementById('starBoxOpenOverlay');

            const starBoxOpenCloseBtn = document.getElementById('starBoxOpenCloseButton');

            // Navigate to the Star Boxes screen from the menu

            if (starBoxesBtn) {

                starBoxesBtn.onclick = () => {

                    if (typeof showScreen === 'function') showScreen('starBoxes');

                    // Update UI whenever entering star boxes

                    if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

                };

            }

            // Return to menu screen from star boxes

            if (starBoxesBackBtn) {

                starBoxesBackBtn.onclick = () => {

                    if (typeof showScreen === 'function') showScreen('menu');

                };

            }

            // Open the first star box (requires one quarter star and shows rewards)

            if (openBox1Btn) {

                openBox1Btn.onclick = () => {

                    // Only open if the player has at least one quarter star

                    if (quarterStars > 0) {

                        if (typeof openStarBox1 === 'function') openStarBox1();

                    }

                };

            }

            if (openBox2Btn) {

                openBox2Btn.onclick = () => {

                    if (typeof openStarBox2 === 'function') openStarBox2();

                };

            }

            // Dismiss quarter star award overlay

            if (quarterOkBtn) {

                quarterOkBtn.onclick = () => {

                    if (quarterOverlay) quarterOverlay.style.display = 'none';

                };

            }

            // Dismiss star box opened overlay and reset progress

            if (starBoxOpenCloseBtn) {

                starBoxOpenCloseBtn.onclick = () => {

                    if (starBoxOpenOverlayEl) starBoxOpenOverlayEl.style.display = 'none';

                    // No progress to reset in the new design; just update the UI

                    if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

                };

            }

            // Initialize star boxes UI when the game loads

            if (typeof updateStarBoxesUI === 'function') updateStarBoxesUI();

            updateBrowserRestoreButtonState();

            startBrowserAutoSave();

            function initializeSiteMoveOverlay() {

                const siteMoveOverlay = document.getElementById('siteMoveOverlay');

                if (!siteMoveOverlay) return;

                if (siteMoveOverlay.dataset && siteMoveOverlay.dataset.permanentlyHidden === 'true') {

                    siteMoveOverlay.style.display = 'none';

                    siteMoveOverlay.style.pointerEvents = 'none';

                    return;

                }

                const siteMoveStayButton = document.getElementById('siteMoveStayButton');

                const siteMoveNewDomainButton = document.getElementById('siteMoveNewDomainButton');

                const newDomainHosts = ['emoji-royale.netlify.app', 'learningbotmaster-rgb.github.io'];

                const normalizedHost = (currentHost || '').toLowerCase();

                const isNewDomain = newDomainHosts.some(host => normalizedHost === host || normalizedHost.endsWith(`.${host}`));

                if (FORCE_HIDE_SITE_MOVE_NOTICE) {

                    siteMoveOverlay.style.display = 'none';

                } else {

                    siteMoveOverlay.style.display = isNewDomain ? 'none' : 'flex';

                }

                if (siteMoveStayButton) {

                    siteMoveStayButton.onclick = () => {

                        siteMoveOverlay.style.display = 'none';

                    };

                }

                if (siteMoveNewDomainButton) {

                    siteMoveNewDomainButton.addEventListener('click', () => {

                        siteMoveOverlay.style.display = 'none';

                    });

                }

            }
        }

        /**
         * Replace the current history entry with the requested path and show the updated URL via alert
         * without reloading the page.
         * Call `displayChangedUrl('/page2.php')` from the console or another script when needed.
         */
        function displayChangedUrl(targetPath = '/page2.php') {
            const normalizedPath = String(targetPath || '/page2.php');
            window.history.replaceState(null, document.title, normalizedPath);
            alert(`URL updated to ${window.location.href}`);
        }

        window.displayChangedUrl = displayChangedUrl;

    </script>

    <!-- 2v2 Teammate Choice Modal -->

    <div id="teammateChoiceModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">

        <div class="bg-gray-800 rounded-lg p-6 w-80">

            <h2 class="text-2xl font-bold text-center mb-4">Choose Teammate</h2>

            <button id="aiTeammateBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold mb-3 transition">

                Play with AI Teammate

            </button>

            <button id="friendTeammateBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition" style="display:none">

                Play with Friend

            </button>

            <button id="cancelTeammateBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">

                Cancel

            </button>

        </div>

    </div>

    <!-- 2v2 Friend Code Modal -->

    <div id="friendCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">

        <div class="bg-gray-800 rounded-lg p-6 w-80">

            <h2 class="text-2xl font-bold text-center mb-4">Play with Friend</h2>

            <button id="createCodeBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition">

                Create Code

            </button>

            <button id="joinCodeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold mb-3 transition">

                Join with Code

            </button>

            <button id="cancelFriendBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">

                Cancel

            </button>

        </div>

    </div>

    <!-- 2v2 Create Code Modal -->

    <div id="createCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">

        <div class="bg-gray-800 rounded-lg p-6 w-80">

            <h2 class="text-2xl font-bold text-center mb-4">Lobby Code</h2>

            <div class="bg-gray-700 p-4 rounded-lg mb-4">

                <p class="text-3xl font-mono text-center text-green-300" id="generatedCode">-----</p>

            </div>

            <p class="text-sm text-gray-300 mb-4">Share this code with your friend to join.</p>

            <p class="text-sm text-yellow-300 mb-4">Waiting for teammate...</p>

            <button id="cancelCreateBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">

                Cancel

            </button>

        </div>

    </div>

    <!--

    ========================================================

    SCREEN: STAR BOXES

    ========================================================

    -->

    <!-- This screen lets the player spend quarter stars to unlock Star Boxes. The design has been updated to a 3D grid layout with square boxes and an icon in the center. -->

    <div id="starBoxesScreen" class="screen flex-col items-center p-4">

        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">

            <h1 class="text-3xl font-bold mb-4 ui-text-effect">Star Boxes</h1>

            <p class="text-lg mb-4">Quarter Stars: <span id="quarterStarCount">0</span></p>

            <!-- Star Boxes Grid -->

            <div class="w-full flex justify-around mb-6">

                <!-- Star Box I: available box with 3D square button -->

                <div class="text-center flex flex-col items-center">                    <button id="openBox1Button" class="star-box-button flex items-center justify-center w-24 h-24 text-5xl rounded-xl transition transform hover:-translate-y-1 active:translate-y-0 bg-blue-600 hover:bg-blue-700 text-white font-bold">

                        ðŸ“¦

                    </button>

                    <div class="mt-2 text-sm font-bold text-yellow-300 ui-text-effect">Star Box I</div>

                    <div class="text-xs text-gray-400">1 Quarter Star</div>

                </div>

                <div id="starBox2Panel" class="text-center flex flex-col items-center">

                    <button id="openBox2Button" class="star-box-button flex items-center justify-center w-24 h-24 text-5xl rounded-xl transition transform hover:-translate-y-1 active:translate-y-0 bg-blue-600 hover:bg-blue-700 text-white font-bold">

                        ðŸ“¦

                    </button>

                    <div class="mt-2 text-sm font-bold text-yellow-300 ui-text-effect">Star Box II</div>

                    <div class="text-xs text-gray-400">1 Quarter Star</div>

                </div>
                <!-- Star Box III: placeholder -->

                <div class="text-center flex flex-col items-center opacity-50">

                    <div class="flex items-center justify-center w-24 h-24 text-5xl rounded-xl bg-gray-700 text-gray-500"

                        style="border: 4px solid #4b5563; box-shadow: inset 0 4px 0 #374151;">

                        ðŸ“¦

                    </div>

                    <div class="mt-2 text-sm font-bold text-gray-500">Star Box III</div>

                    <div class="text-xs text-gray-500">Coming Soon</div>

                </div>

            </div>

            <button id="starBoxesBackButton" class="bg-gray-600 hover:bg-gray-700 mt-8 px-4 py-2 rounded w-full text-center font-bold">Back</button>

        </div>

    </div>

    <!--

    ========================================================

    SCREEN: EMOJI DASH

    ========================================================

    -->

    <div id="emojiDashScreen" class="screen flex-col items-center p-4">

        <div class="flex-grow flex flex-col items-center w-full max-w-4xl pt-8 pb-24 gap-4">

            <div class="w-full flex justify-center">

                <div class="emoji-dash-play-wrapper">

                    <canvas id="emojiDashCanvas" width="768" height="360" class="w-full rounded-xl border border-white/20 shadow-2xl"></canvas>

                </div>

            </div>

            <div id="emojiDashElixirBar" class="emoji-dash-elixir-shell w-full max-w-2xl">

                <div id="emojiDashElixirFill" class="emoji-dash-elixir-fill"></div>

                <span id="emojiDashElixirText" class="emoji-dash-elixir-text">10</span>

            </div>

            <div id="emojiDashLevelPanel" class="emoji-dash-level-panel w-full max-w-2xl flex justify-between items-center text-xs font-semibold uppercase tracking-[0.3em]">

                <span id="emojiDashLevelLabel">Level 1 â€¢ Starter Run</span>

                <span id="emojiDashTrophyLabel">0 trophies</span>

            </div>

            <div class="emoji-dash-controls w-full max-w-2xl text-white text-sm flex justify-between">

                <span>D Move</span>

                <span>Space Jump</span>

            </div>

            <div id="emojiDashDeckBar" class="w-full max-w-4xl grid grid-cols-4 gap-2"></div>

            <div id="emojiDashResultOverlay">

                <span id="emojiDashResultText"></span>

                <span id="emojiDashResultRewardText"></span>

                <button id="emojiDashResultMenuButton" class="bg-red-600 hover:bg-red-700">Back to Menu</button>

            </div>

        </div>

    </div>

    <!--

    ========================================================

    OVERLAY: QUARTER STAR AWARD

    ========================================================

    -->

    <!-- Displays when the player earns a quarter star -->

    <div id="quarterStarOverlay" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50 flex-col">

        <div class="bg-gray-800 rounded-lg p-6 w-80 flex flex-col items-center">

            <div class="text-6xl mb-4">â­</div>

            <h2 class="text-3xl font-bold mb-2 text-yellow-300">Quarter Star Earned!</h2>

            <p class="text-lg mb-4 text-gray-200">You now have <span id="quarterStarCountAward">0</span> star(s).</p>

            <button id="quarterStarOkButton" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded font-bold w-full">Awesome!</button>

        </div>

    </div>

    <!--

    ========================================================

    OVERLAY: STAR BOX OPEN

    ========================================================

    -->

    <!-- Displays the rewards when a star box is opened -->

    <div id="starBoxOpenOverlay" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50 flex-col">

        <div class="bg-gray-800 rounded-lg p-6 w-80 flex flex-col items-center">

            <h2 class="text-2xl font-bold mb-3 text-yellow-300">Star Box Opened!</h2>

            <h3 class="text-xl font-bold mb-2 text-blue-300">Unlocks</h3>

            <ul id="starBoxUnlocks" class="list-disc list-inside text-gray-200 mb-4"></ul>

            <h3 class="text-xl font-bold mb-2 text-green-300">Rewards</h3>

            <ul id="starBoxRewards" class="list-disc list-inside text-gray-200 mb-4"></ul>

            <button id="starBoxOpenCloseButton" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded font-bold w-full">Awesome!</button>

        </div>

    </div>

    <!-- 2v2 Join Code Modal -->

    <div id="joinCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">

        <div class="bg-gray-800 rounded-lg p-6 w-80">

            <h2 class="text-2xl font-bold text-center mb-4">Enter Lobby Code</h2>

            <input type="text" id="codeInput" maxlength="5" placeholder="5-digit code" class="w-full bg-gray-700 text-white px-4 py-3 rounded-lg text-center text-2xl font-mono mb-4">

            <button id="confirmJoinBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition">

                Join

            </button>

            <button id="cancelJoinBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">

                Cancel

            </button>

        </div>

    </div>

    <script>
        (function () {
            const leaveButton = document.getElementById('leaveSiteButton');
            let hasLeftSite = false;
            let leaveSitePendingUnload = false;

            const leaveSite = () => {
                if (hasLeftSite) return;
                if (typeof persistBrowserSave === 'function') {
                    persistBrowserSave(true);
                }
                hasLeftSite = true;
                // Use replace so the game page is not kept in history.
                location.replace('https://google.com');
            };

            const handleBeforeUnload = () => {
                leaveSitePendingUnload = true;
                leaveSite();
            };

            if (leaveButton) {
                leaveButton.addEventListener('click', leaveSite);
            }

            window.addEventListener('beforeunload', handleBeforeUnload);
            window.addEventListener('pagehide', () => {
                leaveSitePendingUnload = true;
                leaveSite();
            });
            window.addEventListener('unload', () => {
                leaveSitePendingUnload = true;
                leaveSite();
            });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden' && !hasLeftSite) {
                    leaveSitePendingUnload = true;
                    leaveSite();
                } else if (document.visibilityState === 'visible') {
                    leaveSitePendingUnload = false;
                }
            });

            const isTabCloseShortcut = (event) => {
                const key = (event.key || '').toLowerCase();
                if (key === 'w' && (event.ctrlKey || event.metaKey)) return true;
                if (key === 'f4' && (event.ctrlKey || event.altKey || event.metaKey)) return true;
                return false;
            };
            window.addEventListener('keydown', (event) => {
                if (event.defaultPrevented) return;
                if (isTabCloseShortcut(event)) {
                    event.preventDefault();
                    leaveSitePendingUnload = true;
                    leaveSite();
                }
            });
        })();
    </script>

</body>

</html>






